/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({ getServiceDefinition, getHandlers });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer;\n//# sourceMappingURL=admin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9hZG1pbi5qcz81NTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSB2b2lkIDA7XG5jb25zdCByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJBZG1pblNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzKSB7XG4gICAgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMucHVzaCh7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9KTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSByZWdpc3RlckFkbWluU2VydmljZTtcbmZ1bmN0aW9uIGFkZEFkbWluU2VydmljZXNUb1NlcnZlcihzZXJ2ZXIpIHtcbiAgICBmb3IgKGNvbnN0IHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0gb2YgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMpIHtcbiAgICAgICAgc2VydmVyLmFkZFNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24oKSwgZ2V0SGFuZGxlcnMoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZG1pbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */\n        this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */\n        this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */\n        this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */\n        this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */\n        this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */\n        this.startTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(() => {\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */\n    reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            }\n            else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */\n    ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */\n    unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\n//# sourceMappingURL=backoff-timeout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9iYWNrb2ZmLXRpbWVvdXQuanM/ZDE4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IHZvaWQgMDtcbmNvbnN0IElOSVRJQUxfQkFDS09GRl9NUyA9IDEwMDA7XG5jb25zdCBCQUNLT0ZGX01VTFRJUExJRVIgPSAxLjY7XG5jb25zdCBNQVhfQkFDS09GRl9NUyA9IDEyMDAwMDtcbmNvbnN0IEJBQ0tPRkZfSklUVEVSID0gMC4yO1xuLyoqXG4gKiBHZXQgYSBudW1iZXIgdW5pZm9ybWx5IGF0IHJhbmRvbSBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4KVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiB1bmlmb3JtUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cbmNsYXNzIEJhY2tvZmZUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgdGltZSBhdCB0aGUgc3RhcnQsIGFuZCBhZnRlciBlYWNoIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBJTklUSUFMX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwb25lbnRpYWwgYmFja29mZiBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gQkFDS09GRl9NVUxUSVBMSUVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZGVsYXkgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhEZWxheSA9IE1BWF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZnJhY3Rpb24gYnkgd2hpY2ggdGhlIGRlbGF5IHRpbWUgY2FuIHJhbmRvbWx5IHZhcnkgYWZ0ZXJcbiAgICAgICAgICogYXBwbHlpbmcgdGhlIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmppdHRlciA9IEJBQ0tPRkZfSklUVEVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2VzcyBydW5uaW5nIGlmIG5vXG4gICAgICAgICAqIG90aGVyIGFzeW5jIG9wZXJhdGlvbiBpcyBkb2luZyBzby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdhcyBzdGFydGVkLiBPbmx5IHZhbGlkIGlmXG4gICAgICAgICAqIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxEZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICB9XG4gICAgcnVuVGltZXIoZGVsYXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlZikge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSBjdXJyZW50IGFtb3VudCBvZiBkZWxheSB0aW1lXG4gICAgICovXG4gICAgcnVuT25jZSgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnJ1blRpbWVyKHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBNYXRoLm1pbih0aGlzLm5leHREZWxheSAqIHRoaXMubXVsdGlwbGllciwgdGhpcy5tYXhEZWxheSk7XG4gICAgICAgIGNvbnN0IGppdHRlck1hZ25pdHVkZSA9IG5leHRCYWNrb2ZmICogdGhpcy5qaXR0ZXI7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID1cbiAgICAgICAgICAgIG5leHRCYWNrb2ZmICsgdW5pZm9ybVJhbmRvbSgtaml0dGVyTWFnbml0dWRlLCBqaXR0ZXJNYWduaXR1ZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0aW1lci4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB1bnRpbCBgcnVuT25jZWAgaXMgY2FsbGVkXG4gICAgICogYWdhaW4uXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgZGVsYXkgdGltZSB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gSWYgdGhlIHRpbWVyIGlzIHN0aWxsIHJ1bm5pbmcsXG4gICAgICogcmV0cm9hY3RpdmVseSBhcHBseSB0aGF0IHJlc2V0IHRvIHRoZSBjdXJyZW50IHRpbWVyLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm5leHREZWxheSA9IHRoaXMuaW5pdGlhbERlbGF5O1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICAgICAgbmV3RW5kVGltZS5zZXRNaWxsaXNlY29uZHMobmV3RW5kVGltZS5nZXRNaWxsaXNlY29uZHMoKSArIHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICAgICAgaWYgKG5vdyA8IG5ld0VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVyKG5ld0VuZFRpbWUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQga2VlcCB0aGUgTm9kZSBwcm9jZXNzXG4gICAgICogcnVubmluZy5cbiAgICAgKi9cbiAgICByZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoYXQgd2hpbGUgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIGl0IHNob3VsZCBub3Qga2VlcCB0aGUgTm9kZSBwcm9jZXNzXG4gICAgICogcnVubmluZy5cbiAgICAgKi9cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5oYXNSZWYgPSBmYWxzZTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSBCYWNrb2ZmVGltZW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtdGltZW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n    constructor(channel, stream) {\n        var _a, _b;\n        super();\n        this.channel = channel;\n        this.stream = stream;\n        this.channel = channel;\n        this.stream = stream;\n        const splitPath = stream.getMethod().split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    async sendMetadata(metadata) {\n        const credentials = this.stream.getCredentials();\n        const credsMetadata = credentials.generateMetadata({\n            service_url: this.serviceUrl,\n        });\n        const resultMetadata = await metadata;\n        try {\n            resultMetadata.merge(await credsMetadata);\n        }\n        catch (error) {\n            this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n            return Promise.reject('Failed to retrieve auth metadata');\n        }\n        if (resultMetadata.get('authorization').length > 1) {\n            this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n            return Promise.reject('\"authorization\" metadata cannot have multiple values');\n        }\n        return resultMetadata;\n    }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CallCredentialsFilter(this.channel, callStream);\n    }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;\n//# sourceMappingURL=call-credentials-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRyw2QkFBNkI7QUFDcEUsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxFQUFFLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLEdBQUcsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkgsY0FBYztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtY3JlZGVudGlhbHMtZmlsdGVyLmpzPzg5OWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jbGFzcyBDYWxsQ3JlZGVudGlhbHNGaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBzdHJlYW0uZ2V0TWV0aG9kKCkuc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IHNlcnZpY2VOYW1lID0gJyc7XG4gICAgICAgIC8qIFRoZSBzdGFuZGFyZCBwYXRoIGZvcm1hdCBpcyBcIi97c2VydmljZU5hbWV9L3ttZXRob2ROYW1lfVwiLCBzbyBpZiB3ZSBzcGxpdFxuICAgICAgICAgKiBieSAnLycsIHRoZSBmaXJzdCBpdGVtIHNob3VsZCBiZSBlbXB0eSBhbmQgdGhlIHNlY29uZCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAqIHNlcnZpY2UgbmFtZSAqL1xuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBzZXJ2aWNlTmFtZSA9IHNwbGl0UGF0aFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0bmFtZSA9IChfYiA9IChfYSA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHN0cmVhbS5nZXRIb3N0KCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2xvY2FsaG9zdCc7XG4gICAgICAgIC8qIEN1cnJlbnRseSwgY2FsbCBjcmVkZW50aWFscyBhcmUgb25seSBhbGxvd2VkIG9uIEhUVFBTIGNvbm5lY3Rpb25zLCBzbyB3ZVxuICAgICAgICAgKiBjYW4gYXNzdW1lIHRoYXQgdGhlIHNjaGVtZSBpcyBcImh0dHBzXCIgKi9cbiAgICAgICAgdGhpcy5zZXJ2aWNlVXJsID0gYGh0dHBzOi8vJHtob3N0bmFtZX0vJHtzZXJ2aWNlTmFtZX1gO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLnN0cmVhbS5nZXRDcmVkZW50aWFscygpO1xuICAgICAgICBjb25zdCBjcmVkc01ldGFkYXRhID0gY3JlZGVudGlhbHMuZ2VuZXJhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBzZXJ2aWNlX3VybDogdGhpcy5zZXJ2aWNlVXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0TWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLm1lcmdlKGF3YWl0IGNyZWRzTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVELCBgRmFpbGVkIHRvIHJldHJpZXZlIGF1dGggbWV0YWRhdGEgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdGYWlsZWQgdG8gcmV0cmlldmUgYXV0aCBtZXRhZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRNZXRhZGF0YS5nZXQoJ2F1dGhvcml6YXRpb24nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdcImF1dGhvcml6YXRpb25cIiBtZXRhZGF0YSBjYW5ub3QgaGF2ZSBtdWx0aXBsZSB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TWV0YWRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHNGaWx0ZXIgPSBDYWxsQ3JlZGVudGlhbHNGaWx0ZXI7XG5jbGFzcyBDYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbENyZWRlbnRpYWxzRmlsdGVyKHRoaXMuY2hhbm5lbCwgY2FsbFN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5ID0gQ2FsbENyZWRlbnRpYWxzRmlsdGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMtZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return ('getRequestHeaders' in client &&\n        typeof client.getRequestHeaders === 'function');\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */\n    static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */\n    static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            }\n            else {\n                getHeaders = new Promise((resolve, reject) => {\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers) => {\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)) {\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err) => {\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds) {\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));\n        for (const gen of generated) {\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([other]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator) {\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject) => {\n            this.metadataGenerator(options, (err, metadata) => {\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([this, other]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n}\n//# sourceMappingURL=call-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtY3JlZGVudGlhbHMuanM/YjIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5mdW5jdGlvbiBpc0N1cnJlbnRPYXV0aDJDbGllbnQoY2xpZW50KSB7XG4gICAgcmV0dXJuICgnZ2V0UmVxdWVzdEhlYWRlcnMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50LmdldFJlcXVlc3RIZWFkZXJzID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBnZW5lcmljIG1ldGhvZCBvZiBhZGRpbmcgYXV0aGVudGljYXRpb24tcmVsYXRlZFxuICogbWV0YWRhdGEgb24gYSBwZXItcmVxdWVzdCBiYXNpcy5cbiAqL1xuY2xhc3MgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENhbGxDcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIGdpdmVuIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzXG4gICAgICogTWV0YWRhdGEgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFHZW5lcmF0b3IgQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBzZXQgb2Ygb3B0aW9ucywgYW5kXG4gICAgICogZ2VuZXJhdGVzIGEgTWV0YWRhdGEgb2JqZWN0IGJhc2VkIG9uIHRoZXNlIG9wdGlvbnMsIHdoaWNoIGlzIHBhc3NlZCBiYWNrXG4gICAgICogdG8gdGhlIGNhbGxlciB2aWEgYSBzdXBwbGllZCAoZXJyLCBtZXRhZGF0YSkgY2FsbGJhY2suXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcihtZXRhZGF0YUdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFNpbmdsZUNhbGxDcmVkZW50aWFscyhtZXRhZGF0YUdlbmVyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdSUEMgY3JlZGVudGlhbCBmcm9tIGEgR29vZ2xlIGNyZWRlbnRpYWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBnb29nbGVDcmVkZW50aWFscyBUaGUgYXV0aGVudGljYXRpb24gY2xpZW50IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwoZ29vZ2xlQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIENhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IoKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBsZXQgZ2V0SGVhZGVycztcbiAgICAgICAgICAgIGlmIChpc0N1cnJlbnRPYXV0aDJDbGllbnQoZ29vZ2xlQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyA9IGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RIZWFkZXJzKG9wdGlvbnMuc2VydmljZV91cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlQ3JlZGVudGlhbHMuZ2V0UmVxdWVzdE1ldGFkYXRhKG9wdGlvbnMuc2VydmljZV91cmwsIChlcnIsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEhlYWRlcnMudGhlbigoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5hZGQoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5Q2FsbENyZWRlbnRpYWxzKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSBDYWxsQ3JlZGVudGlhbHM7XG5jbGFzcyBDb21wb3NlZENhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY3JlZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jcmVkcyA9IGNyZWRzO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY3JlZHMubWFwKChjcmVkKSA9PiBjcmVkLmdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykpKTtcbiAgICAgICAgZm9yIChjb25zdCBnZW4gb2YgZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICBiYXNlLm1lcmdlKGdlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyh0aGlzLmNyZWRzLmNvbmNhdChbb3RoZXJdKSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlZHMuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUuX2VxdWFscyhvdGhlci5jcmVkc1tpbmRleF0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9IG1ldGFkYXRhR2VuZXJhdG9yO1xuICAgIH1cbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3Iob3B0aW9ucywgKGVyciwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKFt0aGlzLCBvdGhlcl0pO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9PT0gb3RoZXIubWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFbXB0eUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEVtcHR5Q2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-stream.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'call_stream';\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL, } = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)) {\n        if (num === errno) {\n            return name;\n        }\n    }\n    return 'Unknown system error ' + errno;\n}\nfunction getMinDeadline(deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList) {\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nfunction isInterceptingListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata) => {\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg) => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            }\n            else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus) => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            }\n            else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\nclass Http2CallStream {\n    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.channelCallCredentials = channelCallCredentials;\n        this.callNumber = callNumber;\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.isWriteFilterPending = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.writesClosed = false;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */\n        this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.subchannel = null;\n        this.listener = null;\n        this.internalError = null;\n        this.configDeadline = Infinity;\n        this.statusWatchers = [];\n        this.streamEndWatchers = [];\n        this.callStatsTracker = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n        this.credentials = channelCallCredentials;\n        this.disconnectListener = () => {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Connection dropped',\n                metadata: new metadata_1.Metadata(),\n            });\n        };\n        if (this.options.parentCall &&\n            this.options.flags & constants_1.Propagate.CANCELLATION) {\n            this.options.parentCall.on('cancelled', () => {\n                this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n            });\n        }\n    }\n    outputStatus() {\n        var _a;\n        /* Precondition: this.finalStatus !== null */\n        if (this.listener && !this.statusOutput) {\n            this.statusOutput = true;\n            const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n            this.trace('ended with status: code=' +\n                filteredStatus.code +\n                ' details=\"' +\n                filteredStatus.details +\n                '\"');\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */\n            process.nextTick(() => {\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */\n            (_a = this.http2Stream) === null || _a === void 0 ? void 0 : _a.resume();\n            if (this.subchannel) {\n                this.subchannel.callUnref();\n                this.subchannel.removeDisconnectListener(this.disconnectListener);\n            }\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */\n            if (this.finalStatus.code !== constants_1.Status.OK ||\n                (this.readsClosed &&\n                    this.unpushedReadMessages.length === 0 &&\n                    this.unfilteredReadMessages.length === 0 &&\n                    !this.isReadFilterPending)) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace('pushing to reader message of length ' +\n            (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        process.nextTick(() => {\n            var _a;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */\n            if (this.statusOutput) {\n                return;\n            }\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(message);\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + message.length);\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */\n            const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.trace('filterReceivedMessage of length ' + framedMessage.length);\n        this.isReadFilterPending = true;\n        this.filterStack\n            .receiveMessage(Promise.resolve(framedMessage))\n            .then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.trace('unfilteredReadMessages.push message of length ' +\n                (messageBytes && messageBytes.length));\n            this.unfilteredReadMessages.push(messageBytes);\n        }\n        else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.streamEndWatchers.forEach(watcher => watcher(true));\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server trailers:\\n' + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN &&\n            typeof metadataMap['grpc-status'] === 'string') {\n            const receivedStatus = Number(metadataMap['grpc-status']);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace('received status code ' + receivedStatus + ' from server');\n            }\n            metadata.remove('grpc-status');\n        }\n        let details = '';\n        if (typeof metadataMap['grpc-message'] === 'string') {\n            try {\n                details = decodeURI(metadataMap['grpc-message']);\n            }\n            catch (e) {\n                details = metadataMap['grpc-message'];\n            }\n            metadata.remove('grpc-message');\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = { code, details, metadata };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    writeMessageToStream(message, callback) {\n        var _a;\n        (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n        this.http2Stream.write(message, callback);\n    }\n    attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {\n        this.filterStack.push(extraFilters);\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        }\n        else {\n            this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n            this.http2Stream = stream;\n            this.subchannel = subchannel;\n            this.callStatsTracker = callStatsTracker;\n            subchannel.addDisconnectListener(this.disconnectListener);\n            subchannel.callRef();\n            stream.on('response', (headers, flags) => {\n                var _a;\n                let headersString = '';\n                for (const header of Object.keys(headers)) {\n                    headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n                }\n                this.trace('Received server headers:\\n' + headersString);\n                switch (headers[':status']) {\n                    // TODO(murgatroid99): handle 100 and 101\n                    case 400:\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case 401:\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case 403:\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case 404:\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case 429:\n                    case 502:\n                    case 503:\n                    case 504:\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                }\n                else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                        return;\n                    }\n                    try {\n                        const finalMetadata = this.filterStack.receiveMetadata(metadata);\n                        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata(),\n                        });\n                    }\n                }\n            });\n            stream.on('trailers', (headers) => {\n                this.handleTrailers(headers);\n            });\n            stream.on('data', (data) => {\n                /* If the status has already been output, allow the http2 stream to\n                 * drain without processing the data. */\n                if (this.statusOutput) {\n                    return;\n                }\n                this.trace('receive HTTP/2 data frame of length ' + data.length);\n                const messages = this.decoder.write(data);\n                for (const message of messages) {\n                    this.trace('parsed message of length ' + message.length);\n                    this.callStatsTracker.addMessageReceived();\n                    this.tryPush(message);\n                }\n            });\n            stream.on('end', () => {\n                this.readsClosed = true;\n                this.maybeOutputStatus();\n            });\n            stream.on('close', () => {\n                /* Use process.next tick to ensure that this code happens after any\n                 * \"error\" event that may be emitted at about the same time, so that\n                 * we can bubble up the error message from that event. */\n                process.nextTick(() => {\n                    var _a;\n                    this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n                    /* If we have a final status with an OK status code, that means that\n                     * we have received all of the messages and we have processed the\n                     * trailers and the call completed successfully, so it doesn't matter\n                     * how the stream ends after that */\n                    if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                        return;\n                    }\n                    let code;\n                    let details = '';\n                    switch (stream.rstCode) {\n                        case http2.constants.NGHTTP2_NO_ERROR:\n                            /* If we get a NO_ERROR code and we already have a status, the\n                             * stream completed properly and we just haven't fully processed\n                             * it yet */\n                            if (this.finalStatus !== null) {\n                                return;\n                            }\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                            break;\n                        case http2.constants.NGHTTP2_REFUSED_STREAM:\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = 'Stream refused by server';\n                            break;\n                        case http2.constants.NGHTTP2_CANCEL:\n                            code = constants_1.Status.CANCELLED;\n                            details = 'Call cancelled';\n                            break;\n                        case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                            code = constants_1.Status.RESOURCE_EXHAUSTED;\n                            details = 'Bandwidth exhausted or memory limit exceeded';\n                            break;\n                        case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                            code = constants_1.Status.PERMISSION_DENIED;\n                            details = 'Protocol not secure enough';\n                            break;\n                        case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                            code = constants_1.Status.INTERNAL;\n                            if (this.internalError === null) {\n                                /* This error code was previously handled in the default case, and\n                                 * there are several instances of it online, so I wanted to\n                                 * preserve the original error message so that people find existing\n                                 * information in searches, but also include the more recognizable\n                                 * \"Internal server error\" message. */\n                                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n                            }\n                            else {\n                                if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                                    code = constants_1.Status.UNAVAILABLE;\n                                    details = this.internalError.message;\n                                }\n                                else {\n                                    /* The \"Received RST_STREAM with code ...\" error is preserved\n                                     * here for continuity with errors reported online, but the\n                                     * error message at the end will probably be more relevant in\n                                     * most cases. */\n                                    details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                                }\n                            }\n                            break;\n                        default:\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                    }\n                    // This is a no-op if trailers were received at all.\n                    // This is OK, because status codes emitted here correspond to more\n                    // catastrophic issues that prevent us from receiving trailers in the\n                    // first place.\n                    this.endCall({ code, details, metadata: new metadata_1.Metadata() });\n                });\n            });\n            stream.on('error', (err) => {\n                /* We need an error handler here to stop \"Uncaught Error\" exceptions\n                 * from bubbling up. However, errors here should all correspond to\n                 * \"close\" events, where we will handle the error more granularly */\n                /* Specifically looking for stream errors that were *not* constructed\n                 * from a RST_STREAM response here:\n                 * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n                 */\n                if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n                    this.trace('Node error event: message=' +\n                        err.message +\n                        ' code=' +\n                        err.code +\n                        ' errno=' +\n                        getSystemErrorName(err.errno) +\n                        ' syscall=' +\n                        err.syscall);\n                    this.internalError = err;\n                }\n                this.streamEndWatchers.forEach(watcher => watcher(false));\n            });\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error('Invalid state in write handling code');\n                }\n                this.trace('sending data chunk of length ' +\n                    this.pendingWrite.length +\n                    ' (deferred)');\n                try {\n                    this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n            }\n            this.maybeCloseWrites();\n        }\n    }\n    start(metadata, listener) {\n        this.trace('Sending metadata');\n        this.listener = listener;\n        this.channel._startCallStream(this, metadata);\n        this.maybeOutputStatus();\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */\n            let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            }\n            else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace('close http2 stream with code ' + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n    }\n    getDeadline() {\n        const deadlineList = [this.options.deadline];\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n            deadlineList.push(this.options.parentCall.getDeadline());\n        }\n        if (this.configDeadline) {\n            deadlineList.push(this.configDeadline);\n        }\n        return getMinDeadline(deadlineList);\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    setConfigDeadline(configDeadline) {\n        this.configDeadline = configDeadline;\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    addStreamEndWatcher(watcher) {\n        this.streamEndWatchers.push(watcher);\n    }\n    addFilters(extraFilters) {\n        this.filterStack.push(extraFilters);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        }\n        else {\n            if (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.push(nextMessage);\n                return;\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit */\n            this.http2Stream.resume();\n        }\n    }\n    maybeCloseWrites() {\n        if (this.writesClosed &&\n            !this.isWriteFilterPending &&\n            this.http2Stream !== null) {\n            this.trace('calling end() on HTTP/2 stream');\n            this.http2Stream.end();\n        }\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags,\n        };\n        const cb = (error) => {\n            var _a, _b;\n            let code = constants_1.Status.UNAVAILABLE;\n            if (((_a = error) === null || _a === void 0 ? void 0 : _a.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n                code = constants_1.Status.INTERNAL;\n            }\n            if (error) {\n                this.cancelWithStatus(code, `Write error: ${error.message}`);\n            }\n            (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);\n        };\n        this.isWriteFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message) => {\n            this.isWriteFilterPending = false;\n            if (this.http2Stream === null) {\n                this.trace('deferring writing data chunk of length ' + message.message.length);\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            }\n            else {\n                this.trace('sending data chunk of length ' + message.message.length);\n                try {\n                    this.writeMessageToStream(message.message, cb);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n                this.maybeCloseWrites();\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    halfClose() {\n        this.trace('end() called');\n        this.writesClosed = true;\n        this.maybeCloseWrites();\n    }\n}\nexports.Http2CallStream = Http2CallStream;\n//# sourceMappingURL=call-stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxnQ0FBZ0MsR0FBRyw4QkFBOEI7QUFDM0YsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBLFFBQVEsa0VBQWtFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZUFBZTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0Isc0NBQXNDLDJCQUEyQjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvREFBb0Q7QUFDdkYsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBNEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtc3RyZWFtLmpzPzUwZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cDJDYWxsU3RyZWFtID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSBleHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSB2b2lkIDA7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnY2FsbF9zdHJlYW0nO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfU1RBVFVTLCBIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFLCBOR0hUVFAyX0NBTkNFTCwgfSA9IGh0dHAyLmNvbnN0YW50cztcbi8qKlxuICogU2hvdWxkIGRvIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdGhpbmcgYXMgdXRpbC5nZXRTeXN0ZW1FcnJvck5hbWUgYnV0IHRoZVxuICogVHlwZVNjcmlwdCB0eXBlcyBkb24ndCBoYXZlIHRoYXQgZnVuY3Rpb24gZm9yIHNvbWUgcmVhc29uIHNvIEkganVzdCBtYWRlIG15XG4gKiBvd24uXG4gKiBAcGFyYW0gZXJybm9cbiAqL1xuZnVuY3Rpb24gZ2V0U3lzdGVtRXJyb3JOYW1lKGVycm5vKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgbnVtXSBvZiBPYmplY3QuZW50cmllcyhvcy5jb25zdGFudHMuZXJybm8pKSB7XG4gICAgICAgIGlmIChudW0gPT09IGVycm5vKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24gc3lzdGVtIGVycm9yICcgKyBlcnJubztcbn1cbmZ1bmN0aW9uIGdldE1pbkRlYWRsaW5lKGRlYWRsaW5lTGlzdCkge1xuICAgIGxldCBtaW5WYWx1ZSA9IEluZmluaXR5O1xuICAgIGZvciAoY29uc3QgZGVhZGxpbmUgb2YgZGVhZGxpbmVMaXN0KSB7XG4gICAgICAgIGNvbnN0IGRlYWRsaW5lTXNlY3MgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZS5nZXRUaW1lKCkgOiBkZWFkbGluZTtcbiAgICAgICAgaWYgKGRlYWRsaW5lTXNlY3MgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgbWluVmFsdWUgPSBkZWFkbGluZU1zZWNzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5WYWx1ZTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJjZXB0aW5nTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEubGVuZ3RoID09PSAxKTtcbn1cbmV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGlzSW50ZXJjZXB0aW5nTGlzdGVuZXI7XG5jbGFzcyBJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVyLCBuZXh0TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLm5leHRMaXN0ZW5lciA9IG5leHRMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IG51bGw7XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UodGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ1N0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHRoaXMucGVuZGluZ1N0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhLCAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogSWYgdGhpcyBsaXN0ZW5lciBwcm9jZXNzZXMgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHksIHRoZSBsYXN0IG1lc3NhZ2UgbWF5XG4gICAgICAgICAqIGJlIHJlb3JkZXJlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXR1cyAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIChtc2cpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMsIChwcm9jZXNzZWRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gcHJvY2Vzc2VkU3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHByb2Nlc3NlZFN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsID0gSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsO1xuY2xhc3MgSHR0cDJDYWxsU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBjaGFubmVsLCBvcHRpb25zLCBmaWx0ZXJTdGFja0ZhY3RvcnksIGNoYW5uZWxDYWxsQ3JlZGVudGlhbHMsIGNhbGxOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jaGFubmVsQ2FsbENyZWRlbnRpYWxzID0gY2hhbm5lbENhbGxDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1dyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdXcml0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXRlc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGFuICdlbmQnIGV2ZW50IGhhcyBjb21lIGZyb20gdGhlIGh0dHAyIHN0cmVhbSwgc28gdGhlcmVcbiAgICAgICAgICogd2lsbCBiZSBubyBtb3JlIGRhdGEgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMudW5maWx0ZXJlZFJlYWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICAvLyBTdGF0dXMgY29kZSBtYXBwZWQgZnJvbSA6c3RhdHVzLiBUbyBiZSB1c2VkIGlmIGdycGMtc3RhdHVzIGlzIG5vdCByZWNlaXZlZFxuICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTjtcbiAgICAgICAgLy8gVGhpcyBpcyBwb3B1bGF0ZWQgKG5vbi1udWxsKSBpZiBhbmQgb25seSBpZiB0aGUgY2FsbCBoYXMgZW5kZWRcbiAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVybmFsRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ0RlYWRsaW5lID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdHJlYW1FbmRXYXRjaGVycyA9IFtdO1xuICAgICAgICB0aGlzLmNhbGxTdGF0c1RyYWNrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNoYW5uZWxDYWxsQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ0Nvbm5lY3Rpb24gZHJvcHBlZCcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnRDYWxsICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyZW50Q2FsbC5vbignY2FuY2VsbGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIGJ5IHBhcmVudCBjYWxsJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogUHJlY29uZGl0aW9uOiB0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICovXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVyICYmICF0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRTdGF0dXMgPSB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVUcmFpbGVycyh0aGlzLmZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2VuZGVkIHdpdGggc3RhdHVzOiBjb2RlPScgK1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycy5mb3JFYWNoKHdhdGNoZXIgPT4gd2F0Y2hlcihmaWx0ZXJlZFN0YXR1cykpO1xuICAgICAgICAgICAgLyogV2UgZGVsYXkgdGhlIGFjdHVhbCBhY3Rpb24gb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cyB0byBpbnN1bGF0ZSB0aGVcbiAgICAgICAgICAgICAqIGNsZWFudXAgY29kZSBpbiB0aGlzIGNsYXNzIGZyb20gYW55IGVycm9ycyB0aGF0IG1heSBiZSB0aHJvd24gaW4gdGhlXG4gICAgICAgICAgICAgKiB1cHBlciBsYXllcnMgYXMgYSByZXN1bHQgb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICAgICAqIGlmIHRoZSBzdGF0dXMgaXMgbm90IE9LLCB0aGUgXCJlcnJvclwiIGV2ZW50IG1heSBiZSBlbWl0dGVkXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5IGF0IHRoZSB0b3AgbGV2ZWwsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgdGhyb3duIGVycm9yIGlmXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBoYW5kbGUgdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbHRlcmVkU3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogTGVhdmUgdGhlIGh0dHAyIHN0cmVhbSBpbiBmbG93aW5nIHN0YXRlIHRvIGRyYWluIGluY29taW5nIG1lc3NhZ2VzLCB0b1xuICAgICAgICAgICAgICogZW5zdXJlIHRoYXQgdGhlIHN0cmVhbSBjbG9zdXJlIGNvbXBsZXRlcy4gVGhlIGNhbGwgc3RyZWFtIGFscmVhZHkgZG9lc1xuICAgICAgICAgICAgICogbm90IHB1c2ggbW9yZSBtZXNzYWdlcyBhZnRlciB0aGUgc3RhdHVzIGlzIG91dHB1dCwgc28gdGhlIG1lc3NhZ2VzIGdvXG4gICAgICAgICAgICAgKiBub3doZXJlIGVpdGhlciB3YXkuICovXG4gICAgICAgICAgICAoX2EgPSB0aGlzLmh0dHAyU3RyZWFtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdW1lKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsLmNhbGxVbnJlZigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbC5yZW1vdmVEaXNjb25uZWN0TGlzdGVuZXIodGhpcy5kaXNjb25uZWN0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIGZpcnN0IGNhbGwsIGVtaXRzIGEgJ3N0YXR1cycgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gU3RhdHVzT2JqZWN0LlxuICAgICAqIFN1YnNlcXVlbnQgY2FsbHMgYXJlIG5vLW9wcy5cbiAgICAgKiBAcGFyYW0gc3RhdHVzIFRoZSBzdGF0dXMgb2YgdGhlIGNhbGwuXG4gICAgICovXG4gICAgZW5kQ2FsbChzdGF0dXMpIHtcbiAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBpcyBPSyBhbmQgYSBuZXcgc3RhdHVzIGNvbWVzIGluIChlLmcuIGZyb20gYVxuICAgICAgICAgKiBkZXNlcmlhbGl6YXRpb24gZmFpbHVyZSksIHRoYXQgbmV3IHN0YXR1cyB0YWtlcyBwcmlvcml0eSAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyA9PT0gbnVsbCB8fCB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3lIdHRwMlN0cmVhbSgpO1xuICAgIH1cbiAgICBtYXliZU91dHB1dFN0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIFRoZSBjb21iaW5hdGlvbiBjaGVjayBvZiByZWFkc0Nsb3NlZCBhbmQgdGhhdCB0aGUgdHdvIG1lc3NhZ2UgYnVmZmVyXG4gICAgICAgICAgICAgKiBhcnJheXMgYXJlIGVtcHR5IGNoZWNrcyB0aGF0IHRoZXJlIGFsbCBpbmNvbWluZyBkYXRhIGhhcyBiZWVuIGZ1bGx5XG4gICAgICAgICAgICAgKiBwcm9jZXNzZWQgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSyB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnJlYWRzQ2xvc2VkICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5maWx0ZXJlZFJlYWRNZXNzYWdlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHB1c2gobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRyYWNlKCdwdXNoaW5nIHRvIHJlYWRlciBtZXNzYWdlIG9mIGxlbmd0aCAnICtcbiAgICAgICAgICAgIChtZXNzYWdlIGluc3RhbmNlb2YgQnVmZmVyID8gbWVzc2FnZS5sZW5ndGggOiBudWxsKSk7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgdGhlIHN0YXR1cyBhbnkgbGF0ZXIgbWVzc2FnZXMgc2hvdWxkIGJlXG4gICAgICAgICAgICAgKiBpZ25vcmVkLCBhbmQgY2FuIGNhdXNlIG91dC1vZi1vcmRlciBvcGVyYXRpb24gZXJyb3JzIGhpZ2hlciB1cCBpbiB0aGVcbiAgICAgICAgICAgICAqIHN0YWNrLiBDaGVja2luZyBhcyBsYXRlIGFzIHBvc3NpYmxlIGhlcmUgdG8gYXZvaWQgYW55IHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVGaWx0ZXJFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgaGFuZGxlRmlsdGVyZWRSZWFkKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogSWYgd2UgdGhlIGNhbGwgaGFzIGFscmVhZHkgZW5kZWQgd2l0aCBhbiBlcnJvciwgd2UgZG9uJ3Qgd2FudCB0byBkb1xuICAgICAgICAgKiBhbnl0aGluZyB3aXRoIHRoaXMgbWVzc2FnZS4gRHJvcHBpbmcgaXQgb24gdGhlIGZsb29yIGlzIGNvcnJlY3RcbiAgICAgICAgICogYmVoYXZpb3IgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgndW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVuZmlsdGVyZWRSZWFkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLyogbmV4dE1lc3NhZ2UgaXMgZ3VhcmFudGVlZCBub3QgdG8gYmUgdW5kZWZpbmVkIGJlY2F1c2VcbiAgICAgICAgICAgICAgIHVuZmlsdGVyZWRSZWFkTWVzc2FnZXMgaXMgbm9uLWVtcHR5ICovXG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMudW5maWx0ZXJlZFJlYWRNZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJSZWNlaXZlZE1lc3NhZ2UobmV4dE1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbHRlclJlY2VpdmVkTWVzc2FnZShmcmFtZWRNZXNzYWdlKSB7XG4gICAgICAgIC8qIElmIHdlIHRoZSBjYWxsIGhhcyBhbHJlYWR5IGVuZGVkIHdpdGggYW4gZXJyb3IsIHdlIGRvbid0IHdhbnQgdG8gZG9cbiAgICAgICAgICogYW55dGhpbmcgd2l0aCB0aGlzIG1lc3NhZ2UuIERyb3BwaW5nIGl0IG9uIHRoZSBmbG9vciBpcyBjb3JyZWN0XG4gICAgICAgICAqIGJlaGF2aW9yICovXG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICYmIHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnZmlsdGVyUmVjZWl2ZWRNZXNzYWdlIG9mIGxlbmd0aCAnICsgZnJhbWVkTWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrXG4gICAgICAgICAgICAucmVjZWl2ZU1lc3NhZ2UoUHJvbWlzZS5yZXNvbHZlKGZyYW1lZE1lc3NhZ2UpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5oYW5kbGVGaWx0ZXJlZFJlYWQuYmluZCh0aGlzKSwgdGhpcy5oYW5kbGVGaWx0ZXJFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgdHJ5UHVzaChtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgndW5maWx0ZXJlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgK1xuICAgICAgICAgICAgICAgIChtZXNzYWdlQnl0ZXMgJiYgbWVzc2FnZUJ5dGVzLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy51bmZpbHRlcmVkUmVhZE1lc3NhZ2VzLnB1c2gobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyUmVjZWl2ZWRNZXNzYWdlKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVHJhaWxlcnMoaGVhZGVycykge1xuICAgICAgICB0aGlzLnN0cmVhbUVuZFdhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB3YXRjaGVyKHRydWUpKTtcbiAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIHRyYWlsZXJzOlxcbicgKyBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YU1hcCA9IG1ldGFkYXRhLmdldE1hcCgpO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMubWFwcGVkU3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKGNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOICYmXG4gICAgICAgICAgICB0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtc3RhdHVzJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXZlZFN0YXR1cyA9IE51bWJlcihtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSk7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMgaW4gY29uc3RhbnRzXzEuU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHJlY2VpdmVkU3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmVkIHN0YXR1cyBjb2RlICcgKyByZWNlaXZlZFN0YXR1cyArICcgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1zdGF0dXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGV0YWlscyA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscyA9IGRlY29kZVVSSShtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLW1lc3NhZ2UnKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmVkIHN0YXR1cyBkZXRhaWxzIHN0cmluZyBcIicgKyBkZXRhaWxzICsgJ1wiIGZyb20gc2VydmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0geyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YSB9O1xuICAgICAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIGNhbGwgd2FzIGFscmVhZHkgZW5kZWQgd2hlbiBoYW5kbGluZyBoZWFkZXJzLlxuICAgICAgICB0aGlzLmVuZENhbGwoc3RhdHVzKTtcbiAgICB9XG4gICAgd3JpdGVNZXNzYWdlVG9TdHJlYW0obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGxTdGF0c1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRNZXNzYWdlU2VudCgpO1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLndyaXRlKG1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYXR0YWNoSHR0cDJTdHJlYW0oc3RyZWFtLCBzdWJjaGFubmVsLCBleHRyYUZpbHRlcnMsIGNhbGxTdGF0c1RyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5wdXNoKGV4dHJhRmlsdGVycyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdHJlYW0uY2xvc2UoTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnYXR0YWNoSHR0cDJTdHJlYW0gZnJvbSBzdWJjaGFubmVsICcgKyBzdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsID0gc3ViY2hhbm5lbDtcbiAgICAgICAgICAgIHRoaXMuY2FsbFN0YXRzVHJhY2tlciA9IGNhbGxTdGF0c1RyYWNrZXI7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZERpc2Nvbm5lY3RMaXN0ZW5lcih0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcik7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmNhbGxSZWYoKTtcbiAgICAgICAgICAgIHN0cmVhbS5vbigncmVzcG9uc2UnLCAoaGVhZGVycywgZmxhZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzU3RyaW5nICs9ICdcXHRcXHQnICsgaGVhZGVyICsgJzogJyArIGhlYWRlcnNbaGVhZGVyXSArICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgaGVhZGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZWFkZXJzWyc6c3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBoYW5kbGUgMTAwIGFuZCAxMDFcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0Mjk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTAyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9GTEFHX0VORF9TVFJFQU0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsTWV0YWRhdGEgPSB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlTWV0YWRhdGEoZmluYWxNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCd0cmFpbGVycycsIChoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgc3RhdHVzIGhhcyBhbHJlYWR5IGJlZW4gb3V0cHV0LCBhbGxvdyB0aGUgaHR0cDIgc3RyZWFtIHRvXG4gICAgICAgICAgICAgICAgICogZHJhaW4gd2l0aG91dCBwcm9jZXNzaW5nIHRoZSBkYXRhLiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmUgSFRUUC8yIGRhdGEgZnJhbWUgb2YgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3BhcnNlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBVc2UgcHJvY2Vzcy5uZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgdGhpcyBjb2RlIGhhcHBlbnMgYWZ0ZXIgYW55XG4gICAgICAgICAgICAgICAgICogXCJlcnJvclwiIGV2ZW50IHRoYXQgbWF5IGJlIGVtaXR0ZWQgYXQgYWJvdXQgdGhlIHNhbWUgdGltZSwgc28gdGhhdFxuICAgICAgICAgICAgICAgICAqIHdlIGNhbiBidWJibGUgdXAgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGF0IGV2ZW50LiAqL1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0hUVFAvMiBzdHJlYW0gY2xvc2VkIHdpdGggY29kZSAnICsgc3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIGEgZmluYWwgc3RhdHVzIHdpdGggYW4gT0sgc3RhdHVzIGNvZGUsIHRoYXQgbWVhbnMgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSBoYXZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgbWVzc2FnZXMgYW5kIHdlIGhhdmUgcHJvY2Vzc2VkIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiB0cmFpbGVycyBhbmQgdGhlIGNhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICogaG93IHRoZSBzdHJlYW0gZW5kcyBhZnRlciB0aGF0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdHJlYW0ucnN0Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSBnZXQgYSBOT19FUlJPUiBjb2RlIGFuZCB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0dXMsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHN0cmVhbSBjb21wbGV0ZWQgcHJvcGVybHkgYW5kIHdlIGp1c3QgaGF2ZW4ndCBmdWxseSBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB5ZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke3N0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX1JFRlVTRURfU1RSRUFNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdTdHJlYW0gcmVmdXNlZCBieSBzZXJ2ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdDYWxsIGNhbmNlbGxlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQmFuZHdpZHRoIGV4aGF1c3RlZCBvciBtZW1vcnkgbGltaXQgZXhjZWVkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTkFERVFVQVRFX1NFQ1VSSVRZOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdQcm90b2NvbCBub3Qgc2VjdXJlIGVub3VnaCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGVycm9yIGNvZGUgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbiB0aGUgZGVmYXVsdCBjYXNlLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mIGl0IG9ubGluZSwgc28gSSB3YW50ZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcHJlc2VydmUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2Ugc28gdGhhdCBwZW9wbGUgZmluZCBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBpbiBzZWFyY2hlcywgYnV0IGFsc28gaW5jbHVkZSB0aGUgbW9yZSByZWNvZ25pemFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiBtZXNzYWdlLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7c3RyZWFtLnJzdENvZGV9IChJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8IHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSB0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBcIlJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlIC4uLlwiIGVycm9yIGlzIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaGVyZSBmb3IgY29udGludWl0eSB3aXRoIGVycm9ycyByZXBvcnRlZCBvbmxpbmUsIGJ1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGVycm9yIG1lc3NhZ2UgYXQgdGhlIGVuZCB3aWxsIHByb2JhYmx5IGJlIG1vcmUgcmVsZXZhbnQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1vc3QgY2FzZXMuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7c3RyZWFtLnJzdENvZGV9IHRyaWdnZXJlZCBieSBpbnRlcm5hbCBjbGllbnQgZXJyb3I6ICR7dGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7c3RyZWFtLnJzdENvZGV9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgdHJhaWxlcnMgd2VyZSByZWNlaXZlZCBhdCBhbGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgT0ssIGJlY2F1c2Ugc3RhdHVzIGNvZGVzIGVtaXR0ZWQgaGVyZSBjb3JyZXNwb25kIHRvIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoeyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgaGVyZSB0byBzdG9wIFwiVW5jYXVnaHQgRXJyb3JcIiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICogZnJvbSBidWJibGluZyB1cC4gSG93ZXZlciwgZXJyb3JzIGhlcmUgc2hvdWxkIGFsbCBjb3JyZXNwb25kIHRvXG4gICAgICAgICAgICAgICAgICogXCJjbG9zZVwiIGV2ZW50cywgd2hlcmUgd2Ugd2lsbCBoYW5kbGUgdGhlIGVycm9yIG1vcmUgZ3JhbnVsYXJseSAqL1xuICAgICAgICAgICAgICAgIC8qIFNwZWNpZmljYWxseSBsb29raW5nIGZvciBzdHJlYW0gZXJyb3JzIHRoYXQgd2VyZSAqbm90KiBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgICAqIGZyb20gYSBSU1RfU1RSRUFNIHJlc3BvbnNlIGhlcmU6XG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvOGI4NjIwZDU4MDMxNDA1MDE3NTk4MzQwMmRmZGRmMjY3NGU4ZTIyYS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMjI2N1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9IVFRQMl9TVFJFQU1fRVJST1InKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05vZGUgZXJyb3IgZXZlbnQ6IG1lc3NhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGNvZGU9JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGVycm5vPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3lzdGVtRXJyb3JOYW1lKGVyci5lcnJubykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBzeXNjYWxsPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN5c2NhbGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRW5kV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIoZmFsc2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1dyaXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdXcml0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZSBpbiB3cml0ZSBoYW5kbGluZyBjb2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3NlbmRpbmcgZGF0YSBjaHVuayBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1dyaXRlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICcgKGRlZmVycmVkKScpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVNZXNzYWdlVG9TdHJlYW0odGhpcy5wZW5kaW5nV3JpdGUsIHRoaXMucGVuZGluZ1dyaXRlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBXcml0ZSBmYWlsZWQgd2l0aCBlcnJvciAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF5YmVDbG9zZVdyaXRlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnRyYWNlKCdTZW5kaW5nIG1ldGFkYXRhJyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5jaGFubmVsLl9zdGFydENhbGxTdHJlYW0odGhpcywgbWV0YWRhdGEpO1xuICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgfVxuICAgIGRlc3Ryb3lIdHRwMlN0cmVhbSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBUaGUgaHR0cDIgc3RyZWFtIGNvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGRlc3Ryb3llZCBpZiBjYW5jZWxXaXRoU3RhdHVzXG4gICAgICAgIC8vIGlzIGNhbGxlZCBpbiByZXNwb25zZSB0byBhbiBpbnRlcm5hbCBodHRwMiBlcnJvci5cbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTdHJlYW0gIT09IG51bGwgJiYgIXRoaXMuaHR0cDJTdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvKiBJZiB0aGUgY2FsbCBoYXMgZW5kZWQgd2l0aCBhbiBPSyBzdGF0dXMsIGNvbW11bmljYXRlIHRoYXQgd2hlbiBjbG9zaW5nXG4gICAgICAgICAgICAgKiB0aGUgc3RyZWFtLCBwYXJ0bHkgdG8gYXZvaWQgYSBzaXR1YXRpb24gaW4gd2hpY2ggd2UgZGV0ZWN0IGFuIGVycm9yXG4gICAgICAgICAgICAgKiBSU1RfU1RSRUFNIGFzIGEgcmVzdWx0IGFmdGVyIHdlIGhhdmUgdGhlIHN0YXR1cyAqL1xuICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX05PX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nsb3NlIGh0dHAyIHN0cmVhbSB3aXRoIGNvZGUgJyArIGNvZGUpO1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5jbG9zZShjb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgdGhpcy5lbmRDYWxsKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIGNvbnN0IGRlYWRsaW5lTGlzdCA9IFt0aGlzLm9wdGlvbnMuZGVhZGxpbmVdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudENhbGwgJiYgdGhpcy5vcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFQURMSU5FKSB7XG4gICAgICAgICAgICBkZWFkbGluZUxpc3QucHVzaCh0aGlzLm9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWdEZWFkbGluZSkge1xuICAgICAgICAgICAgZGVhZGxpbmVMaXN0LnB1c2godGhpcy5jb25maWdEZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldE1pbkRlYWRsaW5lKGRlYWRsaW5lTGlzdCk7XG4gICAgfVxuICAgIGdldENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVkZW50aWFscztcbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRoaXMuY2hhbm5lbENhbGxDcmVkZW50aWFscy5jb21wb3NlKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5hbFN0YXR1cztcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuc3ViY2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEFkZHJlc3MoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xuICAgIH1cbiAgICBnZXRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZE5hbWU7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaG9zdDtcbiAgICB9XG4gICAgc2V0Q29uZmlnRGVhZGxpbmUoY29uZmlnRGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy5jb25maWdEZWFkbGluZSA9IGNvbmZpZ0RlYWRsaW5lO1xuICAgIH1cbiAgICBhZGRTdGF0dXNXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgIH1cbiAgICBhZGRTdHJlYW1FbmRXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1FbmRXYXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgIH1cbiAgICBhZGRGaWx0ZXJzKGV4dHJhRmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goZXh0cmFGaWx0ZXJzKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICAvKiBJZiB0aGUgc3RyZWFtIGhhcyBlbmRlZCB3aXRoIGFuIGVycm9yLCB3ZSBzaG91bGQgbm90IGVtaXQgYW55IG1vcmVcbiAgICAgICAgICogbWVzc2FnZXMgYW5kIHdlIHNob3VsZCBjb21tdW5pY2F0ZSB0aGF0IHRoZSBzdHJlYW0gaGFzIGVuZGVkICovXG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICYmIHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5odHRwMlN0cmVhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVhZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBPbmx5IHJlc3VtZSByZWFkaW5nIGZyb20gdGhlIGh0dHAyU3RyZWFtIGlmIHdlIGRvbid0IGhhdmUgYW55IHBlbmRpbmdcbiAgICAgICAgICAgICAqIG1lc3NhZ2VzIHRvIGVtaXQgKi9cbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVDbG9zZVdyaXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVzQ2xvc2VkICYmXG4gICAgICAgICAgICAhdGhpcy5pc1dyaXRlRmlsdGVyUGVuZGluZyAmJlxuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbGluZyBlbmQoKSBvbiBIVFRQLzIgc3RyZWFtJyk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHdyaXRlT2JqID0ge1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGZsYWdzOiBjb250ZXh0LmZsYWdzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYiA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGxldCBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBlcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSAnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBgV3JpdGUgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IGNvbnRleHQuY2FsbGJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzV3JpdGVGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWVzc2FnZShQcm9taXNlLnJlc29sdmUod3JpdGVPYmopKS50aGVuKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzV3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5odHRwMlN0cmVhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2RlZmVycmluZyB3cml0aW5nIGRhdGEgY2h1bmsgb2YgbGVuZ3RoICcgKyBtZXNzYWdlLm1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdXcml0ZSA9IG1lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdXcml0ZUNhbGxiYWNrID0gY2I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdzZW5kaW5nIGRhdGEgY2h1bmsgb2YgbGVuZ3RoICcgKyBtZXNzYWdlLm1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZVRvU3RyZWFtKG1lc3NhZ2UubWVzc2FnZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBXcml0ZSBmYWlsZWQgd2l0aCBlcnJvciAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlQ2xvc2VXcml0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5oYW5kbGVGaWx0ZXJFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmQoKSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heWJlQ2xvc2VXcml0ZXMoKTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyQ2FsbFN0cmVhbSA9IEh0dHAyQ2FsbFN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtc3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, { stack });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor() {\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize) {\n        super({ objectMode: true });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDJCQUEyQjtBQUNoSyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLEVBQUUsZ0NBQWdDLElBQUksZUFBZTtBQUN6RjtBQUNBLHFCQUFxQixZQUFZLGlCQUFpQixZQUFZO0FBQzlELHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzPzdiNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSBleHBvcnRzLmNhbGxFcnJvckZyb21TdGF0dXMgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgU2VydmljZUVycm9yIGZyb20gYSBTdGF0dXNPYmplY3QuIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHByaW1hcmlseVxuICogYXMgYW4gYXR0ZW1wdCB0byBtYWtlIHRoZSBlcnJvciBzdGFjayB0cmFjZSBjbGVhcmx5IGNvbW11bmljYXRlIHRoYXQgdGhlXG4gKiBlcnJvciBpcyBub3QgbmVjZXNzYXJpbHkgYSBwcm9ibGVtIGluIGdSUEMgaXRzZWxmLlxuICogQHBhcmFtIHN0YXR1c1xuICovXG5mdW5jdGlvbiBjYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYCR7c3RhdHVzLmNvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1cy5jb2RlXX06ICR7c3RhdHVzLmRldGFpbHN9YDtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBjb25zdCBzdGFjayA9IGAke2Vycm9yLnN0YWNrfVxcbmZvciBjYWxsIGF0XFxuJHtjYWxsZXJTdGFja31gO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihtZXNzYWdlKSwgc3RhdHVzLCB7IHN0YWNrIH0pO1xufVxuZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gY2FsbEVycm9yRnJvbVN0YXR1cztcbmNsYXNzIENsaWVudFVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gQ2xpZW50VW5hcnlDYWxsSW1wbDtcbmNsYXNzIENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwgPSBDbGllbnRXcml0YWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnREdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IENsaWVudER1cGxleFN0cmVhbUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\nfunction bufferOrNullEqual(buf1, buf2) {\n    if (buf1 === null && buf2 === null) {\n        return true;\n    }\n    else {\n        return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n    constructor(callCredentials) {\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */\n    _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\n        verifyIsBufferOrNull(privateKey, 'Private key');\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\n        if (privateKey && !certChain) {\n            throw new Error('Private key must be given with accompanying certificate chain');\n        }\n        if (!privateKey && certChain) {\n            throw new Error('Certificate chain must be given with accompanying private key');\n        }\n        const secureContext = tls_1.createSecureContext({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : tls_helpers_1.getDefaultRootsData()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */\n    static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials) {\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error('Cannot compose insecure credentials');\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions) {\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return (this.secureContext === other.secureContext &&\n                this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity);\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds) {\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return (this.channelCredentials._equals(other.channelCredentials) &&\n                this.callCredentials._equals(other.callCredentials));\n        }\n        else {\n            return false;\n        }\n    }\n}\n//# sourceMappingURL=channel-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLWNyZWRlbnRpYWxzLmpzP2RlNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2FsbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2ZXJpZnlJc0J1ZmZlck9yTnVsbChvYmosIGZyaWVuZGx5TmFtZSkge1xuICAgIGlmIChvYmogJiYgIShvYmogaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZnJpZW5kbHlOYW1lfSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBCdWZmZXIuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVmZmVyT3JOdWxsRXF1YWwoYnVmMSwgYnVmMikge1xuICAgIGlmIChidWYxID09PSBudWxsICYmIGJ1ZjIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVmMSAhPT0gbnVsbCAmJiBidWYyICE9PSBudWxsICYmIGJ1ZjEuZXF1YWxzKGJ1ZjIpO1xuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIGNyZWRlbnRpYWxzIGZvciBjb21tdW5pY2F0aW5nIG92ZXIgYSBjaGFubmVsLCBhcyB3ZWxsXG4gKiBhcyBhIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscywgd2hpY2ggYXJlIGFwcGxpZWQgdG8gZXZlcnkgbWV0aG9kIGNhbGwgbWFkZVxuICogb3ZlciBhIGNoYW5uZWwgaW5pdGlhbGl6ZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5jbGFzcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscyA9IGNhbGxDcmVkZW50aWFscyB8fCBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBfZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFscy5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXNcbiAgICAgKiBvdmVyIFRMUy5cbiAgICAgKiBAcGFyYW0gcm9vdENlcnRzIFRoZSByb290IGNlcnRpZmljYXRlIGRhdGEuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBwcml2YXRlIGtleSwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSBjZXJ0Q2hhaW4gVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBrZXkgY2hhaW4sIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBwcml2YXRlS2V5LCBjZXJ0Q2hhaW4sIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChyb290Q2VydHMsICdSb290IGNlcnRpZmljYXRlJyk7XG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKHByaXZhdGVLZXksICdQcml2YXRlIGtleScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChjZXJ0Q2hhaW4sICdDZXJ0aWZpY2F0ZSBjaGFpbicpO1xuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiAhY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgY2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByaXZhdGVLZXkgJiYgY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIGNoYWluIG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gdGxzXzEuY3JlYXRlU2VjdXJlQ29udGV4dCh7XG4gICAgICAgICAgICBjYTogKF9hID0gcm9vdENlcnRzICE9PSBudWxsICYmIHJvb3RDZXJ0cyAhPT0gdm9pZCAwID8gcm9vdENlcnRzIDogdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5ICE9PSB2b2lkIDAgPyBwcml2YXRlS2V5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydDogY2VydENoYWluICE9PSBudWxsICYmIGNlcnRDaGFpbiAhPT0gdm9pZCAwID8gY2VydENoYWluIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIGNyZWRlbnRpYWxzIGNyZWF0ZWQgdXNpbmdcbiAgICAgKiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dC4gVGhlIHJlc3VsdGluZyBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzIG92ZXIgVExTLiBnUlBDIHdpbGwgbm90IG92ZXJyaWRlXG4gICAgICogYW55dGhpbmcgaW4gdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQsIHNvIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgKiBHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIGFuZCBHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCB3aWxsXG4gICAgICogbm90IGJlIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHNlY3VyZUNvbnRleHQgVGhlIHJldHVybiB2YWx1ZSBvZiB0bHMuY3JlYXRlU2VjdXJlQ29udGV4dCgpXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggbm8gY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUluc2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gQ2hhbm5lbENyZWRlbnRpYWxzO1xuY2xhc3MgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgc3VwZXIoY2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcG9zZSBpbnNlY3VyZSBjcmVkZW50aWFscycpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGw7XG4gICAgfVxufVxuY2xhc3MgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3Ioc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHQgPSBzZWN1cmVDb250ZXh0O1xuICAgICAgICB0aGlzLnZlcmlmeU9wdGlvbnMgPSB2ZXJpZnlPcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgc2VjdXJlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGFzc2VydHMgdGhhdCB0aGlzIG9wdGlvbiBpcyBhIGZ1bmN0aW9uLCBzbyB3ZSBjYW5ub3QgcGFzcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKHZlcmlmeU9wdGlvbnMgPT09IG51bGwgfHwgdmVyaWZ5T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSB2ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xuICAgICAgICAvLyBDb3B5IHRvIHByZXZlbnQgY2FsbGVycyBmcm9tIG11dGF0aW5nIHRoaXMuY29ubmVjdGlvbk9wdGlvbnNcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNlY3VyZUNvbnRleHQgPT09IG90aGVyLnNlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9PT0gb3RoZXIudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENyZWRlbnRpYWxzLCBjYWxsQ3JlZHMpIHtcbiAgICAgICAgc3VwZXIoY2FsbENyZWRzKTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMgPSBjaGFubmVsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCh0aGlzLmNoYW5uZWxDcmVkZW50aWFscywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxDcmVkZW50aWFscy5fZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKTtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYW5uZWxDcmVkZW50aWFscy5fZXF1YWxzKG90aGVyLmNoYW5uZWxDcmVkZW50aWFscykgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscy5fZXF1YWxzKG90aGVyLmNhbGxDcmVkZW50aWFscykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */\nexports.recognizedOptions = {\n    'grpc.ssl_target_name_override': true,\n    'grpc.primary_user_agent': true,\n    'grpc.secondary_user_agent': true,\n    'grpc.default_authority': true,\n    'grpc.keepalive_time_ms': true,\n    'grpc.keepalive_timeout_ms': true,\n    'grpc.keepalive_permit_without_calls': true,\n    'grpc.service_config': true,\n    'grpc.max_concurrent_streams': true,\n    'grpc.initial_reconnect_backoff_ms': true,\n    'grpc.max_reconnect_backoff_ms': true,\n    'grpc.use_local_subchannel_pool': true,\n    'grpc.max_send_message_length': true,\n    'grpc.max_receive_message_length': true,\n    'grpc.enable_http_proxy': true,\n    'grpc.enable_channelz': true,\n    'grpc.dns_min_time_between_resolutions_ms': true,\n    'grpc-node.max_session_memory': true,\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let i = 0; i < keys1.length; i += 1) {\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual;\n//# sourceMappingURL=channel-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzPzlkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgaXMgZm9yIGNoZWNraW5nIHByb3ZpZGVkIG9wdGlvbnMgYXQgcnVudGltZS4gVGhpcyBpcyBhbiBvYmplY3QgZm9yXG4gKiBlYXNpZXIgbWVtYmVyc2hpcCBjaGVja2luZy5cbiAqL1xuZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHtcbiAgICAnZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnOiB0cnVlLFxuICAgICdncnBjLnByaW1hcnlfdXNlcl9hZ2VudCc6IHRydWUsXG4gICAgJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLmRlZmF1bHRfYXV0aG9yaXR5JzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyc6IHRydWUsXG4gICAgJ2dycGMuc2VydmljZV9jb25maWcnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnOiB0cnVlLFxuICAgICdncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXG4gICAgJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCc6IHRydWUsXG4gICAgJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5lbmFibGVfaHR0cF9wcm94eSc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2NoYW5uZWx6JzogdHJ1ZSxcbiAgICAnZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNoYW5uZWxPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvcHRpb25zMSkuc29ydCgpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob3B0aW9uczIpLnNvcnQoKTtcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChrZXlzMVtpXSAhPT0ga2V5czJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uczFba2V5czFbaV1dICE9PSBvcHRpb25zMltrZXlzMltpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGNoYW5uZWxPcHRpb25zRXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelImplementation = void 0;\nconst call_stream_1 = __webpack_require__(/*! ./call-stream */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\");\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst call_credentials_filter_1 = __webpack_require__(/*! ./call-credentials-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js\");\nconst deadline_filter_1 = __webpack_require__(/*! ./deadline-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst max_message_size_filter_1 = __webpack_require__(/*! ./max-message-size-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    }\n    else {\n        return { code, details };\n    }\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        var _a, _b, _c, _d;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */\n        this.currentResolutionError = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = uri_parser_1.parseUri(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n        }\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n        }\n        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n                }\n                return subchannel;\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {\n                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n            addChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector) => {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata } of localQueue) {\n                    this.tryGetConfig(callStream, callMetadata);\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status) => {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace('Name resolution failed with calls queued for config selection');\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, restrictControlPlaneStatusCode(status.code, status.details)), { metadata: status.metadata });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const { callStream, callMetadata } of localQueue) {\n                if (callMetadata.getOptions().waitForReady) {\n                    this.callRefTimerRef();\n                    this.configSelectionQueue.push({ callStream, callMetadata });\n                }\n                else {\n                    callStream.cancelWithStatus(status.code, status.details);\n                }\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\n        ]);\n        this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf('\\n') + 1)));\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        };\n    }\n    trace(text, verbosityOverride) {\n        logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });\n        this.callRefTimerRef();\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */\n    tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        var _a, _b;\n        const pickResult = this.currentPicker.pick({\n            metadata: callMetadata,\n            extraPickInfo: callConfig.pickInformation,\n        });\n        const subchannelString = pickResult.subchannel ?\n            '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() :\n            '' + pickResult.subchannel;\n        this.trace('Pick result for call [' +\n            callStream.getCallNumber() +\n            ']: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' +\n            subchannelString +\n            ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\n            ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy');\n                    // End the call with an error\n                }\n                else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        connectivity_state_1.ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' +\n                            subchannelString +\n                            ' has state ' +\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */\n                    callStream.filterStack\n                        .sendMetadata(Promise.resolve(callMetadata.clone()))\n                        .then((finalMetadata) => {\n                        var _a, _b, _c;\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n                            try {\n                                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                                /* If we reach this point, the call stream has started\n                                 * successfully */\n                                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                            }\n                            catch (error) {\n                                const errorCode = error.code;\n                                if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' ||\n                                    errorCode === 'ERR_HTTP2_INVALID_SESSION') {\n                                    /* An error here indicates that something went wrong with\n                                     * the picked subchannel's http2 stream right before we\n                                     * tried to start the stream. We are handling a promise\n                                     * result here, so this is asynchronous with respect to the\n                                     * original tryPick call, so calling it again is not\n                                     * recursive. We call tryPick immediately instead of\n                                     * queueing this pick again because handling the queue is\n                                     * triggered by state changes, and we want to immediately\n                                     * check if the state has already changed since the\n                                     * previous tryPick call. We do this instead of cancelling\n                                     * the stream because the correct behavior may be\n                                     * re-queueing instead, based on the logic in the rest of\n                                     * tryPick */\n                                    this.trace('Failed to start call on picked subchannel ' +\n                                        subchannelString +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Retrying pick', constants_1.LogVerbosity.INFO);\n                                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                                }\n                                else {\n                                    this.trace('Failed to start call on picked subchanel ' +\n                                        subchannelString +\n                                        ' with error ' +\n                                        error.message +\n                                        '. Ending call', constants_1.LogVerbosity.INFO);\n                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                                }\n                            }\n                        }\n                        else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */\n                            this.trace('Picked subchannel ' +\n                                subchannelString +\n                                ' has state ' +\n                                connectivity_state_1.ConnectivityState[subchannelState] +\n                                ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n                            this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        }\n                    }, (error) => {\n                        // We assume the error code isn't 0 (Status.OK)\n                        const { code, details } = restrictControlPlaneStatusCode(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                        callStream.cancelWithStatus(code, details);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n                else {\n                    const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                    callStream.cancelWithStatus(code, details);\n                }\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                callStream.cancelWithStatus(code, details);\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' +\n            uri_parser_1.uriToString(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    tryGetConfig(stream, metadata) {\n        if (stream.getStatus() !== null) {\n            /* If the stream has a status, it has already finished and we don't need\n             * to take any more actions on it. */\n            return;\n        }\n        if (this.configSelector === null) {\n            /* This branch will only be taken at the beginning of the channel's life,\n             * before the resolver ever returns a result. So, the\n             * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n             * because it now has a pending request. */\n            this.resolvingLoadBalancer.exitIdle();\n            if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n                stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n            }\n            else {\n                this.configSelectionQueue.push({\n                    callStream: stream,\n                    callMetadata: metadata,\n                });\n                this.callRefTimerRef();\n            }\n        }\n        else {\n            const callConfig = this.configSelector(stream.getMethod(), metadata);\n            if (callConfig.status === constants_1.Status.OK) {\n                if (callConfig.methodConfig.timeout) {\n                    const deadline = new Date();\n                    deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n                    deadline.setMilliseconds(deadline.getMilliseconds() +\n                        callConfig.methodConfig.timeout.nanos / 1000000);\n                    stream.setConfigDeadline(deadline);\n                    // Refreshing the filters makes the deadline filter pick up the new deadline\n                    stream.filterStack.refresh();\n                }\n                if (callConfig.dynamicFilterFactories.length > 0) {\n                    /* These dynamicFilters are the mechanism for implementing gRFC A39:\n                     * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n                     * We run them here instead of with the rest of the filters because\n                     * that spec says \"the xDS HTTP filters will run in between name\n                     * resolution and load balancing\".\n                     *\n                     * We use the filter stack here to simplify the multi-filter async\n                     * waterfall logic, but we pass along the underlying list of filters\n                     * to avoid having nested filter stacks when combining it with the\n                     * original filter stack. We do not pass along the original filter\n                     * factory list because these filters may need to persist data\n                     * between sending headers and other operations. */\n                    const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n                    const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n                    dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n                        this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n                    });\n                }\n                else {\n                    this.tryPick(stream, metadata, callConfig, []);\n                }\n            }\n            else {\n                const { code, details } = restrictControlPlaneStatusCode(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n                stream.cancelWithStatus(code, details);\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryGetConfig(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return uri_parser_1.uriToString(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer,\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        const callNumber = getNewCallNumber();\n        this.trace('createCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            deadline);\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            stream.addStatusWatcher(status => {\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                }\n                else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n        }\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QixzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDL0Msa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsTUFBTSxFQUFFLDBCQUEwQixFQUFFLFFBQVE7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxrRUFBa0UsMkJBQTJCO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLGNBQWM7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxnQ0FBZ0MsZ0JBQWdCLDhKQUE4SixjQUFjO0FBQzVOO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDBCQUEwQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzP2JhNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gdm9pZCAwO1xuY29uc3QgY2FsbF9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NhbGwtc3RyZWFtXCIpO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfcG9vbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1wb29sXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc19maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHMtZmlsdGVyXCIpO1xuY29uc3QgZGVhZGxpbmVfZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZS1maWx0ZXJcIik7XG5jb25zdCBjb21wcmVzc2lvbl9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWZpbHRlclwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXJcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lcnNfc2V0aW50ZXJ2YWxfY2FsbGJhY2tfZGVsYXlfYXJnc1xuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0NztcbmxldCBuZXh0Q2FsbE51bWJlciA9IDA7XG5mdW5jdGlvbiBnZXROZXdDYWxsTnVtYmVyKCkge1xuICAgIGNvbnN0IGNhbGxOdW1iZXIgPSBuZXh0Q2FsbE51bWJlcjtcbiAgICBuZXh0Q2FsbE51bWJlciArPSAxO1xuICAgIGlmIChuZXh0Q2FsbE51bWJlciA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICBuZXh0Q2FsbE51bWJlciA9IDA7XG4gICAgfVxuICAgIHJldHVybiBjYWxsTnVtYmVyO1xufVxuY29uc3QgSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTID0gW1xuICAgIGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuSU5WQUxJRF9BUkdVTUVOVCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5BTFJFQURZX0VYSVNUUyxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuRkFJTEVEX1BSRUNPTkRJVElPTixcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUJPUlRFRCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT1VUX09GX1JBTkdFLFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5EQVRBX0xPU1Ncbl07XG5mdW5jdGlvbiByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUoY29kZSwgZGV0YWlscykge1xuICAgIGlmIChJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIGRldGFpbHM6IGBJbnZhbGlkIHN0YXR1cyBmcm9tIGNvbnRyb2wgcGxhbmU6ICR7Y29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbY29kZV19ICR7ZGV0YWlsc31gXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlLCBkZXRhaWxzIH07XG4gICAgfVxufVxuY2xhc3MgQ2hhbm5lbEltcGxlbWVudGF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxscyBxdWV1ZWQgdXAgdG8gZ2V0IGEgY2FsbCBjb25maWcuIFNob3VsZCBvbmx5IGJlIHBvcHVsYXRlZCBiZWZvcmUgdGhlXG4gICAgICAgICAqIGZpcnN0IHRpbWUgdGhlIHJlc29sdmVyIHJldHVybnMgYSByZXN1bHQsIHdoaWNoIGluY2x1ZGVzIHRoZSBDb25maWdTZWxlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5waWNrUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZXJyb3IgZnJvbSB0aGUgbmFtZSByZXNvbHZlciBpZiBpdCBmYWlsZWQgbW9zdCByZWNlbnRseS4gSXRcbiAgICAgICAgICogaXMgb25seSB1c2VkIHRvIGVuZCBjYWxscyB0aGF0IHN0YXJ0IHdoaWxlIHRoZXJlIGlzIG5vIGNvbmZpZyBzZWxlY3RvclxuICAgICAgICAgKiBhbmQgdGhlIG5hbWUgcmVzb2x2ZXIgaXMgaW4gYmFja29mZiwgc28gaXQgc2hvdWxkIGJlIG51bGxlZCBpZlxuICAgICAgICAgKiBjb25maWdTZWxlY3RvciBiZWNvbWVzIHNldCBvciB0aGUgY2hhbm5lbCBzdGF0ZSBiZWNvbWVzIGFueXRoaW5nIG90aGVyXG4gICAgICAgICAqIHRoYW4gVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICAvLyBDaGFubmVseiBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRhcmdldFVyaSA9IHVyaV9wYXJzZXJfMS5wYXJzZVVyaSh0YXJnZXQpO1xuICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHNjaGVtZSB0aGF0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9IHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZShvcmlnaW5hbFRhcmdldFVyaSk7XG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lTWFwUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmYXVsdCBzY2hlbWUgZm9yIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgTUFYX1RJTUVPVVRfVElNRSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwodGFyZ2V0LCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0NoYW5uZWwgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknXSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gdGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBdXRob3JpdHkgPSByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlNYXBSZXN1bHQgPSBodHRwX3Byb3h5XzEubWFwUHJveHlOYW1lKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHByb3h5TWFwUmVzdWx0LnRhcmdldDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwcm94eU1hcFJlc3VsdC5leHRyYU9wdGlvbnMpO1xuICAgICAgICAvKiBUaGUgZ2xvYmFsIGJvb2xlYW4gcGFyYW1ldGVyIHRvIGdldFN1YmNoYW5uZWxQb29sIGhhcyB0aGUgaW52ZXJzZSBtZWFuaW5nIHRvIHdoYXRcbiAgICAgICAgICogdGhlIGdycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCBjaGFubmVsIG9wdGlvbiBtZWFucy4gKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsUG9vbCA9IHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKCgoX2MgPSBvcHRpb25zWydncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgPT09IDApO1xuICAgICAgICBjb25zdCBjaGFubmVsQ29udHJvbEhlbHBlciA9IHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsUG9vbC5nZXRPckNyZWF0ZVN1YmNoYW5uZWwodGhpcy50YXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHN1YmNoYW5uZWxBcmdzKSwgdGhpcy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gcGlja2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXVlQ29weSA9IHRoaXMucGlja1F1ZXVlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMgfSBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIgc2hvdWxkIG5ldmVyIGNhbGwgcmVxdWVzdFJlcmVzb2x1dGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gbmV3IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEuUmVzb2x2aW5nTG9hZEJhbGFuY2VyKHRoaXMudGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgb3B0aW9ucywgKGNvbmZpZ1NlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQWRkcmVzcyByZXNvbHV0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8qIFdlIHByb2Nlc3MgdGhlIHF1ZXVlIGFzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhIH0gb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUdldENvbmZpZyhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9XQVJOSU5HJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjb2RlICcgKyBzdGF0dXMuY29kZSArICcgYW5kIGRldGFpbHMgXCInICsgc3RhdHVzLmRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdOYW1lIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY2FsbHMgcXVldWVkIGZvciBjb25maWcgc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscykpLCB7IG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEgfSBvZiBsb2NhbFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxNZXRhZGF0YS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUucHVzaCh7IGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXG4gICAgICAgICAgICBuZXcgY2FsbF9jcmVkZW50aWFsc19maWx0ZXJfMS5DYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5KHRoaXMpLFxuICAgICAgICAgICAgbmV3IGRlYWRsaW5lX2ZpbHRlcl8xLkRlYWRsaW5lRmlsdGVyRmFjdG9yeSh0aGlzKSxcbiAgICAgICAgICAgIG5ldyBtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xLk1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSh0aGlzLm9wdGlvbnMpLFxuICAgICAgICAgICAgbmV3IGNvbXByZXNzaW9uX2ZpbHRlcl8xLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSh0aGlzLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy50cmFjZSgnQ2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBsb2dnaW5nXzEudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY2hhbm5lbF9zdGFja3RyYWNlJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyAnQ2hhbm5lbCBjb25zdHJ1Y3RlZCBcXG4nICsgKChfZCA9IGVycm9yLnN0YWNrKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3Vic3RyaW5nKGVycm9yLnN0YWNrLmluZGV4T2YoJ1xcbicpICsgMSkpKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLm9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQsIHZlcmJvc2l0eU92ZXJyaWRlKSB7XG4gICAgICAgIGxvZ2dpbmdfMS50cmFjZSh2ZXJib3NpdHlPdmVycmlkZSAhPT0gbnVsbCAmJiB2ZXJib3NpdHlPdmVycmlkZSAhPT0gdm9pZCAwID8gdmVyYm9zaXR5T3ZlcnJpZGUgOiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghKChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS5oYXNSZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxSZWZUaW1lci5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYWxsUmVmVGltZXIpLnJlZikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclVucmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghdGhpcy5jYWxsUmVmVGltZXIuaGFzUmVmIHx8IHRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZigpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIudW5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaFBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycykge1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZS5wdXNoKHsgY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyB9KTtcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHBpY2tlciBvdXRwdXQgZm9yIHRoZSBnaXZlbiBjYWxsIGFuZCBjb3JyZXNwb25kaW5nIG1ldGFkYXRhLFxuICAgICAqIGFuZCB0YWtlIGFueSByZWxldmFudCBhY3Rpb25zLiBTaG91bGQgbm90IGJlIGNhbGxlZCB3aGlsZSBpdGVyYXRpbmdcbiAgICAgKiBvdmVyIHBpY2tRdWV1ZS5cbiAgICAgKiBAcGFyYW0gY2FsbFN0cmVhbVxuICAgICAqIEBwYXJhbSBjYWxsTWV0YWRhdGFcbiAgICAgKi9cbiAgICB0cnlQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGlja1Jlc3VsdCA9IHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjYWxsTWV0YWRhdGEsXG4gICAgICAgICAgICBleHRyYVBpY2tJbmZvOiBjYWxsQ29uZmlnLnBpY2tJbmZvcm1hdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdHJpbmcgPSBwaWNrUmVzdWx0LnN1YmNoYW5uZWwgP1xuICAgICAgICAgICAgJygnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkuaWQgKyAnKSAnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldEFkZHJlc3MoKSA6XG4gICAgICAgICAgICAnJyArIHBpY2tSZXN1bHQuc3ViY2hhbm5lbDtcbiAgICAgICAgdGhpcy50cmFjZSgnUGljayByZXN1bHQgZm9yIGNhbGwgWycgK1xuICAgICAgICAgICAgY2FsbFN0cmVhbS5nZXRDYWxsTnVtYmVyKCkgK1xuICAgICAgICAgICAgJ106ICcgK1xuICAgICAgICAgICAgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGVbcGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZV0gK1xuICAgICAgICAgICAgJyBzdWJjaGFubmVsOiAnICtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgJyBzdGF0dXM6ICcgKyAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXG4gICAgICAgICAgICAnICcgKyAoKF9iID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXRhaWxzKSk7XG4gICAgICAgIHN3aXRjaCAocGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURTpcbiAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5zdWJjaGFubmVsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsICdSZXF1ZXN0IGRyb3BwZWQgYnkgbG9hZCBiYWxhbmNpbmcgcG9saWN5Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZCB0aGUgY2FsbCB3aXRoIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGUgc3ViY2hhbm5lbCBpcyBub3QgaW4gdGhlIFJFQURZIHN0YXRlLCB0aGF0IGluZGljYXRlcyBhIGJ1Z1xuICAgICAgICAgICAgICAgICAgICAgKiBzb21ld2hlcmUgaW4gdGhlIGxvYWQgYmFsYW5jZXIgb3IgcGlja2VyLiBTbywgd2UgbG9nIGFuIGVycm9yIGFuZFxuICAgICAgICAgICAgICAgICAgICAgKiBxdWV1ZSB0aGUgcGljayB0byBiZSB0cmllZCBhZ2FpbiBsYXRlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRXJyb3I6IENPTVBMRVRFIHBpY2sgcmVzdWx0IHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBoYXMgc3RhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBXZSBuZWVkIHRvIGNsb25lIHRoZSBjYWxsTWV0YWRhdGEgaGVyZSBiZWNhdXNlIHRoZSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgICAgICAgKiByZXRyeSBjb2RlIGluIHRoZSBwcm9taXNlIHJlc29sdXRpb24gaGFuZGxlciB1c2UgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgICogY2FsbE1ldGFkYXRhIG9iamVjdCwgc28gaXQgbmVlZHMgdG8gc3RheSB1bm1vZGlmaWVkICovXG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uZmlsdGVyU3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKGNhbGxNZXRhZGF0YS5jbG9uZSgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChmaW5hbE1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWNrRXh0cmFGaWx0ZXJzID0gcGlja1Jlc3VsdC5leHRyYUZpbHRlckZhY3Rvcmllcy5tYXAoZmFjdG9yeSA9PiBmYWN0b3J5LmNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWxTdWJjaGFubmVsKCkuc3RhcnRDYWxsU3RyZWFtKGZpbmFsTWV0YWRhdGEsIGNhbGxTdHJlYW0sIFsuLi5keW5hbWljRmlsdGVycywgLi4ucGlja0V4dHJhRmlsdGVyc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSByZWFjaCB0aGlzIHBvaW50LCB0aGUgY2FsbCBzdHJlYW0gaGFzIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bGx5ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGNhbGxDb25maWcub25Db21taXR0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGNhbGxDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSBwaWNrUmVzdWx0Lm9uQ2FsbFN0YXJ0ZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHBpY2tSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ0VSUl9IVFRQMl9HT0FXQVlfU0VTU0lPTicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ0VSUl9IVFRQMl9JTlZBTElEX1NFU1NJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBBbiBlcnJvciBoZXJlIGluZGljYXRlcyB0aGF0IHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBwaWNrZWQgc3ViY2hhbm5lbCdzIGh0dHAyIHN0cmVhbSByaWdodCBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyaWVkIHRvIHN0YXJ0IHRoZSBzdHJlYW0uIFdlIGFyZSBoYW5kbGluZyBhIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHJlc3VsdCBoZXJlLCBzbyB0aGlzIGlzIGFzeW5jaHJvbm91cyB3aXRoIHJlc3BlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvcmlnaW5hbCB0cnlQaWNrIGNhbGwsIHNvIGNhbGxpbmcgaXQgYWdhaW4gaXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiByZWN1cnNpdmUuIFdlIGNhbGwgdHJ5UGljayBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBxdWV1ZWluZyB0aGlzIHBpY2sgYWdhaW4gYmVjYXVzZSBoYW5kbGluZyB0aGUgcXVldWUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyaWdnZXJlZCBieSBzdGF0ZSBjaGFuZ2VzLCBhbmQgd2Ugd2FudCB0byBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY2hlY2sgaWYgdGhlIHN0YXRlIGhhcyBhbHJlYWR5IGNoYW5nZWQgc2luY2UgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmV2aW91cyB0cnlQaWNrIGNhbGwuIFdlIGRvIHRoaXMgaW5zdGVhZCBvZiBjYW5jZWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc3RyZWFtIGJlY2F1c2UgdGhlIGNvcnJlY3QgYmVoYXZpb3IgbWF5IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiByZS1xdWV1ZWluZyBpbnN0ZWFkLCBiYXNlZCBvbiB0aGUgbG9naWMgaW4gdGhlIHJlc3Qgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyeVBpY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBzdGFydCBjYWxsIG9uIHBpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLiBSZXRyeWluZyBwaWNrJywgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIHN0YXJ0IGNhbGwgb24gcGlja2VkIHN1YmNoYW5lbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4gRW5kaW5nIGNhbGwnLCBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsU3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgRmFpbGVkIHRvIHN0YXJ0IEhUVFAvMiBzdHJlYW0gd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIGxvZ2ljIGZvciBkb2luZyB0aGlzIGhlcmUgaXMgdGhlIHNhbWUgYXMgaW4gdGhlIGNhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYmxvY2sgYWJvdmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQaWNrZWQgc3ViY2hhbm5lbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaGFzIHN0YXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtzdWJjaGFubmVsU3RhdGVdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhZnRlciBtZXRhZGF0YSBmaWx0ZXJzLiBSZXRyeWluZyBwaWNrJywgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIGVycm9yIGNvZGUgaXNuJ3QgMCAoU3RhdHVzLk9LKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlFVRVVFOlxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmIChjYWxsTWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkRST1A6XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGRldGFpbHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGU6IHVua25vd24gcGlja1Jlc3VsdFR5cGUgJHtwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5maW5kSW5kZXgoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gd2F0Y2hlck9iamVjdCk7XG4gICAgICAgIGlmICh3YXRjaGVySW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnNwbGljZSh3YXRjaGVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGxvZ2dpbmdfMS50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjb25uZWN0aXZpdHlfc3RhdGUnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArXG4gICAgICAgICAgICB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArICcgLT4gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjb25zdCB3YXRjaGVyc0NvcHkgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyT2JqZWN0IG9mIHdhdGNoZXJzQ29weSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyT2JqZWN0LnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3YXRjaGVyT2JqZWN0LnRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlck9iamVjdC5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5R2V0Q29uZmlnKHN0cmVhbSwgbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5nZXRTdGF0dXMoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyogSWYgdGhlIHN0cmVhbSBoYXMgYSBzdGF0dXMsIGl0IGhhcyBhbHJlYWR5IGZpbmlzaGVkIGFuZCB3ZSBkb24ndCBuZWVkXG4gICAgICAgICAgICAgKiB0byB0YWtlIGFueSBtb3JlIGFjdGlvbnMgb24gaXQuICovXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIFRoaXMgYnJhbmNoIHdpbGwgb25seSBiZSB0YWtlbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjaGFubmVsJ3MgbGlmZSxcbiAgICAgICAgICAgICAqIGJlZm9yZSB0aGUgcmVzb2x2ZXIgZXZlciByZXR1cm5zIGEgcmVzdWx0LiBTbywgdGhlXG4gICAgICAgICAgICAgKiBSZXNvbHZpbmdMb2FkQmFsYW5jZXIgbWF5IGJlIGlkbGUgYW5kIGlmIHNvIGl0IG5lZWRzIHRvIGJlIGtpY2tlZFxuICAgICAgICAgICAgICogYmVjYXVzZSBpdCBub3cgaGFzIGEgcGVuZGluZyByZXF1ZXN0LiAqL1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgJiYgIW1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IuY29kZSwgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yLmRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBjYWxsTWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsQ29uZmlnID0gdGhpcy5jb25maWdTZWxlY3RvcihzdHJlYW0uZ2V0TWV0aG9kKCksIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChjYWxsQ29uZmlnLnN0YXR1cyA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVhZGxpbmUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWFkbGluZS5zZXRTZWNvbmRzKGRlYWRsaW5lLmdldFNlY29uZHMoKSArIGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQuc2Vjb25kcyk7XG4gICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhkZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0Lm5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRDb25maWdEZWFkbGluZShkZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZnJlc2hpbmcgdGhlIGZpbHRlcnMgbWFrZXMgdGhlIGRlYWRsaW5lIGZpbHRlciBwaWNrIHVwIHRoZSBuZXcgZGVhZGxpbmVcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmZpbHRlclN0YWNrLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxDb25maWcuZHluYW1pY0ZpbHRlckZhY3Rvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoZXNlIGR5bmFtaWNGaWx0ZXJzIGFyZSB0aGUgbWVjaGFuaXNtIGZvciBpbXBsZW1lbnRpbmcgZ1JGQyBBMzk6XG4gICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EzOS14ZHMtaHR0cC1maWx0ZXJzLm1kXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHJ1biB0aGVtIGhlcmUgaW5zdGVhZCBvZiB3aXRoIHRoZSByZXN0IG9mIHRoZSBmaWx0ZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogdGhhdCBzcGVjIHNheXMgXCJ0aGUgeERTIEhUVFAgZmlsdGVycyB3aWxsIHJ1biBpbiBiZXR3ZWVuIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICogcmVzb2x1dGlvbiBhbmQgbG9hZCBiYWxhbmNpbmdcIi5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogV2UgdXNlIHRoZSBmaWx0ZXIgc3RhY2sgaGVyZSB0byBzaW1wbGlmeSB0aGUgbXVsdGktZmlsdGVyIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAqIHdhdGVyZmFsbCBsb2dpYywgYnV0IHdlIHBhc3MgYWxvbmcgdGhlIHVuZGVybHlpbmcgbGlzdCBvZiBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIGF2b2lkIGhhdmluZyBuZXN0ZWQgZmlsdGVyIHN0YWNrcyB3aGVuIGNvbWJpbmluZyBpdCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBvcmlnaW5hbCBmaWx0ZXIgc3RhY2suIFdlIGRvIG5vdCBwYXNzIGFsb25nIHRoZSBvcmlnaW5hbCBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICogZmFjdG9yeSBsaXN0IGJlY2F1c2UgdGhlc2UgZmlsdGVycyBtYXkgbmVlZCB0byBwZXJzaXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogYmV0d2VlbiBzZW5kaW5nIGhlYWRlcnMgYW5kIG90aGVyIG9wZXJhdGlvbnMuICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJTdGFja0ZhY3RvcnkgPSBuZXcgZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5KGNhbGxDb25maWcuZHluYW1pY0ZpbHRlckZhY3Rvcmllcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJTdGFjayA9IGR5bmFtaWNGaWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJTdGFjay5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKG1ldGFkYXRhKSkudGhlbihmaWx0ZXJlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhzdHJlYW0sIGZpbHRlcmVkTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJTdGFjay5nZXRGaWx0ZXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhzdHJlYW0sIG1ldGFkYXRhLCBjYWxsQ29uZmlnLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUoY2FsbENvbmZpZy5zdGF0dXMsICdGYWlsZWQgdG8gcm91dGUgY2FsbCB0byBtZXRob2QgJyArIHN0cmVhbS5nZXRNZXRob2QoKSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29kZSwgZGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0YXJ0Q2FsbFN0cmVhbShzdHJlYW0sIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMudHJ5R2V0Q29uZmlnKHN0cmVhbSwgbWV0YWRhdGEuY2xvbmUoKSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZih0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eVN0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgaWYgKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgfVxuICAgIHdhdGNoQ29ubmVjdGl2aXR5U3RhdGUoY3VycmVudFN0YXRlLCBkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5uZWwgaGFzIGJlZW4gc2h1dCBkb3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgaWYgKGRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgY29uc3QgZGVhZGxpbmVEYXRlID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUgOiBuZXcgRGF0ZShkZWFkbGluZSk7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGRlYWRsaW5lID09PSAtSW5maW5pdHkgfHwgZGVhZGxpbmVEYXRlIDw9IG5vdykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcignRGVhZGxpbmUgcGFzc2VkIHdpdGhvdXQgY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRGVhZGxpbmUgcGFzc2VkIHdpdGhvdXQgY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZScpKTtcbiAgICAgICAgICAgIH0sIGRlYWRsaW5lRGF0ZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YXRjaGVyT2JqZWN0ID0ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB0aW1lcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnB1c2god2F0Y2hlck9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIGNoYW5uZWwuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHlwZW9mIGRlYWRsaW5lID09PSAnbnVtYmVyJyB8fCBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSBnZXROZXdDYWxsTnVtYmVyKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZUNhbGwgWycgK1xuICAgICAgICAgICAgY2FsbE51bWJlciArXG4gICAgICAgICAgICAnXSBtZXRob2Q9XCInICtcbiAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xuICAgICAgICAgICAgZGVhZGxpbmUpO1xuICAgICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkZWFkbGluZTogZGVhZGxpbmUsXG4gICAgICAgICAgICBmbGFnczogcHJvcGFnYXRlRmxhZ3MgIT09IG51bGwgJiYgcHJvcGFnYXRlRmxhZ3MgIT09IHZvaWQgMCA/IHByb3BhZ2F0ZUZsYWdzIDogY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFRkFVTFRTLFxuICAgICAgICAgICAgaG9zdDogaG9zdCAhPT0gbnVsbCAmJiBob3N0ICE9PSB2b2lkIDAgPyBob3N0IDogdGhpcy5kZWZhdWx0QXV0aG9yaXR5LFxuICAgICAgICAgICAgcGFyZW50Q2FsbDogcGFyZW50Q2FsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGNhbGxfc3RyZWFtXzEuSHR0cDJDYWxsU3RyZWFtKG1ldGhvZCwgdGhpcywgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeSwgdGhpcy5jcmVkZW50aWFscy5fZ2V0Q2FsbENyZWRlbnRpYWxzKCksIGNhbGxOdW1iZXIpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIHN0cmVhbS5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gQ2hhbm5lbEltcGxlbWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor() {\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map(event => {\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor() {\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch (child.kind) {\n            case 'channel': {\n                let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : { ref: child, count: 0 };\n                trackedChild.count += 1;\n                this.channelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'subchannel': {\n                let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : { ref: child, count: 0 };\n                trackedChild.count += 1;\n                this.subchannelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'socket': {\n                let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : { ref: child, count: 0 };\n                trackedChild.count += 1;\n                this.socketChildren.set(child.id, trackedChild);\n                break;\n            }\n        }\n    }\n    unrefChild(child) {\n        switch (child.kind) {\n            case 'channel': {\n                let trackedChild = this.channelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.channelChildren.delete(child.id);\n                    }\n                    else {\n                        this.channelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'subchannel': {\n                let trackedChild = this.subchannelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.subchannelChildren.delete(child.id);\n                    }\n                    else {\n                        this.subchannelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'socket': {\n                let trackedChild = this.socketChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.socketChildren.delete(child.id);\n                    }\n                    else {\n                        this.socketChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()) {\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()) {\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()) {\n            sockets.push(ref);\n        }\n        return { channels, subchannels, sockets };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor() {\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'channel' };\n    if (channelzEnabled) {\n        channels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'subchannel' };\n    if (channelzEnabled) {\n        subchannels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, kind: 'server' };\n    if (channelzEnabled) {\n        servers[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'socket' };\n    if (channelzEnabled) {\n        sockets[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch (ref.kind) {\n        case 'channel':\n            delete channels[ref.id];\n            return;\n        case 'subchannel':\n            delete subchannels[ref.id];\n            return;\n        case 'server':\n            delete servers[ref.id];\n            return;\n        case 'socket':\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n    if (addressChunk === '') {\n        return [];\n    }\n    const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n    if (net_1.isIPv4(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n    }\n    else if (net_1.isIPv6(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf('::');\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = '';\n        }\n        else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n    }\n    else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch (state) {\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: 'CONNECTING'\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: 'IDLE'\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: 'READY'\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: 'SHUTDOWN'\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: 'TRANSIENT_FAILURE'\n            };\n        default:\n            return {\n                state: 'UNKNOWN'\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: (millisSinceEpoch / 1000) | 0,\n        nanos: (millisSinceEpoch % 1000) * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No channel data found for id ' + channelId\n        });\n        return;\n    }\n    callback(null, { channel: getChannelMessage(channelEntry) });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for (; i < channels.length; i++) {\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No server data found for id ' + serverId\n        });\n        return;\n    }\n    callback(null, { server: getServerMessage(serverEntry) });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for (; i < servers.length; i++) {\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No subchannel data found for id ' + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n    };\n    callback(null, { subchannel: subchannelMessage });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n        return {\n            address: 'tcpip_address',\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    }\n    else {\n        return {\n            address: 'uds_address',\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No socket data found for id ' + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: 'tls',\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null,\n        }\n    };\n    callback(null, { socket: socketMessage });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            'code': constants_1.Status.NOT_FOUND,\n            'details': 'No server data found for id ' + serverId\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for (; i < allSockets.length; i++) {\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync('channelz.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;\n//# sourceMappingURL=channelz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsb0NBQW9DLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCLEdBQUcsK0JBQStCLEdBQUcscUJBQXFCO0FBQ25WLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSw2Q0FBNkM7QUFDNUgsaUZBQWlGLDhDQUE4QztBQUMvSDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUpBQXNDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsei5qcz83NDE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uID0gZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZXhwb3J0cy51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYgPSBleHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQgPSBleHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCA9IGV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlciA9IGV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIgPSBleHBvcnRzLkNoYW5uZWx6VHJhY2UgPSB2b2lkIDA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBhZG1pbl8xID0gcmVxdWlyZShcIi4vYWRtaW5cIik7XG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XG5mdW5jdGlvbiBjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWVcbiAgICB9O1xufVxuZnVuY3Rpb24gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZFxuICAgIH07XG59XG5mdW5jdGlvbiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc29ja2V0X2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lXG4gICAgfTtcbn1cbi8qKlxuICogVGhlIGxvb3NlIHVwcGVyIGJvdW5kIG9uIHRoZSBudW1iZXIgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIHJldGFpbmVkIGluIGFcbiAqIHRyYWNlLiBUaGlzIG1heSBiZSBleGNlZWRlZCBieSB1cCB0byBhIGZhY3RvciBvZiAyLiBBcmJpdHJhcmlseSBjaG9zZW4gYXMgYVxuICogbnVtYmVyIHRoYXQgc2hvdWxkIGJlIGxhcmdlIGVub3VnaCB0byBjb250YWluIHRoZSByZWNlbnQgcmVsZXZhbnRcbiAqIGluZm9ybWF0aW9uLCBidXQgc21hbGwgZW5vdWdoIHRvIG5vdCB1c2UgZXhjZXNzaXZlIG1lbW9yeS5cbiAqL1xuY29uc3QgVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyA9IDMyO1xuY2xhc3MgQ2hhbm5lbHpUcmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRzTG9nZ2VkID0gMDtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGFkZFRyYWNlKHNldmVyaXR5LCBkZXNjcmlwdGlvbiwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBzZXZlcml0eTogc2V2ZXJpdHksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGNoaWxkQ2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ2NoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGlsZFN1YmNoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdzdWJjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXaGVuZXZlciB0aGUgdHJhY2UgYXJyYXkgZ2V0cyB0b28gbGFyZ2UsIGRpc2NhcmQgdGhlIGZpcnN0IGhhbGZcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSBUQVJHRVRfUkVUQUlORURfVFJBQ0VTICogMikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCArPSAxO1xuICAgIH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IGV2ZW50LnNldmVyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfcmVmOiBldmVudC5jaGlsZENoYW5uZWwgPyBjaGFubmVsUmVmVG9NZXNzYWdlKGV2ZW50LmNoaWxkQ2hhbm5lbCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsX3JlZjogZXZlbnQuY2hpbGRTdWJjaGFubmVsID8gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZFN1YmNoYW5uZWwpIDogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tlZENoaWxkID0gKF9hID0gdGhpcy5jaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeyByZWY6IGNoaWxkLCBjb3VudDogMCB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrZWRDaGlsZCA9IChfYiA9IHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHsgcmVmOiBjaGlsZCwgY291bnQ6IDAgfTtcbiAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzb2NrZXQnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrZWRDaGlsZCA9IChfYyA9IHRoaXMuc29ja2V0Q2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogeyByZWY6IGNoaWxkLCBjb3VudDogMCB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgc3dpdGNoIChjaGlsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2VkQ2hpbGQgPSB0aGlzLmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrZWRDaGlsZCA9IHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc29ja2V0Jzoge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2VkQ2hpbGQgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGlsZExpc3RzKCkge1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5jaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLnNvY2tldENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXRzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFubmVscywgc3ViY2hhbm5lbHMsIHNvY2tldHMgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXI7XG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N0YXJ0ZWQgPSAwO1xuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbnVsbDtcbiAgICB9XG4gICAgYWRkQ2FsbFN0YXJ0ZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkICs9IDE7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCArPSAxO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkICs9IDE7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gQ2hhbm5lbHpDYWxsVHJhY2tlcjtcbmxldCBuZXh0SWQgPSAxO1xuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiBuZXh0SWQrKztcbn1cbmNvbnN0IGNoYW5uZWxzID0gW107XG5jb25zdCBzdWJjaGFubmVscyA9IFtdO1xuY29uc3Qgc2VydmVycyA9IFtdO1xuY29uc3Qgc29ja2V0cyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnY2hhbm5lbCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIGNoYW5uZWxzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWw7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQ6ICdzdWJjaGFubmVsJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc3ViY2hhbm5lbHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIoZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBraW5kOiAnc2VydmVyJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc2VydmVyc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gcmVnaXN0ZXJDaGFubmVselNlcnZlcjtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc29ja2V0JyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc29ja2V0c1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gcmVnaXN0ZXJDaGFubmVselNvY2tldDtcbmZ1bmN0aW9uIHVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpIHtcbiAgICBzd2l0Y2ggKHJlZi5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2NoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIGNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIHN1YmNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3NlcnZlcic6XG4gICAgICAgICAgICBkZWxldGUgc2VydmVyc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzb2NrZXQnOlxuICAgICAgICAgICAgZGVsZXRlIHNvY2tldHNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG5leHBvcnRzLnVucmVnaXN0ZXJDaGFubmVselJlZiA9IHVucmVnaXN0ZXJDaGFubmVselJlZjtcbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc2VjdGlvbiBvZiBhbiBJUHY2IGFkZHJlc3MgYXMgdHdvIGJ5dGVzXG4gKiBAcGFyYW0gYWRkcmVzc1NlY3Rpb24gQSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgbGVuZ3RoIHVwIHRvIDRcbiAqIEByZXR1cm5zIFRoZSBwYWlyIG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3Mgc2VjdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZUlQdjZTZWN0aW9uKGFkZHJlc3NTZWN0aW9uKSB7XG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoYWRkcmVzc1NlY3Rpb24sIDE2KTtcbiAgICByZXR1cm4gW251bWJlclZhbHVlIC8gMjU2IHwgMCwgbnVtYmVyVmFsdWUgJSAyNTZdO1xufVxuLyoqXG4gKiBQYXJzZSBhIGNodW5rIG9mIGFuIElQdjYgYWRkcmVzcyBzdHJpbmcgdG8gc29tZSBudW1iZXIgb2YgYnl0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzQ2h1bmsgU29tZSBudW1iZXIgb2Ygc2VnbWVudHMgb2YgdXAgdG8gNCBoZXhhZGVjaW1hbFxuICogICBjaGFyYWN0ZXJzIGVhY2gsIGpvaW5lZCBieSBjb2xvbnMuXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIGNodW5rXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSVB2NkNodW5rKGFkZHJlc3NDaHVuaykge1xuICAgIGlmIChhZGRyZXNzQ2h1bmsgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZVBhaXJzID0gYWRkcmVzc0NodW5rLnNwbGl0KCc6JykubWFwKHNlY3Rpb24gPT4gcGFyc2VJUHY2U2VjdGlvbihzZWN0aW9uKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoLi4uYnl0ZVBhaXJzKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NCBvciBJUHY2IGFkZHJlc3MgZnJvbSBzdHJpbmcgcmVwcmVzZW50YXRpb24gdG8gYmluYXJ5XG4gKiByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIGlwQWRkcmVzcyBhbiBJUCBhZGRyZXNzIGluIHN0YW5kYXJkIElQdjQgb3IgSVB2NiB0ZXh0IGZvcm1hdFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXBBZGRyZXNzU3RyaW5nVG9CdWZmZXIoaXBBZGRyZXNzKSB7XG4gICAgaWYgKG5ldF8xLmlzSVB2NChpcEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20oaXBBZGRyZXNzLnNwbGl0KCcuJykubWFwKHNlZ21lbnQgPT4gTnVtYmVyLnBhcnNlSW50KHNlZ21lbnQpKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXRfMS5pc0lQdjYoaXBBZGRyZXNzKSkge1xuICAgICAgICBsZXQgbGVmdFNlY3Rpb247XG4gICAgICAgIGxldCByaWdodFNlY3Rpb247XG4gICAgICAgIGNvbnN0IGRvdWJsZUNvbG9uSW5kZXggPSBpcEFkZHJlc3MuaW5kZXhPZignOjonKTtcbiAgICAgICAgaWYgKGRvdWJsZUNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcztcbiAgICAgICAgICAgIHJpZ2h0U2VjdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKDAsIGRvdWJsZUNvbG9uSW5kZXgpO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZyhkb3VibGVDb2xvbkluZGV4ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhcnNlSVB2NkNodW5rKGxlZnRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsocmlnaHRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IG1pZGRsZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiAtIGxlZnRCdWZmZXIubGVuZ3RoIC0gcmlnaHRCdWZmZXIubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2xlZnRCdWZmZXIsIG1pZGRsZUJ1ZmZlciwgcmlnaHRCdWZmZXJdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnQ09OTkVDVElORydcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdJRExFJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdSRUFEWSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV046XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnU0hVVERPV04nXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1RSQU5TSUVOVF9GQUlMVVJFJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdVTktOT1dOJ1xuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRlVG9Qcm90b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaWxsaXNTaW5jZUVwb2NoID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpc1NpbmNlRXBvY2ggLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAobWlsbGlzU2luY2VFcG9jaCAlIDEwMDApICogMTAwMDAwMFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIHtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogY2hhbm5lbFJlZlRvTWVzc2FnZShjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5uZWxfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uY2hhbm5lbHMubWFwKHJlZiA9PiBjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikpLFxuICAgICAgICBzdWJjaGFubmVsX3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLnN1YmNoYW5uZWxzLm1hcChyZWYgPT4gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpKVxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRDaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2hhbm5lbElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5jaGFubmVsX2lkKTtcbiAgICBjb25zdCBjaGFubmVsRW50cnkgPSBjaGFubmVsc1tjaGFubmVsSWRdO1xuICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAnY29kZSc6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICAnZGV0YWlscyc6ICdObyBjaGFubmVsIGRhdGEgZm91bmQgZm9yIGlkICcgKyBjaGFubmVsSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgeyBjaGFubmVsOiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIH0pO1xufVxuZnVuY3Rpb24gR2V0VG9wQ2hhbm5lbHMoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cyk7XG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xuICAgIGxldCBpID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9jaGFubmVsX2lkKTtcbiAgICBmb3IgKDsgaSA8IGNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxFbnRyeSA9IGNoYW5uZWxzW2ldO1xuICAgICAgICBpZiAoY2hhbm5lbEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpKTtcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgY2hhbm5lbDogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpID49IHNlcnZlcnMubGVuZ3RoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogc2VydmVyUmVmVG9NZXNzYWdlKHNlcnZlckVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKClcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuX3NvY2tldDogcmVzb2x2ZWRJbmZvLmxpc3RlbmVyQ2hpbGRyZW4uc29ja2V0cy5tYXAocmVmID0+IHNvY2tldFJlZlRvTWVzc2FnZShyZWYpKVxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXIoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc2VydmVyX2lkKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyeSA9IHNlcnZlcnNbc2VydmVySWRdO1xuICAgIGlmIChzZXJ2ZXJFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICdjb2RlJzogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgICdkZXRhaWxzJzogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzZXJ2ZXI6IGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpIH0pO1xufVxuZnVuY3Rpb24gR2V0U2VydmVycyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NlcnZlcl9pZCk7XG4gICAgZm9yICg7IGkgPCBzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tpXTtcbiAgICAgICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSk7XG4gICAgICAgIGlmIChyZXN1bHRMaXN0Lmxlbmd0aCA+PSBtYXhSZXN1bHRzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNlcnZlcjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpID49IHNlcnZlcnMubGVuZ3RoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBHZXRTdWJjaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3ViY2hhbm5lbElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdWJjaGFubmVsX2lkKTtcbiAgICBjb25zdCBzdWJjaGFubmVsRW50cnkgPSBzdWJjaGFubmVsc1tzdWJjaGFubmVsSWRdO1xuICAgIGlmIChzdWJjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAnY29kZSc6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICAnZGV0YWlscyc6ICdObyBzdWJjaGFubmVsIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzdWJjaGFubmVsSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc3ViY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzdWJjaGFubmVsTWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHN1YmNoYW5uZWxFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHJlc29sdmVkSW5mby50YXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKClcbiAgICAgICAgfSxcbiAgICAgICAgc29ja2V0X3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLnNvY2tldHMubWFwKHJlZiA9PiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSlcbiAgICB9O1xuICAgIGNhbGxiYWNrKG51bGwsIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbE1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvQWRkcmVzc01lc3NhZ2Uoc3ViY2hhbm5lbEFkZHJlc3MpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3Moc3ViY2hhbm5lbEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAndGNwaXBfYWRkcmVzcycsXG4gICAgICAgICAgICB0Y3BpcF9hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaXBfYWRkcmVzczogKF9hID0gaXBBZGRyZXNzU3RyaW5nVG9CdWZmZXIoc3ViY2hhbm5lbEFkZHJlc3MuaG9zdCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwb3J0OiBzdWJjaGFubmVsQWRkcmVzcy5wb3J0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3Vkc19hZGRyZXNzJyxcbiAgICAgICAgICAgIHVkc19hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHN1YmNoYW5uZWxBZGRyZXNzLnBhdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBHZXRTb2NrZXQoY2FsbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHNvY2tldElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zb2NrZXRfaWQpO1xuICAgIGNvbnN0IHNvY2tldEVudHJ5ID0gc29ja2V0c1tzb2NrZXRJZF07XG4gICAgaWYgKHNvY2tldEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgJ2NvZGUnOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgJ2RldGFpbHMnOiAnTm8gc29ja2V0IGRhdGEgZm91bmQgZm9yIGlkICcgKyBzb2NrZXRJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzb2NrZXRFbnRyeS5nZXRJbmZvKCk7XG4gICAgY29uc3Qgc2VjdXJpdHlNZXNzYWdlID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5ID8ge1xuICAgICAgICBtb2RlbDogJ3RscycsXG4gICAgICAgIHRsczoge1xuICAgICAgICAgICAgY2lwaGVyX3N1aXRlOiByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUgPyAnc3RhbmRhcmRfbmFtZScgOiAnb3RoZXJfbmFtZScsXG4gICAgICAgICAgICBzdGFuZGFyZF9uYW1lOiAoX2EgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aGVyX25hbWU6IChfYiA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5jaXBoZXJTdWl0ZU90aGVyTmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbG9jYWxfY2VydGlmaWNhdGU6IChfYyA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5sb2NhbENlcnRpZmljYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZW1vdGVfY2VydGlmaWNhdGU6IChfZCA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5yZW1vdGVDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9IDogbnVsbDtcbiAgICBjb25zdCBzb2NrZXRNZXNzYWdlID0ge1xuICAgICAgICByZWY6IHNvY2tldFJlZlRvTWVzc2FnZShzb2NrZXRFbnRyeS5yZWYpLFxuICAgICAgICBsb2NhbDogcmVzb2x2ZWRJbmZvLmxvY2FsQWRkcmVzcyA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzKSA6IG51bGwsXG4gICAgICAgIHJlbW90ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUFkZHJlc3MgPyBzdWJjaGFubmVsQWRkcmVzc1RvQWRkcmVzc01lc3NhZ2UocmVzb2x2ZWRJbmZvLnJlbW90ZUFkZHJlc3MpIDogbnVsbCxcbiAgICAgICAgcmVtb3RlX25hbWU6IChfZSA9IHJlc29sdmVkSW5mby5yZW1vdGVOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3VyaXR5OiBzZWN1cml0eU1lc3NhZ2UsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGtlZXBfYWxpdmVzX3NlbnQ6IHJlc29sdmVkSW5mby5rZWVwQWxpdmVzU2VudCxcbiAgICAgICAgICAgIHN0cmVhbXNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc19mYWlsZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9sb2NhbF9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfcmVtb3RlX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3JlY2VpdmVkOiByZXNvbHZlZEluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3NlbnQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2VfcmVjZWl2ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbG9jYWxfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3cgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvdyB9IDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3cgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3cgfSA6IG51bGwsXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNhbGxiYWNrKG51bGwsIHsgc29ja2V0OiBzb2NrZXRNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gR2V0U2VydmVyU29ja2V0cyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgJ2NvZGUnOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgJ2RldGFpbHMnOiAnTm8gc2VydmVyIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzZXJ2ZXJJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zb2NrZXRfaWQpO1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzZXJ2ZXJFbnRyeS5nZXRJbmZvKCk7XG4gICAgLy8gSWYgd2Ugd2FudGVkIHRvIGluY2x1ZGUgbGlzdGVuZXIgc29ja2V0cyBpbiB0aGUgcmVzdWx0LCB0aGlzIGxpbmUgd291bGRcbiAgICAvLyBpbnN0ZWFkIHNheVxuICAgIC8vIGNvbnN0IGFsbFNvY2tldHMgPSByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLmNvbmNhdChyZXNvbHZlZEluZm8uc2Vzc2lvbkNoaWxkcmVuLnNvY2tldHMpLnNvcnQoKHJlZjEsIHJlZjIpID0+IHJlZjEuaWQgLSByZWYyLmlkKTtcbiAgICBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzLnNvcnQoKHJlZjEsIHJlZjIpID0+IHJlZjEuaWQgLSByZWYyLmlkKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgYWxsU29ja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYWxsU29ja2V0c1tpXS5pZCA+PSBzdGFydElkKSB7XG4gICAgICAgICAgICByZXN1bHRMaXN0LnB1c2goc29ja2V0UmVmVG9NZXNzYWdlKGFsbFNvY2tldHNbaV0pKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRMaXN0Lmxlbmd0aCA+PSBtYXhSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBzb2NrZXRfcmVmOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gYWxsU29ja2V0cy5sZW5ndGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR2V0Q2hhbm5lbCxcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXG4gICAgICAgIEdldFNlcnZlcixcbiAgICAgICAgR2V0U2VydmVycyxcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcbiAgICAgICAgR2V0U29ja2V0LFxuICAgICAgICBHZXRTZXJ2ZXJTb2NrZXRzXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGdldENoYW5uZWx6SGFuZGxlcnM7XG5sZXQgbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uID0gbnVsbDtcbmZ1bmN0aW9uIGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24oKSB7XG4gICAgaWYgKGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uO1xuICAgIH1cbiAgICAvKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNvbXBsZXhpdHkgaXMgdG8gYXZvaWQgbG9hZGluZyBAZ3JwYy9wcm90by1sb2FkZXIgYXRcbiAgICAgKiBydW50aW1lIGZvciB1c2VycyB3aG8gd2lsbCBub3QgdXNlL2VuYWJsZSBjaGFubmVsei4gKi9cbiAgICBjb25zdCBsb2FkZXJMb2FkU3luYyA9IHJlcXVpcmUoJ0BncnBjL3Byb3RvLWxvYWRlcicpLmxvYWRTeW5jO1xuICAgIGNvbnN0IGxvYWRlZFByb3RvID0gbG9hZGVyTG9hZFN5bmMoJ2NoYW5uZWx6LnByb3RvJywge1xuICAgICAgICBrZWVwQ2FzZTogdHJ1ZSxcbiAgICAgICAgbG9uZ3M6IFN0cmluZyxcbiAgICAgICAgZW51bXM6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdHM6IHRydWUsXG4gICAgICAgIG9uZW9mczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZURpcnM6IFtcbiAgICAgICAgICAgIGAke19fZGlybmFtZX0vLi4vLi4vcHJvdG9gXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICBjb25zdCBjaGFubmVsekdycGNPYmplY3QgPSBtYWtlX2NsaWVudF8xLmxvYWRQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRQcm90byk7XG4gICAgbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uID0gY2hhbm5lbHpHcnBjT2JqZWN0LmdycGMuY2hhbm5lbHoudjEuQ2hhbm5lbHouc2VydmljZTtcbiAgICByZXR1cm4gbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uO1xufVxuZXhwb3J0cy5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uID0gZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2UoZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0Q2hhbm5lbHpIYW5kbGVycyk7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsei5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_stream_1 = __webpack_require__(/*! ./call-stream */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InterceptorConfigurationError';\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status,\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor() {\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel,\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveStatus: (status, next) => {\n        next(status);\n    },\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n    start: (metadata, listener, next) => {\n        next(metadata, listener);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    halfClose: (next) => {\n        next();\n    },\n    cancel: (next) => {\n        next();\n    },\n};\nclass InterceptingCall {\n    constructor(nextCall, requester) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */\n        this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */\n        this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\n            };\n        }\n        else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(() => {\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : ((metadata) => { }),\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : ((message) => { }),\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : ((status) => { }),\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if (call_stream_1.isInterceptingListener(listener)) {\n                finalInterceptingListener = listener;\n            }\n            else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\n                };\n                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage) => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            }\n            else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(() => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            }\n            else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    setCredentials(credentials) {\n        this.nextCall.setCredentials(credentials);\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n    constructor(call, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition) {\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    setCredentials(credentials) {\n        this.call.setCredentials(credentials);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        }\n        catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata) => {\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message) => {\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                }\n                catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${e.message}`,\n                        metadata: new metadata_1.Metadata(),\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                }\n                else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            },\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition) {\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : ((metadata) => { }),\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message) => {\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            },\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    }\n    else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 &&\n        interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\n            'to the client constructor. Only one of these is allowed.');\n    }\n    if (interceptorArgs.callInterceptors.length > 0 &&\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\n            'options. Only one of these is allowed.');\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 ||\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = []\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition)))\n            .filter((interceptor) => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    else {\n        interceptors = []\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition)))\n            .filter((interceptor) => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition,\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n        return (currentOptions) => nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;\n//# sourceMappingURL=client-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFDQUFxQztBQUNuSixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzUkFBc1I7QUFDdFIsbVJBQW1SO0FBQ25SLGdSQUFnUjtBQUNoUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLFVBQVU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNPQUFzTztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC1pbnRlcmNlcHRvcnMuanM/ZGY5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2FsbF9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NhbGwtc3RyZWFtXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEVycm9yIGNsYXNzIGFzc29jaWF0ZWQgd2l0aCBwYXNzaW5nIGJvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvclxuICogcHJvdmlkZXJzIHRvIGEgY2xpZW50IGNvbnN0cnVjdG9yIG9yIGFzIGNhbGwgb3B0aW9ucy5cbiAqL1xuY2xhc3MgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yJztcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjtcbmNsYXNzIExpc3RlbmVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXRhZGF0YShvblJlY2VpdmVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb25SZWNlaXZlTWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlTWVzc2FnZShvblJlY2VpdmVNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG9uUmVjZWl2ZU1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlU3RhdHVzKG9uUmVjZWl2ZVN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG9uUmVjZWl2ZVN0YXR1cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gTGlzdGVuZXJCdWlsZGVyO1xuY2xhc3MgUmVxdWVzdGVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aXRoU3RhcnQoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFNlbmRNZXNzYWdlKHNlbmRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aEhhbGZDbG9zZShoYWxmQ2xvc2UpIHtcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSBoYWxmQ2xvc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoQ2FuY2VsKGNhbmNlbCkge1xuICAgICAgICB0aGlzLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgaGFsZkNsb3NlOiB0aGlzLmhhbGZDbG9zZSxcbiAgICAgICAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gUmVxdWVzdGVyQnVpbGRlcjtcbi8qKlxuICogQSBMaXN0ZW5lciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBMaXN0ZW5lcnMgd2l0aCBzb21lIG1ldGhvZHMgb21pdHRlZC5cbiAqL1xuY29uc3QgZGVmYXVsdExpc3RlbmVyID0ge1xuICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAobWV0YWRhdGEsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoc3RhdHVzKTtcbiAgICB9LFxufTtcbi8qKlxuICogQSBSZXF1ZXN0ZXIgd2l0aCBhIGRlZmF1bHQgcGFzcy10aHJvdWdoIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kLiBVc2VkXG4gKiBmb3IgZmlsbGluZyBvdXQgUmVxdWVzdGVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0UmVxdWVzdGVyID0ge1xuICAgIHN0YXJ0OiAobWV0YWRhdGEsIGxpc3RlbmVyLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIHNlbmRNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgaGFsZkNsb3NlOiAobmV4dCkgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBjYW5jZWw6IChuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxufTtcbmNsYXNzIEludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKG5leHRDYWxsLCByZXF1ZXN0ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBtZXRhZGF0YSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHN0YXJ0XG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSBjb250ZXh0IGZvciBhIHBlbmRpbmcgbWVzc2FnZSB0aGF0IGlzIHdhaXRpbmcgZm9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIG1lc3NhZ2UgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzZW5kTWVzc2FnZVxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBzdGF0dXMgd2FzIHJlY2VpdmVkIGJ1dCBjb3VsZCBub3QgYmUgcHJvcGFnYXRlZCBiZWNhdXNlXG4gICAgICAgICAqIGEgbWVzc2FnZSB3YXMgc3RpbGwgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXF1ZXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAoX2EgPSByZXF1ZXN0ZXIuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRSZXF1ZXN0ZXIuc3RhcnQsXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChfYiA9IHJlcXVlc3Rlci5zZW5kTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlcXVlc3Rlci5zZW5kTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBoYWxmQ2xvc2U6IChfYyA9IHJlcXVlc3Rlci5oYWxmQ2xvc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZXF1ZXN0ZXIuaGFsZkNsb3NlLFxuICAgICAgICAgICAgICAgIGNhbmNlbDogKF9kID0gcmVxdWVzdGVyLmNhbmNlbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdFJlcXVlc3Rlci5jYW5jZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSBkZWZhdWx0UmVxdWVzdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKChtZXRhZGF0YSkgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChfZCA9IChfYyA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICgobWVzc2FnZSkgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9mID0gKF9lID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAoKHN0YXR1cykgPT4geyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zdGFydChtZXRhZGF0YSwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyLCAobWQsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmIChjYWxsX3N0cmVhbV8xLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9hID0gbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9jID0gbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBjYWxsX3N0cmVhbV8xLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbChmdWxsTGlzdGVuZXIsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0KG1kLCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgKGZpbmFsTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGZpbmFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5oYWxmQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMubmV4dENhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IEludGVyY2VwdGluZ0NhbGw7XG5mdW5jdGlvbiBnZXRDYWxsKGNoYW5uZWwsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRlYWRsaW5lID0gKF9hID0gb3B0aW9ucy5kZWFkbGluZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XG4gICAgY29uc3QgaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2IgPSBvcHRpb25zLnBhcmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICBjb25zdCBwcm9wYWdhdGVGbGFncyA9IG9wdGlvbnMucHJvcGFnYXRlX2ZsYWdzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICBjb25zdCBjYWxsID0gY2hhbm5lbC5jcmVhdGVDYWxsKHBhdGgsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnQsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY2FsbC5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsO1xufVxuLyoqXG4gKiBJbnRlcmNlcHRpbmdDYWxsIGltcGxlbWVudGF0aW9uIHRoYXQgZGlyZWN0bHkgb3ducyB0aGUgdW5kZXJseWluZyBDYWxsXG4gKiBvYmplY3QgYW5kIGhhbmRsZXMgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJhaXpsaWF0aW9uLlxuICovXG5jbGFzcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0aG9kRGVmaW5pdGlvbiA9IG1ldGhvZERlZmluaXRpb247XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVxdWVzdFNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgUmVxdWVzdCBtZXNzYWdlIHNlcmlhbGl6YXRpb24gZmFpbHVyZTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IHJlYWRFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydChtZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZURlc2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVzcG9uc2UgbWVzc2FnZSBwYXJzaW5nIGVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHJlYWRFcnJvci5jb2RlLCByZWFkRXJyb3IuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBkZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgcmVhZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCB1bmFyeVxuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcihjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZWNlaXZlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgd3JhcHBlckxpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQobGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoKG1ldGFkYXRhKSA9PiB7IH0pLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGxpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIuc3RhcnQobWV0YWRhdGEsIHdyYXBwZXJMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHN0cmVhbWluZ1xuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbn1cbmZ1bmN0aW9uIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgb3B0aW9ucywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbikge1xuICAgIGNvbnN0IGNhbGwgPSBnZXRDYWxsKGNoYW5uZWwsIG1ldGhvZERlZmluaXRpb24ucGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKG1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbChjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWV0aG9kRGVmaW5pdGlvbiwgb3B0aW9ucywgY2hhbm5lbCkge1xuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBjYWxsICcgK1xuICAgICAgICAgICAgJ29wdGlvbnMuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgfVxuICAgIGxldCBpbnRlcmNlcHRvcnMgPSBbXTtcbiAgICAvLyBJbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjYWxsIG92ZXJyaWRlIGludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNsaWVudCBjb25zdHJ1Y3RvclxuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycy5sZW5ndGggPiAwIHx8XG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAoKHByb3ZpZGVyKSA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXG4gICAgICAgICAgICAuZmlsdGVyKChpbnRlcmNlcHRvcikgPT4gaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW50ZXJjZXB0b3JzID0gW11cbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcCgocHJvdmlkZXIpID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGludGVyY2VwdG9yKSA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGNvbnN0IGludGVyY2VwdG9yT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbWV0aG9kX2RlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgfSk7XG4gICAgLyogRm9yIGVhY2ggaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHRoZSBuZXh0Q2FsbCBmdW5jdGlvbiBwYXNzZWQgdG8gaXQgaXNcbiAgICAgKiBiYXNlZCBvbiB0aGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdXNpbmcgYSBuZXh0Q2FsbCBmdW5jdGlvblxuICAgICAqIGNvbnN0cnVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgYW5kIHNvIG9uLiBUaGVcbiAgICAgKiBpbml0aWFsVmFsdWUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIGlzIGEgbmV4dENhbGxcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGludm9rZXMgZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbCwgdGhlIHJlc3VsdCBvZiB3aGljaFxuICAgICAqIGhhbmRsZXMgKGRlKXNlcmlhbGl6YXRpb24gYW5kIGFsc28gZ2V0cyB0aGUgdW5kZXJseWluZyBjYWxsIGZyb20gdGhlXG4gICAgICogY2hhbm5lbC4gKi9cbiAgICBjb25zdCBnZXRDYWxsID0gaW50ZXJjZXB0b3JzLnJlZHVjZVJpZ2h0KChuZXh0Q2FsbCwgbmV4dEludGVyY2VwdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiAoY3VycmVudE9wdGlvbnMpID0+IG5leHRJbnRlcmNlcHRvcihjdXJyZW50T3B0aW9ucywgbmV4dENhbGwpO1xuICAgIH0sIChmaW5hbE9wdGlvbnMpID0+IGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgZmluYWxPcHRpb25zLCBtZXRob2REZWZpbml0aW9uKSk7XG4gICAgcmV0dXJuIGdldENhbGwoaW50ZXJjZXB0b3JPcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGdldEludGVyY2VwdGluZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtaW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n    return error.stack.split('\\n').slice(1).join('\\n');\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\n                'to the client constructor. Only one of these is allowed.');\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n            options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                isFunction(arg3))) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata) => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata) => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit('status', status);\n            },\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit('status', status);\n            },\n        });\n        return stream;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsOEJBQThCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQWdEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC5qcz83YjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfMSA9IHJlcXVpcmUoXCIuL2NhbGxcIik7XG5jb25zdCBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5jb25zdCBDSEFOTkVMX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgSU5URVJDRVBUT1JfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IENBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0wgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBnZXRFcnJvclN0YWNrU3RyaW5nKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5qb2luKCdcXG4nKTtcbn1cbi8qKlxuICogQSBnZW5lcmljIGdSUEMgY2xpZW50LiBQcmltYXJpbHkgdXNlZnVsIGFzIGEgYmFzZSBjbGFzcyBmb3IgYWxsIGdlbmVyYXRlZFxuICogY2xpZW50cy5cbiAqL1xuY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdID0gKF9hID0gb3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcnM7XG4gICAgICAgIHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSA9IChfYiA9IG9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzO1xuICAgICAgICBpZiAodGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcbiAgICAgICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdID1cbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbEludm9jYXRpb25UcmFuc2Zvcm1lcjtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2FsbEludm9jYXRpb25UcmFuc2Zvcm1lcjtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbE92ZXJyaWRlKSB7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG9wdGlvbnMuY2hhbm5lbE92ZXJyaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZhY3RvcnlPdmVycmlkZSA9IG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGU7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IGNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBuZXcgY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmNsb3NlKCk7XG4gICAgfVxuICAgIGdldENoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0NIQU5ORUxfU1lNQk9MXTtcbiAgICB9XG4gICAgd2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjaGVja1N0YXRlID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgYmVmb3JlIHRoZSBkZWFkbGluZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpc1tDSEFOTkVMX1NZTUJPTF0uZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0ud2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShuZXdTdGF0ZSwgZGVhZGxpbmUsIGNoZWNrU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldEltbWVkaWF0ZShjaGVja1N0YXRlKTtcbiAgICB9XG4gICAgY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihhcmcxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oYXJnMikpIHtcbiAgICAgICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiBhcmcxLCBjYWxsYmFjazogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICBhcmcyIGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihhcmczKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBhcmd1bWVudHMgcGFzc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogYXJnMSwgb3B0aW9uczogYXJnMiwgY2FsbGJhY2s6IGFyZzMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlVW5hcnlSZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFVuYXJ5Q2FsbEltcGwoKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyhzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfVxuICAgIG1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwoc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyhzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChhcmcyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XG4gICAgfVxuICAgIG1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgc3RyZWFtLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgbWFrZUJpZGlTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMobWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnREdXBsZXhTdHJlYW1JbXBsKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9IGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgaWYgKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function (CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms = exports.CompressionAlgorithms || (exports.CompressionAlgorithms = {}));\n;\n//# sourceMappingURL=compression-algorithms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQsNkJBQTZCLEtBQUs7QUFDL0Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzPzkwOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gdm9pZCAwO1xudmFyIENvbXByZXNzaW9uQWxnb3JpdGhtcztcbihmdW5jdGlvbiAoQ29tcHJlc3Npb25BbGdvcml0aG1zKSB7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImlkZW50aXR5XCJdID0gMF0gPSBcImlkZW50aXR5XCI7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImRlZmxhdGVcIl0gPSAxXSA9IFwiZGVmbGF0ZVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJnemlwXCJdID0gMl0gPSBcImd6aXBcIjtcbn0pKENvbXByZXNzaW9uQWxnb3JpdGhtcyA9IGV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zIHx8IChleHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHt9KSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key) => {\n    return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.inflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.unzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler();\n        case 'gzip':\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig) {\n        var _a;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */\n                if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n                }\n            }\n            else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        headers.set('accept-encoding', 'identity');\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === 'identity') {\n            headers.remove('grpc-encoding');\n        }\n        else {\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove('grpc-encoding');\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = 'identity';\n            }\n        }\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        }\n        else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* NoCompress */) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options) {\n        this.channel = channel;\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter(callStream) {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcseUJBQXlCO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQ0FBaUMsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyxxQkFBcUI7QUFDaEk7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHFCQUFxQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSSx3QkFBd0I7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbXByZXNzaW9uLWZpbHRlci5qcz82YmYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSB2b2lkIDA7XG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleSA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXNba2V5XSA9PT0gJ3N0cmluZyc7XG59O1xuY2xhc3MgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBSYXcgdW5jb21wcmVzc2VkIG1lc3NhZ2UgYnl0ZXNcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGNvbXByZXNzZWRcbiAgICAgKiBAcmV0dXJuIEZyYW1lZCBtZXNzYWdlLCBjb21wcmVzc2VkIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoY29tcHJlc3MpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVzc2FnZUJ1ZmZlci5sZW5ndGggKyA1KTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoY29tcHJlc3MgPyAxIDogMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2VCdWZmZXIubGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhIEZyYW1lZCBtZXNzYWdlLCBwb3NzaWJseSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBVbmNvbXByZXNzZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGRhdGEucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICBsZXQgbWVzc2FnZUJ1ZmZlciA9IGRhdGEuc2xpY2UoNSk7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5kZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZUJ1ZmZlcjtcbiAgICB9XG59XG5jbGFzcyBJZGVudGl0eUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGFzeW5jIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2UubGVuZ3RoICsgNSk7XG4gICAgICAgIC8qIFdpdGggXCJpZGVudGl0eVwiIGNvbXByZXNzaW9uLCBtZXNzYWdlcyBzaG91bGQgYWx3YXlzIGJlIG1hcmtlZCBhc1xuICAgICAgICAgKiB1bmNvbXByZXNzZWQgKi9cbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2UubGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZS5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUmVjZWl2ZWQgY29tcHJlc3NlZCBtZXNzYWdlIGJ1dCBcImdycGMtZW5jb2RpbmdcIiBoZWFkZXIgd2FzIGlkZW50aXR5JykpO1xuICAgIH1cbn1cbmNsYXNzIERlZmxhdGVIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5kZWZsYXRlKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLmluZmxhdGUobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgR3ppcEhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLmd6aXAobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIudW56aXAobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVW5rbm93bkhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbXByZXNzaW9uTmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTmFtZSA9IGNvbXByZXNzaW9uTmFtZTtcbiAgICB9XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvbXByZXNzaW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkOiAke3RoaXMuY29tcHJlc3Npb25OYW1lfWApKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wcmVzc2lvbkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgc3dpdGNoIChjb21wcmVzc2lvbk5hbWUpIHtcbiAgICAgICAgY2FzZSAnaWRlbnRpdHknOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgY2FzZSAnZGVmbGF0ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGVIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgJ2d6aXAnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHemlwSGFuZGxlcigpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmtub3duSGFuZGxlcihjb21wcmVzc2lvbk5hbWUpO1xuICAgIH1cbn1cbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyIGV4dGVuZHMgZmlsdGVyXzEuQmFzZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE9wdGlvbnMsIHNoYXJlZEZpbHRlckNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0gc2hhcmVkRmlsdGVyQ29uZmlnO1xuICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcbiAgICAgICAgY29uc3QgY29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSddO1xuICAgICAgICBpZiAoY29tcHJlc3Npb25BbGdvcml0aG1LZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkoY29tcHJlc3Npb25BbGdvcml0aG1LZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50U2VsZWN0ZWRFbmNvZGluZyA9IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXNbY29tcHJlc3Npb25BbGdvcml0aG1LZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IChfYSA9IHNoYXJlZEZpbHRlckNvbmZpZy5zZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzaXR1YXRpb25zIGhlcmU6XG4gICAgICAgICAgICAgICAgICogMSkgV2UgZG9uJ3QgaGF2ZSBhbnkgaW5mbyB5ZXQgZnJvbSB0aGUgc2VydmVyIGFib3V0IHdoYXQgY29tcHJlc3Npb24gaXQgc3VwcG9ydHNcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIGp1c3QgdXNlIHdoYXQgdGhlIGNsaWVudCB0ZWxscyB1cyB0byB1c2VcbiAgICAgICAgICAgICAgICAgKiAyKSBXZSd2ZSBwcmV2aW91c2x5IHJlY2VpdmVkIGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGluY2x1ZGluZyBhIGdycGMtYWNjZXB0LWVuY29kaW5nIGhlYWRlclxuICAgICAgICAgICAgICAgICAqICAgIEluIHRoYXQgY2FzZSB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoZSBlbmNvZGluZyBjaG9zZW4gYnkgdGhlIGNsaWVudCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIGl0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgfHwgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKGNsaWVudFNlbGVjdGVkRW5jb2RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gY2xpZW50U2VsZWN0ZWRFbmNvZGluZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIodGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYEludmFsaWQgdmFsdWUgcHJvdmlkZWQgZm9yIGdycGMuZGVmYXVsdF9jb21wcmVzc2lvbl9hbGdvcml0aG0gb3B0aW9uOiAke2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgbWV0YWRhdGE7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdncnBjLWFjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eSxkZWZsYXRlLGd6aXAnKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScpO1xuICAgICAgICAvLyBObyBuZWVkIHRvIHNlbmQgdGhlIGhlYWRlciBpZiBpdCdzIFwiaWRlbnRpdHlcIiAtICBiZWhhdmlvciBpcyBpZGVudGljYWw7IHNhdmUgdGhlIGJhbmR3aWR0aFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIGhlYWRlcnMucmVtb3ZlKCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1lbmNvZGluZycsIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVFbmNvZGluZyA9IG1ldGFkYXRhLmdldCgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICBpZiAocmVjZWl2ZUVuY29kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gcmVjZWl2ZUVuY29kaW5nWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uSGFuZGxlcihlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB0aGUgY29tcHJlc3Npb24gd2UncmUgdXNpbmcgdG8gc2VuZCBtZXNzYWdlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlclxuICAgICAgICAgKiBJZiBub3QsIHJlc2V0IHRoZSBzZW5kQ29tcHJlc3Npb24gZmlsdGVyIGFuZCBoYXZlIGl0IHVzZSB0aGUgZGVmYXVsdCBJZGVudGl0eUhhbmRsZXIgKi9cbiAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyID0gbWV0YWRhdGEuZ2V0KCdncnBjLWFjY2VwdC1lbmNvZGluZycpWzBdO1xuICAgICAgICBpZiAoc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZy5zZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlciA9IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXModGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgdGhlIGJhcmUgbWVzc2FnZSBieXRlcyxcbiAgICAgICAgICogYW5kIHRoZSBvdXRwdXQgaXMgYSBmcmFtZWQgYW5kIHBvc3NpYmx5IGNvbXByZXNzZWQgbWVzc2FnZS4gRm9yIHRoaXNcbiAgICAgICAgICogcmVhc29uLCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZmlsdGVyIHN0YWNrICovXG4gICAgICAgIGNvbnN0IHJlc29sdmVkTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBjb21wcmVzcztcbiAgICAgICAgaWYgKHRoaXMuc2VuZENvbXByZXNzaW9uIGluc3RhbmNlb2YgSWRlbnRpdHlIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIE5vQ29tcHJlc3MgKi8pID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBhd2FpdCB0aGlzLnNlbmRDb21wcmVzc2lvbi53cml0ZU1lc3NhZ2UocmVzb2x2ZWRNZXNzYWdlLm1lc3NhZ2UsIGNvbXByZXNzKSxcbiAgICAgICAgICAgIGZsYWdzOiByZXNvbHZlZE1lc3NhZ2UuZmxhZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgYWxzbyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyBmcmFtZWQgYW5kIHBvc3NpYmx5XG4gICAgICAgICAqIGNvbXByZXNzZWQsIGFuZCB0aGUgb3V0cHV0IG1lc3NhZ2UgaXMgZGVmcmFtZWQgYW5kIHVuY29tcHJlc3NlZC4gU29cbiAgICAgICAgICogdGhpcyBpcyBhbm90aGVyIHJlYXNvbiB0aGF0IHRoaXMgZmlsdGVyIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgICAgKiBmaWx0ZXIgc3RhY2suICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbi5yZWFkTWVzc2FnZShhd2FpdCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyID0gQ29tcHJlc3Npb25GaWx0ZXI7XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcgPSB7fTtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc2lvbkZpbHRlcih0aGlzLm9wdGlvbnMsIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSA9IENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzaW9uLWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n//# sourceMappingURL=connectivity-state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0QseUJBQXlCLEtBQUs7QUFDbkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzP2Q0MGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSB2b2lkIDA7XG52YXIgQ29ubmVjdGl2aXR5U3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpdml0eVN0YXRlKSB7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiUkVBRFlcIl0gPSAyXSA9IFwiUkVBRFlcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gM10gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJTSFVURE9XTlwiXSA9IDRdID0gXCJTSFVURE9XTlwiO1xufSkoQ29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlIHx8IChleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpdml0eS1zdGF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function (Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status = exports.Status || (exports.Status = {}));\nvar LogVerbosity;\n(function (LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity = exports.LogVerbosity || (exports.LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */\nvar Propagate;\n(function (Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate = exports.Propagate || (exports.Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsdUNBQXVDLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLGNBQWMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQyxvQkFBb0IsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQyxpQkFBaUIsS0FBSztBQUMzRDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDBDQUEwQztBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25zdGFudHMuanM/Mjg0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5Qcm9wYWdhdGUgPSBleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuU3RhdHVzID0gdm9pZCAwO1xudmFyIFN0YXR1cztcbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlJFU09VUkNFX0VYSEFVU1RFRFwiXSA9IDhdID0gXCJSRVNPVVJDRV9FWEhBVVNURURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkFCT1JURURcIl0gPSAxMF0gPSBcIkFCT1JURURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiT1VUX09GX1JBTkdFXCJdID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlRFUk5BTFwiXSA9IDEzXSA9IFwiSU5URVJOQUxcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5BVkFJTEFCTEVcIl0gPSAxNF0gPSBcIlVOQVZBSUxBQkxFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVVUSEVOVElDQVRFRFwiXSA9IDE2XSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG59KShTdGF0dXMgPSBleHBvcnRzLlN0YXR1cyB8fCAoZXhwb3J0cy5TdGF0dXMgPSB7fSkpO1xudmFyIExvZ1ZlcmJvc2l0eTtcbihmdW5jdGlvbiAoTG9nVmVyYm9zaXR5KSB7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIklORk9cIl0gPSAxXSA9IFwiSU5GT1wiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJFUlJPUlwiXSA9IDJdID0gXCJFUlJPUlwiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJOT05FXCJdID0gM10gPSBcIk5PTkVcIjtcbn0pKExvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuTG9nVmVyYm9zaXR5IHx8IChleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IHt9KSk7XG4vKipcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXG4gKiBsaWJyYXJ5LiBJdCBpcyBpbmNsdWRlZCBvbmx5IGZvciB0eXBlIHBhcml0eSB3aXRoIHRoZSBvdGhlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIFByb3BhZ2F0ZTtcbihmdW5jdGlvbiAoUHJvcGFnYXRlKSB7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIl0gPSA0XSA9IFwiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVGQVVMVFNcIl0gPSA2NTUzNV0gPSBcIkRFRkFVTFRTXCI7XG59KShQcm9wYWdhdGUgPSBleHBvcnRzLlByb3BhZ2F0ZSB8fCAoZXhwb3J0cy5Qcm9wYWdhdGUgPSB7fSkpO1xuLy8gLTEgbWVhbnMgdW5saW1pdGVkXG5leHBvcnRzLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEggPSAtMTtcbi8vIDQgTUIgZGVmYXVsdFxuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gNCAqIDEwMjQgKiAxMDI0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline-filter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst units = [\n    ['m', 1],\n    ['S', 1000],\n    ['M', 60 * 1000],\n    ['H', 60 * 60 * 1000],\n];\nfunction getDeadline(deadline) {\n    const now = new Date().getTime();\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units) {\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error('Deadline is too far in the future');\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n    constructor(channel, callStream) {\n        super();\n        this.channel = channel;\n        this.callStream = callStream;\n        this.timer = null;\n        this.deadline = Infinity;\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    retreiveDeadline() {\n        const callDeadline = this.callStream.getDeadline();\n        if (callDeadline instanceof Date) {\n            this.deadline = callDeadline.getTime();\n        }\n        else {\n            this.deadline = callDeadline;\n        }\n    }\n    runTimer() {\n        var _a, _b;\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        const now = new Date().getTime();\n        const timeout = this.deadline - now;\n        if (timeout <= 0) {\n            process.nextTick(() => {\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            });\n        }\n        else if (this.deadline !== Infinity) {\n            this.timer = setTimeout(() => {\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            }, timeout);\n            (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    refresh() {\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    async sendMetadata(metadata) {\n        if (this.deadline === Infinity) {\n            return metadata;\n        }\n        /* The input metadata promise depends on the original channel.connect()\n         * promise, so when it is complete that implies that the channel is\n         * connected */\n        const finalMetadata = await metadata;\n        const timeoutString = getDeadline(this.deadline);\n        finalMetadata.set('grpc-timeout', timeoutString);\n        return finalMetadata;\n    }\n    receiveTrailers(status) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        return status;\n    }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new DeadlineFilter(this.channel, callStream);\n    }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory;\n//# sourceMappingURL=deadline-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUtZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsc0JBQXNCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kZWFkbGluZS1maWx0ZXIuanM/MWVkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWFkbGluZUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRlYWRsaW5lRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IHVuaXRzID0gW1xuICAgIFsnbScsIDFdLFxuICAgIFsnUycsIDEwMDBdLFxuICAgIFsnTScsIDYwICogMTAwMF0sXG4gICAgWydIJywgNjAgKiA2MCAqIDEwMDBdLFxuXTtcbmZ1bmN0aW9uIGdldERlYWRsaW5lKGRlYWRsaW5lKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZW91dE1zID0gTWF0aC5tYXgoZGVhZGxpbmUgLSBub3csIDApO1xuICAgIGZvciAoY29uc3QgW3VuaXQsIGZhY3Rvcl0gb2YgdW5pdHMpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdGltZW91dE1zIC8gZmFjdG9yO1xuICAgICAgICBpZiAoYW1vdW50IDwgMWU4KSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKE1hdGguY2VpbChhbW91bnQpKSArIHVuaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWFkbGluZSBpcyB0b28gZmFyIGluIHRoZSBmdXR1cmUnKTtcbn1cbmNsYXNzIERlYWRsaW5lRmlsdGVyIGV4dGVuZHMgZmlsdGVyXzEuQmFzZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbFN0cmVhbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmNhbGxTdHJlYW0gPSBjYWxsU3RyZWFtO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnJldHJlaXZlRGVhZGxpbmUoKTtcbiAgICAgICAgdGhpcy5ydW5UaW1lcigpO1xuICAgIH1cbiAgICByZXRyZWl2ZURlYWRsaW5lKCkge1xuICAgICAgICBjb25zdCBjYWxsRGVhZGxpbmUgPSB0aGlzLmNhbGxTdHJlYW0uZ2V0RGVhZGxpbmUoKTtcbiAgICAgICAgaWYgKGNhbGxEZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSBjYWxsRGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9IGNhbGxEZWFkbGluZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZGVhZGxpbmUgLSBub3c7XG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5yZXRyZWl2ZURlYWRsaW5lKCk7XG4gICAgICAgIHRoaXMucnVuVGltZXIoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8qIFRoZSBpbnB1dCBtZXRhZGF0YSBwcm9taXNlIGRlcGVuZHMgb24gdGhlIG9yaWdpbmFsIGNoYW5uZWwuY29ubmVjdCgpXG4gICAgICAgICAqIHByb21pc2UsIHNvIHdoZW4gaXQgaXMgY29tcGxldGUgdGhhdCBpbXBsaWVzIHRoYXQgdGhlIGNoYW5uZWwgaXNcbiAgICAgICAgICogY29ubmVjdGVkICovXG4gICAgICAgIGNvbnN0IGZpbmFsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgdGltZW91dFN0cmluZyA9IGdldERlYWRsaW5lKHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICBmaW5hbE1ldGFkYXRhLnNldCgnZ3JwYy10aW1lb3V0JywgdGltZW91dFN0cmluZyk7XG4gICAgICAgIHJldHVybiBmaW5hbE1ldGFkYXRhO1xuICAgIH1cbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLkRlYWRsaW5lRmlsdGVyID0gRGVhZGxpbmVGaWx0ZXI7XG5jbGFzcyBEZWFkbGluZUZpbHRlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWFkbGluZUZpbHRlcih0aGlzLmNoYW5uZWwsIGNhbGxTdHJlYW0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVhZGxpbmVGaWx0ZXJGYWN0b3J5ID0gRGVhZGxpbmVGaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVhZGxpbmUtZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: (millis / 1000) | 0,\n        nanos: (millis % 1000) * 1000000 | 0\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return (typeof value.seconds === 'number') && (typeof value.nanos === 'number');\n}\nexports.isDuration = isDuration;\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanM/YmFiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0R1cmF0aW9uID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLm1zVG9EdXJhdGlvbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1zVG9EdXJhdGlvbihtaWxsaXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzIC8gMTAwMCkgfCAwLFxuICAgICAgICBuYW5vczogKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCB8IDBcbiAgICB9O1xufVxuZXhwb3J0cy5tc1RvRHVyYXRpb24gPSBtc1RvRHVyYXRpb247XG5mdW5jdGlvbiBkdXJhdGlvblRvTXMoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gKGR1cmF0aW9uLnNlY29uZHMgKiAxMDAwICsgZHVyYXRpb24ubmFub3MgLyAxMDAwMDAwKSB8IDA7XG59XG5leHBvcnRzLmR1cmF0aW9uVG9NcyA9IGR1cmF0aW9uVG9NcztcbmZ1bmN0aW9uIGlzRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZS5zZWNvbmRzID09PSAnbnVtYmVyJykgJiYgKHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcicpO1xufVxuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR1cmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({ enumerable: true, get: function () { return logging_1.trace; } }));\nObject.defineProperty(exports, \"log\", ({ enumerable: true, get: function () { return logging_1.log; } }));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({ enumerable: true, get: function () { return duration_1.durationToMs; } }));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({ enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } }));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({ enumerable: true, get: function () { return load_balancer_1.getFirstUsableConfig; } }));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_1.validateLoadBalancingConfig; } }));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({ enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } }));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));\nObject.defineProperty(exports, \"QueuePicker\", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));\nObject.defineProperty(exports, \"PickResultType\", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({ enumerable: true, get: function () { return admin_1.registerAdminService; } }));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({ enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } }));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig; } }));\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLHlDQUF3QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMzRyx1Q0FBc0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDdkcsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7QUFDckMsb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFjO0FBQ3pDLCtDQUE4QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMxSCxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsd0JBQXdCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ25ELGtEQUFpRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNySSxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDL0MsbUVBQWtFLEVBQUUscUNBQXFDLDJEQUEyRCxFQUFDO0FBQ3JLLDREQUEyRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUN2Six3REFBdUQsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDL0ksK0RBQThELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQzdKLDJCQUEyQixtQkFBTyxDQUFDLGdHQUFzQjtBQUN6RCw2REFBNEQsRUFBRSxxQ0FBcUMsMERBQTBELEVBQUM7QUFDOUosb0NBQW9DLG1CQUFPLENBQUMsa0hBQStCO0FBQzNFLDREQUEyRCxFQUFFLHFDQUFxQyxrRUFBa0UsRUFBQztBQUNySyxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMscURBQW9ELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2xJLCtDQUE4QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN0SCxrREFBaUQsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDNUgsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDN0Msc0RBQXFELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQzFJLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQix3REFBdUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDdkksNkJBQTZCLG1CQUFPLENBQUMsb0dBQXdCO0FBQzdELHlEQUF3RCxFQUFFLHFDQUFxQyx3REFBd0QsRUFBQztBQUN4Six3Q0FBd0MsbUJBQU8sQ0FBQywwSEFBbUM7QUFDbkYsdUVBQXNFLEVBQUUscUNBQXFDLGlGQUFpRixFQUFDO0FBQy9MIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2V4cGVyaW1lbnRhbC5qcz81YTk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLnRyYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnaW5nXzEubG9nOyB9IH0pO1xudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyUmVzb2x2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcjsgfSB9KTtcbnZhciB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZzsgfSB9KTtcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xudmFyIGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpcnN0VXNhYmxlQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmF2YWlsYWJsZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMS5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    refresh() {\n        for (const filter of this.filters) {\n            filter.refresh();\n        }\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories) {\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    createFilter(callStream) {\n        return new FilterStack(this.factories.map((factory) => factory.createFilter(callStream)));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory;\n//# sourceMappingURL=filter-stack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci1zdGFjay5qcz8zZGY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuRmlsdGVyU3RhY2sgPSB2b2lkIDA7XG5jbGFzcyBGaWx0ZXJTdGFjayB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXRhZGF0YShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RhdHVzO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZVRyYWlsZXJzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBmaWx0ZXIucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1c2goZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMudW5zaGlmdCguLi5maWx0ZXJzKTtcbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycztcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrID0gRmlsdGVyU3RhY2s7XG5jbGFzcyBGaWx0ZXJTdGFja0ZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB9XG4gICAgcHVzaChmaWx0ZXJGYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMudW5zaGlmdCguLi5maWx0ZXJGYWN0b3JpZXMpO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrKHRoaXMuZmFjdG9yaWVzLm1hcCgoZmFjdG9yeSkgPT4gZmFjdG9yeS5jcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkpKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IEZpbHRlclN0YWNrRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci1zdGFjay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n    refresh() { }\n}\nexports.BaseFilter = BaseFilter;\n//# sourceMappingURL=filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanM/M2E3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZUZpbHRlciB7XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICByZWZyZXNoKCkgeyB9XG59XG5leHBvcnRzLkJhc2VGaWx0ZXIgPSBCYXNlRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http:') {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */\n    if (port === '') {\n        port = '80';\n    }\n    const result = {\n        address: `${hostname}:${port}`,\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {},\n    };\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === 'unix') {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()) {\n        if (host === serverHost) {\n            trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        'grpc.http_connect_target': uri_parser_1.uriToString(target),\n    };\n    if (proxyInfo.creds) {\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: 'dns',\n            path: proxyInfo.address,\n        },\n        extraOptions: extraOptions,\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    if (!('grpc.http_connect_target' in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions['grpc.http_connect_target'];\n    const parsedTarget = uri_parser_1.parseUri(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const options = {\n        method: 'CONNECT',\n        path: parsedTarget.path,\n    };\n    const headers = {\n        Host: parsedTarget.path,\n    };\n    // Connect to the subchannel address as a proxy\n    if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    }\n    else {\n        options.socketPath = address.path;\n    }\n    if ('grpc.http_connect_creds' in channelOptions) {\n        headers['Proxy-Authorization'] =\n            'Basic ' +\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n    }\n    options.headers = headers;\n    const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace('Successfully connected to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                if ('secureContext' in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n                    const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {\n                        trace('Successfully established a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString);\n                        resolve({ socket: cts, realTarget: parsedTarget });\n                    });\n                    cts.on('error', (error) => {\n                        trace('Failed to establish a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString +\n                            ' with error ' +\n                            error.message);\n                        reject();\n                    });\n                }\n                else {\n                    trace('Successfully established a plaintext connection to ' +\n                        options.path +\n                        ' through proxy ' +\n                        proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget,\n                    });\n                }\n            }\n            else {\n                logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with status ' +\n                    res.statusCode);\n                reject();\n            }\n        });\n        request.once('error', (err) => {\n            request.removeAllListeners();\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection;\n//# sourceMappingURL=http_proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLG9CQUFvQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0IsR0FBRyxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEdBQUcsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwREFBMEQ7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUNBQXVDO0FBQ3pFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2h0dHBfcHJveHkuanM/MDI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGV4cG9ydHMubWFwUHJveHlOYW1lID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgdGxzID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncHJveHknO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUluZm8oKSB7XG4gICAgbGV0IHByb3h5RW52ID0gJyc7XG4gICAgbGV0IGVudlZhciA9ICcnO1xuICAgIC8qIFByZWZlciB1c2luZyAnZ3JwY19wcm94eScuIEZhbGxiYWNrIG9uICdodHRwX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LlxuICAgICAqIEFsc28gcHJlZmVyIHVzaW5nICdodHRwc19wcm94eScgd2l0aCBmYWxsYmFjayBvbiAnaHR0cF9wcm94eScuIFRoZVxuICAgICAqIGZhbGxiYWNrIGJlaGF2aW9yIGNhbiBiZSByZW1vdmVkIGlmIHRoZXJlJ3MgYSBkZW1hbmQgZm9yIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5ncnBjX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdncnBjX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5ncnBjX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cHNfcHJveHknO1xuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdodHRwX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgcHJveHlVcmw7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJveHlVcmwgPSBuZXcgdXJsXzEuVVJMKHByb3h5RW52KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBjYW5ub3QgcGFyc2UgdmFsdWUgb2YgXCIke2VudlZhcn1cIiBlbnYgdmFyYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKHByb3h5VXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgXCIke3Byb3h5VXJsLnByb3RvY29sfVwiIHNjaGVtZSBub3Qgc3VwcG9ydGVkIGluIHByb3h5IFVSSWApO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxldCB1c2VyQ3JlZCA9IG51bGw7XG4gICAgaWYgKHByb3h5VXJsLnVzZXJuYW1lKSB7XG4gICAgICAgIGlmIChwcm94eVVybC5wYXNzd29yZCkge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgJ3VzZXJpbmZvIGZvdW5kIGluIHByb3h5IFVSSScpO1xuICAgICAgICAgICAgdXNlckNyZWQgPSBgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBQcm94eU5hbWUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5vUHJveHlSZXN1bHQgPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBleHRyYU9wdGlvbnM6IHt9LFxuICAgIH07XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zWydncnBjLmVuYWJsZV9odHRwX3Byb3h5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gJ3VuaXgnKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eUluZm8gPSBnZXRQcm94eUluZm8oKTtcbiAgICBpZiAoIXByb3h5SW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHRhcmdldC5wYXRoKTtcbiAgICBpZiAoIWhvc3RQb3J0KSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJIb3N0ID0gaG9zdFBvcnQuaG9zdDtcbiAgICBmb3IgKGNvbnN0IGhvc3Qgb2YgZ2V0Tm9Qcm94eUhvc3RMaXN0KCkpIHtcbiAgICAgICAgaWYgKGhvc3QgPT09IHNlcnZlckhvc3QpIHtcbiAgICAgICAgICAgIHRyYWNlKCdOb3QgdXNpbmcgcHJveHkgZm9yIHRhcmdldCBpbiBub19wcm94eSBsaXN0OiAnICsgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0cmFPcHRpb25zID0ge1xuICAgICAgICAnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JzogdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5leHBvcnRzLm1hcFByb3h5TmFtZSA9IG1hcFByb3h5TmFtZTtcbmZ1bmN0aW9uIGdldFByb3hpZWRDb25uZWN0aW9uKGFkZHJlc3MsIGNoYW5uZWxPcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGlmICghKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIGNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3QgcmVhbFRhcmdldCA9IGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXTtcbiAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSB1cmlfcGFyc2VyXzEucGFyc2VVcmkocmVhbFRhcmdldCk7XG4gICAgaWYgKHBhcnNlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnQ09OTkVDVCcsXG4gICAgICAgIHBhdGg6IHBhcnNlZFRhcmdldC5wYXRoLFxuICAgIH07XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgSG9zdDogcGFyc2VkVGFyZ2V0LnBhdGgsXG4gICAgfTtcbiAgICAvLyBDb25uZWN0IHRvIHRoZSBzdWJjaGFubmVsIGFkZHJlc3MgYXMgYSBwcm94eVxuICAgIGlmIChzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKTtcbiAgICB0cmFjZSgnVXNpbmcgcHJveHkgJyArIHByb3h5QWRkcmVzc1N0cmluZyArICcgdG8gY29ubmVjdCB0byAnICsgb3B0aW9ucy5wYXRoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Nvbm5lY3QnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGUgdGhpcyBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgICAgICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KHBhcnNlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUhvc3QgPSAoX2EgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3RzID0gdGxzLmNvbm5lY3QoT2JqZWN0LmFzc2lnbih7IGhvc3Q6IHJlbW90ZUhvc3QsIHNlcnZlcm5hbWU6IHJlbW90ZUhvc3QsIHNvY2tldDogc29ja2V0IH0sIGNvbm5lY3Rpb25PcHRpb25zKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc29ja2V0OiBjdHMsIHJlYWxUYXJnZXQ6IHBhcnNlZFRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGEgVExTIGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIGEgcGxhaW50ZXh0IGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgJyB3aXRoIHN0YXR1cyAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBnZXRQcm94aWVkQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBfcHJveHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.experimental = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({ enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } }));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({ enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } }));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({ enumerable: true, get: function () { return client_1.Client; } }));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));\nObject.defineProperty(exports, \"status\", ({ enumerable: true, get: function () { return constants_1.Status; } }));\nObject.defineProperty(exports, \"propagate\", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));\nObject.defineProperty(exports, \"makeClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));\nconst server_1 = __webpack_require__(/*! ./server */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));\n/**** Client Credentials ****/\n// Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */\n    combineChannelCredentials: (channelCredentials, ...callCredentials) => {\n        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */\n    combineCallCredentials: (first, ...additional) => {\n        return additional.reduce((acc, other) => acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty,\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */\nexports.closeClient = (client) => client.close();\nexports.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\n/* eslint-enable @typescript-eslint/no-explicit-any */\n/**** Unimplemented function stubs ****/\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexports.loadObject = (value, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.load = (filename, format, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.setLogger = (logger) => {\n    logging.setLogger(logger);\n};\nexports.setLogVerbosity = (verbosity) => {\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.getClientChannel = (client) => {\n    return client_1.Client.prototype.getChannel.call(client);\n};\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));\nObject.defineProperty(exports, \"RequesterBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));\nObject.defineProperty(exports, \"InterceptingCall\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({ enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } }));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({ enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({ enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } }));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\n(() => {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'index', 'Loading @grpc/grpc-js version ' + clientVersion);\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxvQ0FBb0MsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxjQUFjLEdBQUcsNkJBQTZCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQjtBQUMzbEIsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELG1EQUFrRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN4SSxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQywyQ0FBMEMsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDN0gsaUNBQWlDLG1CQUFPLENBQUMsd0dBQTBCO0FBQ25FLHlEQUF3RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUMxSiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLDhCQUE4QixtQkFBTyxDQUFDLGtHQUF1QjtBQUM3RCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLHlEQUF3RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMvSSx5REFBd0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDL0ksZ0VBQStELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3RKLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFEQUFvRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM5SSx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsaURBQWdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2xJO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLGtHQUF1QjtBQUMzRCxtREFBa0QsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDM0ksb0RBQW1ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzdJLG9EQUFtRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM3SSxpRUFBZ0UsRUFBRSxxQ0FBcUMsK0RBQStELEVBQUM7QUFDdkssaUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7QUFDckMsZ0VBQStELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQzFKLHVEQUFzRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUN4SSxjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0IsNERBQTJELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQy9JLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3QyxvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUMzQyxpQ0FBaUMsbUJBQU8sQ0FBQyw0R0FBNEI7QUFDckUsa0NBQWtDLG1CQUFPLENBQUMsOEdBQTZCO0FBQ3ZFLHdDQUF3QyxtQkFBTyxDQUFDLDBIQUFtQztBQUNuRixpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxzQkFBc0IsMEdBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbmRleC5qcz9lNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IGV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBleHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLmxvYWRPYmplY3QgPSBleHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IGV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSBleHBvcnRzLmNsb3NlQ2xpZW50ID0gZXhwb3J0cy5DaGFubmVsID0gZXhwb3J0cy5tYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ2xpZW50ID0gZXhwb3J0cy5jb21wcmVzc2lvbkFsZ29yaXRobXMgPSBleHBvcnRzLnByb3BhZ2F0ZSA9IGV4cG9ydHMuY29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLnN0YXR1cyA9IGV4cG9ydHMubG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5NZXRhZGF0YSA9IGV4cG9ydHMuY3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb247IH0gfSk7XG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHJlc3Npb25BbGdvcml0aG1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zOyB9IH0pO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25uZWN0aXZpdHlTdGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGU7IH0gfSk7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLkNsaWVudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nVmVyYm9zaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlN0YXR1czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3BhZ2F0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuUHJvcGFnYXRlOyB9IH0pO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkUGFja2FnZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUNsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWV0YWRhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ldGFkYXRhXzEuTWV0YWRhdGE7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3Qgc2VydmVyX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBzdGF0dXNfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vc3RhdHVzLWJ1aWxkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0dXNCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0dXNfYnVpbGRlcl8xLlN0YXR1c0J1aWxkZXI7IH0gfSk7XG4vKioqKiBDbGllbnQgQ3JlZGVudGlhbHMgKioqKi9cbi8vIFVzaW5nIGFzc2lnbiBvbmx5IGNvcGllcyBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuZXhwb3J0cy5jcmVkZW50aWFscyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGEgQ2hhbm5lbENyZWRlbnRpYWxzIHdpdGggYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhXG4gICAgICogc2luZ2xlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFscyBUaGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2FsbENyZWRlbnRpYWxzIEFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNoYW5uZWxDcmVkZW50aWFsczogKGNoYW5uZWxDcmVkZW50aWFscywgLi4uY2FsbENyZWRlbnRpYWxzKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsQ3JlZGVudGlhbHMucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGNoYW5uZWxDcmVkZW50aWFscyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIGludG8gYSBzaW5nbGUgQ2FsbENyZWRlbnRpYWxzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNhbGxDcmVkZW50aWFsczogKGZpcnN0LCAuLi5hZGRpdGlvbmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBmaXJzdCk7XG4gICAgfSxcbiAgICAvLyBmcm9tIGNoYW5uZWwtY3JlZGVudGlhbHMudHNcbiAgICBjcmVhdGVJbnNlY3VyZTogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSxcbiAgICBjcmVhdGVTc2w6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlU3NsLFxuICAgIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0OiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21TZWN1cmVDb250ZXh0LFxuICAgIC8vIGZyb20gY2FsbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcjogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IsXG4gICAgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWw6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwsXG4gICAgY3JlYXRlRW1wdHk6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHksXG59O1xuLyoqXG4gKiBDbG9zZSBhIENsaWVudCBvYmplY3QuXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBjbGllbnQgdG8gY2xvc2UuXG4gKi9cbmV4cG9ydHMuY2xvc2VDbGllbnQgPSAoY2xpZW50KSA9PiBjbGllbnQuY2xvc2UoKTtcbmV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gKGNsaWVudCwgZGVhZGxpbmUsIGNhbGxiYWNrKSA9PiBjbGllbnQud2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjayk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKioqIFVuaW1wbGVtZW50ZWQgZnVuY3Rpb24gc3R1YnMgKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmV4cG9ydHMubG9hZE9iamVjdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBpbiB0aGlzIGxpYnJhcnkuIFVzZSBAZ3JwYy9wcm90by1sb2FkZXIgYW5kIGxvYWRQYWNrYWdlRGVmaW5pdGlvbiBpbnN0ZWFkJyk7XG59O1xuZXhwb3J0cy5sb2FkID0gKGZpbGVuYW1lLCBmb3JtYXQsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyKGxvZ2dlcik7XG59O1xuZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXJWZXJib3NpdHkodmVyYm9zaXR5KTtcbn07XG5leHBvcnRzLmdldENsaWVudENoYW5uZWwgPSAoY2xpZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUuZ2V0Q2hhbm5lbC5jYWxsKGNsaWVudCk7XG59O1xudmFyIGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5MaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0ZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuUmVxdWVzdGVyQnVpbGRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdGluZ0NhbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRpbmdDYWxsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjsgfSB9KTtcbnZhciBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVsekhhbmRsZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6SGFuZGxlcnM7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZG1pbl8xLmFkZEFkbWluU2VydmljZXNUb1NlcnZlcjsgfSB9KTtcbmNvbnN0IGV4cGVyaW1lbnRhbCA9IHJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbFwiKTtcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwZXJpbWVudGFsO1xuY29uc3QgcmVzb2x2ZXJfZG5zID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgcmVzb2x2ZXJfdWRzID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItdWRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfaXAgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1pcFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdCA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XG5jb25zdCBjaGFubmVseiA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4oKCkgPT4ge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnaW5kZXgnLCAnTG9hZGluZyBAZ3JwYy9ncnBjLWpzIHZlcnNpb24gJyArIGNsaWVudFZlcnNpb24pO1xuICAgIHJlc29sdmVyX2Rucy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX3Vkcy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX2lwLnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0LnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2Jpbi5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24uc2V0dXAoKTtcbiAgICBjaGFubmVsei5zZXR1cCgpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = 'child_load_balancer_helper';\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent) {\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                }\n                else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */\n    updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null ||\n            this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            }\n            else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        }\n        else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            }\n            else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;\n//# sourceMappingURL=load-balancer-child-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzP2Y3MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgVFlQRV9OQU1FID0gJ2NoaWxkX2xvYWRfYmFsYW5jZXJfaGVscGVyJztcbmNsYXNzIENoaWxkTG9hZEJhbGFuY2VySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5DaGlsZFBvbGljeUhlbHBlciA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsZWRCeVBlbmRpbmdDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY3VycmVudENoaWxkID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jYWxsZWRCeUN1cnJlbnRDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RDaGlsZCA9IChfYSA9IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkID09PSBsYXRlc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2hpbGQobmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeVBlbmRpbmdDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGVkQnlDdXJyZW50Q2hpbGQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPT09IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcmVxdWlzaXRlczogbGJDb25maWcgIT09IG51bGwgYW5kIGxiQ29uZmlnLm5hbWUgaXMgcmVnaXN0ZXJlZFxuICAgICAqIEBwYXJhbSBhZGRyZXNzTGlzdFxuICAgICAqIEBwYXJhbSBsYkNvbmZpZ1xuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGxldCBjaGlsZFRvVXBkYXRlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLmdldFR5cGVOYW1lKCkgIT09IGxiQ29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3SGVscGVyID0gbmV3IHRoaXMuQ2hpbGRQb2xpY3lIZWxwZXIodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVMb2FkQmFsYW5jZXIobGJDb25maWcsIG5ld0hlbHBlcik7XG4gICAgICAgICAgICBuZXdIZWxwZXIuc2V0Q2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZFRvVXBkYXRlLnVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZywgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLnJlc2V0QmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!duration_1.isDuration(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, 'number', objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n        this.childPolicy = childPolicy;\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: duration_1.msToDuration(this.intervalMs),\n            base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n            max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, 'interval');\n        validatePositiveDuration(obj, 'base_ejection_time');\n        validatePositiveDuration(obj, 'max_ejection_time');\n        validatePercentage(obj, 'max_ejection_percent');\n        if ('success_rate_ejection' in obj) {\n            if (typeof obj.success_rate_ejection !== 'object') {\n                throw new Error('outlier detection config success_rate_ejection must be an object');\n            }\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n        }\n        if ('failure_percentage_ejection' in obj) {\n            if (typeof obj.failure_percentage_ejection !== 'object') {\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\n            }\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry) {\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners) {\n                    listener(this, previousState, newState);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        }\n        else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners) {\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners) {\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor() {\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n    constructor(callCounter) {\n        super();\n        this.callCounter = callCounter;\n    }\n    receiveTrailers(status) {\n        if (status.code === constants_1.Status.OK) {\n            this.callCounter.addSuccess();\n        }\n        else {\n            this.callCounter.addFailure();\n        }\n        return status;\n    }\n}\nclass OutlierDetectionCounterFilterFactory {\n    constructor(callCounter) {\n        this.callCounter = callCounter;\n    }\n    createFilter(callStream) {\n        return new OutlierDetectionCounterFilter(this.callCounter);\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls) {\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                const extraFilterFactories = [...wrappedPick.extraFilterFactories];\n                if (this.countCalls) {\n                    extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));\n                }\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), extraFilterFactories: extraFilterFactories });\n            }\n            else {\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\n            }\n        }\n        else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper) {\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker) => {\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                }\n                else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(() => { }, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null &&\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return (ejectionCount * 100) / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace('Running success rate check');\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const mapEntry of this.addressMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates) {\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Candidate successes=' + successes + ' failures=' + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = (failures * 100) / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()) {\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace('Ejection timer running');\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            }\n            else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace('Unejecting ' + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList) {\n            subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n        }\n        for (const address of subchannelAddresses) {\n            if (!this.addressMap.has(address)) {\n                trace('Adding map entry for ' + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()) {\n            if (!subchannelAddresses.has(key)) {\n                trace('Removing map entry for ' + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace('Previous timer existed. Replacing timer');\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - ((new Date()).getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            }\n            else {\n                trace('Starting new timer');\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        }\n        else {\n            trace('Counting disabled. Cancelling timer.');\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()) {\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-outlier-detection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQztBQUNsRyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCxzQ0FBc0MsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDN0UsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsR0FBRyxVQUFVO0FBQ3RFLG9EQUFvRCxlQUFlLHdCQUF3QixhQUFhLFFBQVEsc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEdBQUcsVUFBVTtBQUNsRTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsc0NBQXNDLHNCQUFzQjtBQUNuSTtBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxHQUFHLFVBQVU7QUFDbEU7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RixtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLGtHQUFrRztBQUN6SztBQUNBO0FBQ0EscURBQXFELGtCQUFrQixzREFBc0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb24uanM/M2E0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2R1cmF0aW9uXCIpO1xuY29uc3QgZXhwZXJpbWVudGFsXzEgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ291dGxpZXJfZGV0ZWN0aW9uJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgVFlQRV9OQU1FID0gJ291dGxpZXJfZGV0ZWN0aW9uJztcbmNvbnN0IE9VVExJRVJfREVURUNUSU9OX0VOQUJMRUQgPSAoKF9hID0gcHJvY2Vzcy5lbnYuR1JQQ19FWFBFUklNRU5UQUxfRU5BQkxFX09VVExJRVJfREVURUNUSU9OKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndHJ1ZScpID09PSAndHJ1ZSc7XG5jb25zdCBkZWZhdWx0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZyA9IHtcbiAgICBzdGRldl9mYWN0b3I6IDE5MDAsXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxuICAgIG1pbmltdW1faG9zdHM6IDUsXG4gICAgcmVxdWVzdF92b2x1bWU6IDEwMFxufTtcbmNvbnN0IGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHRocmVzaG9sZDogODUsXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxuICAgIG1pbmltdW1faG9zdHM6IDUsXG4gICAgcmVxdWVzdF92b2x1bWU6IDUwXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgb2JqZWN0TmFtZSkge1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmIHR5cGVvZiBvYmpbZmllbGROYW1lXSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgJHtleHBlY3RlZFR5cGV9LCBnb3QgJHt0eXBlb2Ygb2JqW2ZpZWxkTmFtZV19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgZmllbGROYW1lLCBvYmplY3ROYW1lKSB7XG4gICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGlmICghZHVyYXRpb25fMS5pc0R1cmF0aW9uKG9ialtmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmpbZmllbGROYW1lXS5zZWNvbmRzID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0uc2Vjb25kcyA8PSAzMTU1NzYwMDAwMDAgJiYgb2JqW2ZpZWxkTmFtZV0ubmFub3MgPj0gMCAmJiBvYmpbZmllbGROYW1lXS5uYW5vcyA8PSA5OTk5OTk5OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiAhKG9ialtmaWVsZE5hbWVdID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0gPD0gMTAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZSBvdXQgb2YgcmFuZ2UgZm9yIHBlcmNlbnRhZ2UgKDAtMTAwKWApO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbE1zLCBiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblBlcmNlbnQsIHN1Y2Nlc3NSYXRlRWplY3Rpb24sIGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KSB7XG4gICAgICAgIHRoaXMuY2hpbGRQb2xpY3kgPSBjaGlsZFBvbGljeTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbE1zID0gaW50ZXJ2YWxNcyAhPT0gbnVsbCAmJiBpbnRlcnZhbE1zICE9PSB2b2lkIDAgPyBpbnRlcnZhbE1zIDogMTAwMDA7XG4gICAgICAgIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zID0gYmFzZUVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIGJhc2VFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gYmFzZUVqZWN0aW9uVGltZU1zIDogMzAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25UaW1lTXMgPSBtYXhFamVjdGlvblRpbWVNcyAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25UaW1lTXMgOiAzMDAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25QZXJjZW50ID0gbWF4RWplY3Rpb25QZXJjZW50ICE9PSBudWxsICYmIG1heEVqZWN0aW9uUGVyY2VudCAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25QZXJjZW50IDogMTA7XG4gICAgICAgIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiA9IHN1Y2Nlc3NSYXRlRWplY3Rpb24gPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKSwgc3VjY2Vzc1JhdGVFamVjdGlvbikgOiBudWxsO1xuICAgICAgICB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24gPSBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZyksIGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKHRoaXMuaW50ZXJ2YWxNcyksXG4gICAgICAgICAgICBiYXNlX2VqZWN0aW9uX3RpbWU6IGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zKSxcbiAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbih0aGlzLm1heEVqZWN0aW9uVGltZU1zKSxcbiAgICAgICAgICAgIG1heF9lamVjdGlvbl9wZXJjZW50OiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCxcbiAgICAgICAgICAgIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbjogdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uLFxuICAgICAgICAgICAgZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uOiB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sXG4gICAgICAgICAgICBjaGlsZF9wb2xpY3k6IHRoaXMuY2hpbGRQb2xpY3kubWFwKHBvbGljeSA9PiBwb2xpY3kudG9Kc29uT2JqZWN0KCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEludGVydmFsTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsTXM7XG4gICAgfVxuICAgIGdldEJhc2VFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25UaW1lTXM7XG4gICAgfVxuICAgIGdldE1heEVqZWN0aW9uUGVyY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25QZXJjZW50O1xuICAgIH1cbiAgICBnZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRDaGlsZFBvbGljeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQb2xpY3k7XG4gICAgfVxuICAgIGNvcHlXaXRoQ2hpbGRQb2xpY3koY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyh0aGlzLmludGVydmFsTXMsIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCwgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uLCB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdpbnRlcnZhbCcpO1xuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnYmFzZV9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdtYXhfZWplY3Rpb25fdGltZScpO1xuICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCAnbWF4X2VqZWN0aW9uX3BlcmNlbnQnKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzX3JhdGVfZWplY3Rpb24nIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3N0ZGV2X2ZhY3RvcicsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAncmVxdWVzdF92b2x1bWUnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5pbnRlcnZhbCA/IGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKG9iai5pbnRlcnZhbCkgOiBudWxsLCBvYmouYmFzZV9lamVjdGlvbl90aW1lID8gZHVyYXRpb25fMS5kdXJhdGlvblRvTXMob2JqLmJhc2VfZWplY3Rpb25fdGltZSkgOiBudWxsLCBvYmoubWF4X2VqZWN0aW9uX3RpbWUgPyBkdXJhdGlvbl8xLmR1cmF0aW9uVG9NcyhvYmoubWF4X2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgKF9hID0gb2JqLm1heF9lamVjdGlvbl9wZXJjZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCBvYmouY2hpbGRfcG9saWN5Lm1hcChsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnO1xuY2xhc3MgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgbWFwRW50cnkpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcbiAgICAgICAgdGhpcy5tYXBFbnRyeSA9IG1hcEVudHJ5O1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkU3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICBjaGlsZFN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcigoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB3cmFwcGVyJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVySW5kZXggPSB0aGlzLnN0YXRlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdCgpIHtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5lamVjdCgpIHtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1hcEVudHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBFbnRyeTtcbiAgICB9XG4gICAgZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5QnVja2V0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IDAsXG4gICAgICAgIGZhaWx1cmU6IDBcbiAgICB9O1xufVxuY2xhc3MgQ2FsbENvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgICAgIHRoaXMuaW5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xuICAgIH1cbiAgICBhZGRTdWNjZXNzKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldC5zdWNjZXNzICs9IDE7XG4gICAgfVxuICAgIGFkZEZhaWx1cmUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LmZhaWx1cmUgKz0gMTtcbiAgICB9XG4gICAgc3dpdGNoQnVja2V0cygpIHtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IHRoaXMuYWN0aXZlQnVja2V0O1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGdldExhc3RTdWNjZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluYWN0aXZlQnVja2V0LnN1Y2Nlc3M7XG4gICAgfVxuICAgIGdldExhc3RGYWlsdXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuZmFpbHVyZTtcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uQ291bnRlckZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDb3VudGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FsbENvdW50ZXIgPSBjYWxsQ291bnRlcjtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5jYWxsQ291bnRlci5hZGRTdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxDb3VudGVyLmFkZEZhaWx1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Db3VudGVyRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2FsbENvdW50ZXIpIHtcbiAgICAgICAgdGhpcy5jYWxsQ291bnRlciA9IGNhbGxDb3VudGVyO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Db3VudGVyRmlsdGVyKHRoaXMuY2FsbENvdW50ZXIpO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWRQaWNrZXIsIGNvdW50Q2FsbHMpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkUGlja2VyID0gd3JhcHBlZFBpY2tlcjtcbiAgICAgICAgdGhpcy5jb3VudENhbGxzID0gY291bnRDYWxscztcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCB3cmFwcGVkUGljayA9IHRoaXMud3JhcHBlZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcbiAgICAgICAgaWYgKHdyYXBwZWRQaWNrLnBpY2tSZXN1bHRUeXBlID09PSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSB3cmFwcGVkUGljay5zdWJjaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSBzdWJjaGFubmVsV3JhcHBlci5nZXRNYXBFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFGaWx0ZXJGYWN0b3JpZXMgPSBbLi4ud3JhcHBlZFBpY2suZXh0cmFGaWx0ZXJGYWN0b3JpZXNdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFGaWx0ZXJGYWN0b3JpZXMucHVzaChuZXcgT3V0bGllckRldGVjdGlvbkNvdW50ZXJGaWx0ZXJGYWN0b3J5KG1hcEVudHJ5LmNvdW50ZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCksIGV4dHJhRmlsdGVyRmFjdG9yaWVzOiBleHRyYUZpbHRlckZhY3RvcmllcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRQaWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKGV4cGVyaW1lbnRhbF8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIoY2hhbm5lbENvbnRyb2xIZWxwZXIsIHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN1YmNoYW5uZWwgPSBjaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSB0aGlzLmFkZHJlc3NNYXAuZ2V0KHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoc3ViY2hhbm5lbEFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsV3JhcHBlciA9IG5ldyBPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIob3JpZ2luYWxTdWJjaGFubmVsLCBtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKChtYXBFbnRyeSA9PT0gbnVsbCB8fCBtYXBFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYWRkcmVzcyBpcyBlamVjdGVkLCBwcm9wYWdhdGUgdGhhdCB0byB0aGUgbmV3IHN1YmNoYW5uZWwgd3JhcHBlclxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci5lamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBFbnRyeSA9PT0gbnVsbCB8fCBtYXBFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzLnB1c2goc3ViY2hhbm5lbFdyYXBwZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJjaGFubmVsV3JhcHBlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBuZXcgT3V0bGllckRldGVjdGlvblBpY2tlcihwaWNrZXIsIHRoaXMuaXNDb3VudGluZ0VuYWJsZWQoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZWplY3Rpb25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICB9XG4gICAgaXNDb3VudGluZ0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSB7XG4gICAgICAgIGxldCBlamVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlamVjdGlvbkNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlamVjdGlvbkNvdW50ICogMTAwKSAvIHRoaXMuYWRkcmVzc01hcC5zaXplO1xuICAgIH1cbiAgICBydW5TdWNjZXNzUmF0ZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFzdWNjZXNzUmF0ZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIHN1Y2Nlc3MgcmF0ZSBjaGVjaycpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVxdWVzdFZvbHVtZSA9IHN1Y2Nlc3NSYXRlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lO1xuICAgICAgICBsZXQgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lID0gMDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA+PSB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lICs9IDE7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc1JhdGVzLnB1c2goc3VjY2Vzc2VzIC8gKHN1Y2Nlc3NlcyArIGZhaWx1cmVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ0ZvdW5kICcgKyBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKyAnIHN1Y2Nlc3MgcmF0ZSBjYW5kaWRhdGVzOyBjdXJyZW50RWplY3Rpb25QZXJjZW50PScgKyB0aGlzLmdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSArICcgc3VjY2Vzc1JhdGVzPVsnICsgc3VjY2Vzc1JhdGVzICsgJ10nKTtcbiAgICAgICAgaWYgKGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA8IHN1Y2Nlc3NSYXRlQ29uZmlnLm1pbmltdW1faG9zdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVNZWFuID0gc3VjY2Vzc1JhdGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gc3VjY2Vzc1JhdGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IHN1Y2Nlc3NSYXRlRGV2aWF0aW9uU3VtID0gMDtcbiAgICAgICAgZm9yIChjb25zdCByYXRlIG9mIHN1Y2Nlc3NSYXRlcykge1xuICAgICAgICAgICAgY29uc3QgZGV2aWF0aW9uID0gcmF0ZSAtIHN1Y2Nlc3NSYXRlTWVhbjtcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlRGV2aWF0aW9uU3VtICs9IGRldmlhdGlvbiAqIGRldmlhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZVZhcmlhbmNlID0gc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZVN0ZGV2ID0gTWF0aC5zcXJ0KHN1Y2Nlc3NSYXRlVmFyaWFuY2UpO1xuICAgICAgICBjb25zdCBlamVjdGlvblRocmVzaG9sZCA9IHN1Y2Nlc3NSYXRlTWVhbiAtIHN1Y2Nlc3NSYXRlU3RkZXYgKiAoc3VjY2Vzc1JhdGVDb25maWcuc3RkZXZfZmFjdG9yIC8gMTAwMCk7XG4gICAgICAgIHRyYWNlKCdzdGRldj0nICsgc3VjY2Vzc1JhdGVTdGRldiArICcgZWplY3Rpb25UaHJlc2hvbGQ9JyArIGVqZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uUGVyY2VudCgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAzLmlpaVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGUgPSBzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgdHJhY2UoJ0NoZWNraW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyArICcgc3VjY2Vzc1JhdGU9JyArIHN1Y2Nlc3NSYXRlKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzUmF0ZSA8IGVqZWN0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyByYW5kb21OdW1iZXI9JyArIHJhbmRvbU51bWJlciArICcgZW5mb3JjZW1lbnRfcGVyY2VudGFnZT0nICsgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmRvbU51bWJlciA8IHN1Y2Nlc3NSYXRlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ0VqZWN0aW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWplY3QobWFwRW50cnksIGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBmYWlsdXJlIHBlcmNlbnRhZ2UgY2hlY2suIHRocmVzaG9sZD0nICsgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcudGhyZXNob2xkICsgJyByZXF1ZXN0IHZvbHVtZSB0aHJlc2hvbGQ9JyArIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGxldCBhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgLy8gU3RlcCAyLmlcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSA+PSB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblBlcmNlbnQoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgc3VjY2Vzc2VzPScgKyBzdWNjZXNzZXMgKyAnIGZhaWx1cmVzPScgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpaVxuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVBlcmNlbnRhZ2UgPSAoZmFpbHVyZXMgKiAxMDApIC8gKGZhaWx1cmVzICsgc3VjY2Vzc2VzKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlUGVyY2VudGFnZSA+IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICsgYWRkcmVzcyArICcgcmFuZG9tTnVtYmVyPScgKyByYW5kb21OdW1iZXIgKyAnIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U9JyArIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdFamVjdGluZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyICs9IDE7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci5lamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QobWFwRW50cnkpIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsV3JhcHBlciBvZiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLnVuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2hBbGxCdWNrZXRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbWFwRW50cnkuY291bnRlci5zd2l0Y2hCdWNrZXRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRUaW1lcihkZWxheU1zKSB7XG4gICAgICAgIHRoaXMuZWplY3Rpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ydW5DaGVja3MoKSwgZGVsYXlNcyk7XG4gICAgfVxuICAgIHJ1bkNoZWNrcygpIHtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0cmFjZSgnRWplY3Rpb24gdGltZXIgcnVubmluZycpO1xuICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVyKHRoaXMubGF0ZXN0Q29uZmlnLmdldEludGVydmFsTXMoKSk7XG4gICAgICAgIHRoaXMucnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlRWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRCYXNlRWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uVGltZU1zKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVGltZSA9IG5ldyBEYXRlKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIHJldHVyblRpbWUuc2V0TWlsbGlzZWNvbmRzKHJldHVyblRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyBNYXRoLm1pbihiYXNlRWplY3Rpb25UaW1lTXMgKiBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyLCBNYXRoLm1heChiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UaW1lIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnVW5lamVjdGluZyAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZywgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxBZGRyZXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3Nlcy5hZGQoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIHN1YmNoYW5uZWxBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGRyZXNzTWFwLmhhcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdBZGRpbmcgbWFwIGVudHJ5IGZvciAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRyZXNzTWFwLnNldChhZGRyZXNzLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXI6IG5ldyBDYWxsQ291bnRlcigpLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWplY3Rpb25UaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVqZWN0aW9uVGltZU11bHRpcGxpZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmFkZHJlc3NNYXAua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoIXN1YmNoYW5uZWxBZGRyZXNzZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVtb3ZpbmcgbWFwIGVudHJ5IGZvciAnICsga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQb2xpY3kgPSBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWcobGJDb25maWcuZ2V0Q2hpbGRQb2xpY3koKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci51cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgY2hpbGRQb2xpY3ksIGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAobGJDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpIHx8IGxiQ29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUHJldmlvdXMgdGltZXIgZXhpc3RlZC4gUmVwbGFjaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXkgPSBsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkgLSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMudGltZXJTdGFydFRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIocmVtYWluaW5nRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N0YXJ0aW5nIG5ldyB0aW1lcicpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcihsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoQWxsQnVja2V0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2UoJ0NvdW50aW5nIGRpc2FibGVkLiBDYW5jZWxsaW5nIHRpbWVyLicpO1xuICAgICAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmVqZWN0KG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IGxiQ29uZmlnO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGlmIChPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEKSB7XG4gICAgICAgIGV4cGVyaW1lbnRhbF8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZShUWVBFX05BTUUsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new PickFirstLoadBalancingConfig();\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null,\n        };\n    }\n}\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of backend addresses most recently passed to `updateAddressList`.\n         */\n        this.latestAddressList = [];\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */\n        this.subchannels = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */\n        this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */\n        this.currentPick = null;\n        this.triedAllSubchannels = false;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState) => {\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            /* If the subchannel we most recently attempted to start connecting\n             * to goes into TRANSIENT_FAILURE, immediately try to start\n             * connecting to the next one instead of waiting for the connection\n             * delay timer. */\n            if (subchannel === this.subchannels[this.currentSubchannelIndex] &&\n                newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.startNextSubchannelConnecting();\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n            else {\n                if (this.triedAllSubchannels &&\n                    this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] ===\n                        this.subchannels.length) {\n                    /* If all of the subchannels are IDLE we should go back to a\n                     * basic IDLE state where there is no subchannel list to avoid\n                     * holding unused resources. We do not reset triedAllSubchannels\n                     * because that is a reminder to request reresolution the next time\n                     * this LB policy needs to connect. */\n                    this.resetSubchannelList(false);\n                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                    return;\n                }\n                if (this.currentPick === null) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        }\n                        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] >\n                            0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        }\n                        else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState !== this.currentState) {\n                            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                                this.updateState(newLBState, new picker_1.UnavailablePicker());\n                            }\n                            else {\n                                this.updateState(newLBState, new picker_1.QueuePicker(this));\n                            }\n                        }\n                    }\n                    else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n            }\n        };\n        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.currentPick = null;\n                subchannel.unref();\n                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n                this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n                if (this.subchannels.length > 0) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        }\n                        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] >\n                            0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        }\n                        else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                            this.updateState(newLBState, new picker_1.UnavailablePicker());\n                        }\n                        else {\n                            this.updateState(newLBState, new picker_1.QueuePicker(this));\n                        }\n                    }\n                    else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n                else {\n                    /* We don't need to backoff here because this only happens if a\n                     * subchannel successfully connects then disconnects, so it will not\n                     * create a loop of attempting to connect to an unreachable backend\n                     */\n                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                }\n            }\n        };\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    startNextSubchannelConnecting() {\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, subchannel] of this.subchannels.entries()) {\n            if (index > this.currentSubchannelIndex) {\n                const subchannelState = subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n    startConnecting(subchannelIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.subchannels[subchannelIndex].getConnectivityState() ===\n            connectivity_state_1.ConnectivityState.IDLE) {\n            trace('Start connecting to subchannel with address ' +\n                this.subchannels[subchannelIndex].getAddress());\n            process.nextTick(() => {\n                this.subchannels[subchannelIndex].startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(() => {\n            this.startNextSubchannelConnecting();\n        }, CONNECTION_DELAY_INTERVAL_MS);\n    }\n    pickSubchannel(subchannel) {\n        trace('Pick subchannel with address ' + subchannel.getAddress());\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList(resetTriedAllSubchannels = true) {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannels = [];\n        if (resetTriedAllSubchannels) {\n            this.triedAllSubchannels = false;\n        }\n    }\n    /**\n     * Start connecting to the address list most recently passed to\n     * `updateAddressList`.\n     */\n    connectToAddressList() {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            this.latestAddressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        for (const subchannel of this.subchannels) {\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                this.resetSubchannelList();\n                return;\n            }\n        }\n        for (const [index, subchannel] of this.subchannels.entries()) {\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                this.startConnecting(index);\n                if (this.currentPick === null) {\n                    this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                }\n                return;\n            }\n        }\n        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n        if (this.currentPick === null) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        // lbConfig has no useful information for pick first load balancing\n        /* To avoid unnecessary churn, we only do something with this address list\n         * if we're not currently trying to establish a connection, or if the new\n         * address list is different from the existing one */\n        if (this.subchannels.length === 0 ||\n            !this.latestAddressList.every((value, index) => addressList[index] === value)) {\n            this.latestAddressList = addressList;\n            this.connectToAddressList();\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\n            this.triedAllSubchannels) {\n            this.channelControlHelper.requestReresolution();\n        }\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            if (this.latestAddressList.length > 0) {\n                this.connectToAddressList();\n            }\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */\n            const currentPick = this.currentPick;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-pick-first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLDZCQUE2QixHQUFHLG9DQUFvQztBQUNwRix3QkFBd0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzPzkxYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNlciA9IGV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncGlja19maXJzdCc7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdwaWNrX2ZpcnN0Jztcbi8qKlxuICogRGVsYXkgYWZ0ZXIgc3RhcnRpbmcgYSBjb25uZWN0aW9uIG9uIGEgc3ViY2hhbm5lbCBiZWZvcmUgc3RhcnRpbmcgYVxuICogY29ubmVjdGlvbiBvbiB0aGUgbmV4dCBzdWJjaGFubmVsIGluIHRoZSBsaXN0LCBmb3IgSGFwcHkgRXllYmFsbHMgYWxnb3JpdGhtLlxuICovXG5jb25zdCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TID0gMjUwO1xuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcoKTtcbiAgICB9XG59XG5leHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnO1xuLyoqXG4gKiBQaWNrZXIgZm9yIGEgYFBpY2tGaXJzdExvYWRCYWxhbmNlcmAgaW4gdGhlIFJFQURZIHN0YXRlLiBBbHdheXMgcmV0dXJucyB0aGVcbiAqIHBpY2tlZCBzdWJjaGFubmVsLlxuICovXG5jbGFzcyBQaWNrRmlyc3RQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsID0gc3ViY2hhbm5lbDtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogdGhpcy5zdWJjaGFubmVsLFxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgZXh0cmFGaWx0ZXJGYWN0b3JpZXM6IFtdLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jZXIge1xuICAgIC8qKlxuICAgICAqIExvYWQgYmFsYW5jZXIgdGhhdCBhdHRlbXB0cyB0byBjb25uZWN0IHRvIGVhY2ggYmFja2VuZCBpbiB0aGUgYWRkcmVzcyBsaXN0XG4gICAgICogaW4gb3JkZXIsIGFuZCBwaWNrcyB0aGUgZmlyc3Qgb25lIHRoYXQgY29ubmVjdHMsIHVzaW5nIGl0IGZvciBldmVyeVxuICAgICAqIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgYmFja2VuZCBhZGRyZXNzZXMgbW9zdCByZWNlbnRseSBwYXNzZWQgdG8gYHVwZGF0ZUFkZHJlc3NMaXN0YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHN1YmNoYW5uZWxzIHRoaXMgbG9hZCBiYWxhbmNlciBpcyBjdXJyZW50bHkgYXR0ZW1wdGluZyB0b1xuICAgICAgICAgKiBjb25uZWN0IHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlIG9mIHRoZSBsb2FkIGJhbGFuY2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IHdpdGhpbiB0aGUgYHN1YmNoYW5uZWxzYCBhcnJheSBvZiB0aGUgc3ViY2hhbm5lbCB3aXRoIHRoZSBtb3N0XG4gICAgICAgICAqIHJlY2VudGx5IHN0YXJ0ZWQgY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgcGlja2VkIHN1YmNoYW5uZWwgdXNlZCBmb3IgbWFraW5nIGNhbGxzLiBQb3B1bGF0ZWQgaWZcbiAgICAgICAgICogYW5kIG9ubHkgaWYgdGhlIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IHN0YXRlIGlzIFJFQURZLiBJbiB0aGF0IGNhc2UsXG4gICAgICAgICAqIHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBzdGF0ZSBpcyBhbHNvIFJFQURZLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50cyA9IHtcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV05dOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbcHJldmlvdXNTdGF0ZV0gLT0gMTtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW25ld1N0YXRlXSArPSAxO1xuICAgICAgICAgICAgLyogSWYgdGhlIHN1YmNoYW5uZWwgd2UgbW9zdCByZWNlbnRseSBhdHRlbXB0ZWQgdG8gc3RhcnQgY29ubmVjdGluZ1xuICAgICAgICAgICAgICogdG8gZ29lcyBpbnRvIFRSQU5TSUVOVF9GQUlMVVJFLCBpbW1lZGlhdGVseSB0cnkgdG8gc3RhcnRcbiAgICAgICAgICAgICAqIGNvbm5lY3RpbmcgdG8gdGhlIG5leHQgb25lIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAqIGRlbGF5IHRpbWVyLiAqL1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwgPT09IHRoaXMuc3ViY2hhbm5lbHNbdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4XSAmJlxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tTdWJjaGFubmVsKHN1YmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBhbGwgb2YgdGhlIHN1YmNoYW5uZWxzIGFyZSBJRExFIHdlIHNob3VsZCBnbyBiYWNrIHRvIGFcbiAgICAgICAgICAgICAgICAgICAgICogYmFzaWMgSURMRSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBzdWJjaGFubmVsIGxpc3QgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICogaG9sZGluZyB1bnVzZWQgcmVzb3VyY2VzLiBXZSBkbyBub3QgcmVzZXQgdHJpZWRBbGxTdWJjaGFubmVsc1xuICAgICAgICAgICAgICAgICAgICAgKiBiZWNhdXNlIHRoYXQgaXMgYSByZW1pbmRlciB0byByZXF1ZXN0IHJlcmVzb2x1dGlvbiB0aGUgbmV4dCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgTEIgcG9saWN5IG5lZWRzIHRvIGNvbm5lY3QuICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TEJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMQlN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xCU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xCU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xCU3RhdGUgIT09IHRoaXMuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xCU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUobmV3TEJTdGF0ZSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdMQlN0YXRlLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waWNrZWRTdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwudW5yZWYoKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5waWNrZWRTdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TEJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMQlN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xCU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xCU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xCU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdMQlN0YXRlLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld0xCU3RhdGUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFdlIGRvbid0IG5lZWQgdG8gYmFja29mZiBoZXJlIGJlY2F1c2UgdGhpcyBvbmx5IGhhcHBlbnMgaWYgYVxuICAgICAgICAgICAgICAgICAgICAgKiBzdWJjaGFubmVsIHN1Y2Nlc3NmdWxseSBjb25uZWN0cyB0aGVuIGRpc2Nvbm5lY3RzLCBzbyBpdCB3aWxsIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBjcmVhdGUgYSBsb29wIG9mIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byBhbiB1bnJlYWNoYWJsZSBiYWNrZW5kXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgIH1cbiAgICBzdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHJpZWRBbGxTdWJjaGFubmVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBzdWJjaGFubmVsXSBvZiB0aGlzLnN1YmNoYW5uZWxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0YXRlID0gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXZlIGEgc2luZ2xlIHN1YmNoYW5uZWwgaW4gdGhlIGBzdWJjaGFubmVsc2AgbGlzdCBzdGFydCBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsSW5kZXggVGhlIGluZGV4IGludG8gdGhlIGBzdWJjaGFubmVsc2AgbGlzdC5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3Rpbmcoc3ViY2hhbm5lbEluZGV4KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSBzdWJjaGFubmVsSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLnN1YmNoYW5uZWxzW3N1YmNoYW5uZWxJbmRleF0uZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRyYWNlKCdTdGFydCBjb25uZWN0aW5nIHRvIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbHNbc3ViY2hhbm5lbEluZGV4XS5nZXRBZGRyZXNzKCkpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsc1tzdWJjaGFubmVsSW5kZXhdLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKCk7XG4gICAgICAgIH0sIENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMpO1xuICAgIH1cbiAgICBwaWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XG4gICAgICAgIHRyYWNlKCdQaWNrIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgKyBzdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5waWNrZWRTdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IHN1YmNoYW5uZWw7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBQaWNrRmlyc3RQaWNrZXIoc3ViY2hhbm5lbCkpO1xuICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5waWNrZWRTdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KHJlc2V0VHJpZWRBbGxTdWJjaGFubmVscyA9IHRydWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwudW5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzID0ge1xuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEVdOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTl06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gW107XG4gICAgICAgIGlmIChyZXNldFRyaWVkQWxsU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGNvbm5lY3RpbmcgdG8gdGhlIGFkZHJlc3MgbGlzdCBtb3N0IHJlY2VudGx5IHBhc3NlZCB0b1xuICAgICAqIGB1cGRhdGVBZGRyZXNzTGlzdGAuXG4gICAgICovXG4gICAgY29ubmVjdFRvQWRkcmVzc0xpc3QoKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICB0cmFjZSgnQ29ubmVjdCB0byBhZGRyZXNzIGxpc3QgJyArXG4gICAgICAgICAgICB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0Lm1hcCgoYWRkcmVzcykgPT4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gdGhpcy5sYXRlc3RBZGRyZXNzTGlzdC5tYXAoKGFkZHJlc3MpID0+IHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChhZGRyZXNzLCB7fSkpO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCldICs9IDE7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBzdWJjaGFubmVsXSBvZiB0aGlzLnN1YmNoYW5uZWxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0YXRlID0gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29kZSByZWFjaGVzIHRoaXMgcG9pbnQsIGV2ZXJ5IHN1YmNoYW5uZWwgbXVzdCBiZSBpbiBUUkFOU0lFTlRfRkFJTFVSRVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xuICAgICAgICAvLyBsYkNvbmZpZyBoYXMgbm8gdXNlZnVsIGluZm9ybWF0aW9uIGZvciBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jaW5nXG4gICAgICAgIC8qIFRvIGF2b2lkIHVubmVjZXNzYXJ5IGNodXJuLCB3ZSBvbmx5IGRvIHNvbWV0aGluZyB3aXRoIHRoaXMgYWRkcmVzcyBsaXN0XG4gICAgICAgICAqIGlmIHdlJ3JlIG5vdCBjdXJyZW50bHkgdHJ5aW5nIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBuZXdcbiAgICAgICAgICogYWRkcmVzcyBsaXN0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBleGlzdGluZyBvbmUgKi9cbiAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbHMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAhdGhpcy5sYXRlc3RBZGRyZXNzTGlzdC5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiBhZGRyZXNzTGlzdFtpbmRleF0gPT09IHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IGFkZHJlc3NMaXN0O1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscykge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RBZGRyZXNzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgLyogVGhlIHBpY2sgZmlyc3QgbG9hZCBiYWxhbmNlciBkb2VzIG5vdCBoYXZlIGEgY29ubmVjdGlvbiBiYWNrb2ZmLCBzbyB0aGlzXG4gICAgICAgICAqIGRvZXMgbm90aGluZyAqL1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIFVucmVmIGNhbiBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgd2hpY2ggY2FuIGNhdXNlIGEgY2hhbmdlIGluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICogb2YgdGhpcy5jdXJyZW50UGljaywgc28gd2UgaG9sZCBhIGxvY2FsIHJlZmVyZW5jZSB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgICAgICAgICogZG9lcyBub3QgaW1wYWN0IHRoaXMgZnVuY3Rpb24uICovXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGljayA9IHRoaXMuY3VycmVudFBpY2s7XG4gICAgICAgICAgICBjdXJyZW50UGljay51bnJlZigpO1xuICAgICAgICAgICAgY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnBpY2tlZFN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNlciA9IFBpY2tGaXJzdExvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUoVFlQRV9OQU1FLCBQaWNrRmlyc3RMb2FkQmFsYW5jZXIsIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKFRZUEVfTkFNRSk7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0) {\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null,\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n    peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState) => {\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||\n                newState === connectivity_state_1.ConnectivityState.IDLE) {\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    calculateAndUpdateState() {\n        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n            const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        }\n        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n        else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        }\n        else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,\n        };\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            addressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            this.subchannelStateCounts[subchannelState] += 1;\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyw4QkFBOEI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcz81MjRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5Sb3VuZFJvYmluTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgfVxufVxuY2xhc3MgUm91bmRSb2JpblBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbExpc3QsIG5leHRJbmRleCA9IDApIHtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsTGlzdCA9IHN1YmNoYW5uZWxMaXN0O1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCBwaWNrZWRTdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsTGlzdFt0aGlzLm5leHRJbmRleF07XG4gICAgICAgIHRoaXMubmV4dEluZGV4ID0gKHRoaXMubmV4dEluZGV4ICsgMSkgJSB0aGlzLnN1YmNoYW5uZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHBpY2tlZFN1YmNoYW5uZWwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBleHRyYUZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxuICAgICAqIHBvc3NpYmxlIHdoZW4gYSBzdWJjaGFubmVsIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzLlxuICAgICAqL1xuICAgIHBlZWtOZXh0U3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHMgPSB7XG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR106IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV06IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW3ByZXZpb3VzU3RhdGVdIC09IDE7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tuZXdTdGF0ZV0gKz0gMTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUgfHxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZHlTdWJjaGFubmVscyA9IHRoaXMuc3ViY2hhbm5lbHMuZmlsdGVyKChzdWJjaGFubmVsKSA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlYWR5U3ViY2hhbm5lbHMuaW5kZXhPZih0aGlzLmN1cnJlbnRSZWFkeVBpY2tlci5wZWVrTmV4dFN1YmNoYW5uZWwoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFJvdW5kUm9iaW5QaWNrZXIocmVhZHlTdWJjaGFubmVscywgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcikge1xuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gcGlja2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50cyA9IHtcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV05dOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcCgoYWRkcmVzcykgPT4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gYWRkcmVzc0xpc3QubWFwKChhZGRyZXNzKSA9PiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pKTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW3N1YmNoYW5uZWxTdGF0ZV0gKz0gMTtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */\nfunction createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType,\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    }\n    else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs) {\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === 'object')) {\n        throw new Error('Load balancing config must be an object');\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error('Provided load balancing config has multiple conflicting entries');\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    }\n    else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig;\n//# sourceMappingURL=load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxHQUFHLDRCQUE0QixHQUFHLG9DQUFvQyxHQUFHLDBCQUEwQixHQUFHLHVDQUF1QyxHQUFHLGdDQUFnQyxHQUFHLHVDQUF1QztBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcz9jMzdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IGV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBleHBvcnRzLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQgPSBleHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlID0gZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gdm9pZCAwO1xuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBDaGFubmVsQ29udHJvbEhlbHBlciB0aGF0IG92ZXJyaWRlcyBzb21lIG1ldGhvZHMgb2YgdGhlXG4gKiBwYXJlbnQgd2hpbGUgbGV0dGluZyBvdGhlcnMgcGFzcyB0aHJvdWdoIHRvIHRoZSBwYXJlbnQgdW5tb2RpZmllZC4gVGhpc1xuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XG4gKiBhbGwgb2YgdGhlIG1ldGhvZHMgdG8gYmUgcGFzc2VkIHRocm91Z2guXG4gKiBAcGFyYW0gcGFyZW50XG4gKiBAcGFyYW0gb3ZlcnJpZGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKF9iID0gKF9hID0gb3ZlcnJpZGVzLmNyZWF0ZVN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBhcmVudC5jcmVhdGVTdWJjaGFubmVsLmJpbmQocGFyZW50KSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKF9mID0gKF9lID0gb3ZlcnJpZGVzLnJlcXVlc3RSZXJlc29sdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHBhcmVudC5yZXF1ZXN0UmVyZXNvbHV0aW9uLmJpbmQocGFyZW50KSxcbiAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogKF9oID0gKF9nID0gb3ZlcnJpZGVzLmFkZENoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHBhcmVudC5hZGRDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KVxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyO1xuY29uc3QgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzID0ge307XG5sZXQgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBudWxsO1xuZnVuY3Rpb24gcmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lLCBsb2FkQmFsYW5jZXJUeXBlLCBsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSkge1xuICAgIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgIExvYWRCYWxhbmNlcjogbG9hZEJhbGFuY2VyVHlwZSxcbiAgICAgICAgTG9hZEJhbGFuY2luZ0NvbmZpZzogbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlID0gcmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlO1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSkge1xuICAgIGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gdHlwZU5hbWU7XG59XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSByZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlO1xuZnVuY3Rpb24gY3JlYXRlTG9hZEJhbGFuY2VyKGNvbmZpZywgY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2VyKGNoYW5uZWxDb250cm9sSGVscGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTG9hZEJhbGFuY2VyID0gY3JlYXRlTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCh0eXBlTmFtZSkge1xuICAgIHJldHVybiB0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXM7XG59XG5leHBvcnRzLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQgPSBpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkO1xuZnVuY3Rpb24gZ2V0Rmlyc3RVc2FibGVDb25maWcoY29uZmlncywgZmFsbGJhY2tUb2RlZmF1bHQgPSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFja1RvZGVmYXVsdCkge1xuICAgICAgICBpZiAoZGVmYXVsdExvYWRCYWxhbmNlclR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW2RlZmF1bHRMb2FkQmFsYW5jZXJUeXBlXS5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGaXJzdFVzYWJsZUNvbmZpZyA9IGdldEZpcnN0VXNhYmxlQ29uZmlnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyhvYmopIHtcbiAgICBpZiAoIShvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZCBiYWxhbmNpbmcgY29uZmlnIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBoYXMgbXVsdGlwbGUgY29uZmxpY3RpbmcgZW50cmllcycpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IGtleXNbMF07XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jaW5nQ29uZmlnLmNyZWF0ZUZyb21Kc29uKG9ialt0eXBlTmFtZV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbG9hZCBiYWxhbmNpbmcgY29uZmlnIG5hbWUgJHt0eXBlTmFtZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams) => {\n        console.error('E ' + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams) => {\n        console.error('I ' + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams) => {\n        console.error('D ' + message, ...optionalParams);\n    },\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';\nswitch (verbosityString.toUpperCase()) {\n    case 'DEBUG':\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case 'INFO':\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case 'ERROR':\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case 'NONE':\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n    // Ignore any other values\n}\nexports.getLogger = () => {\n    return _logger;\n};\nexports.setLogger = (logger) => {\n    _logger = logger;\n};\nexports.setLoggerVerbosity = (verbosity) => {\n    _logVerbosity = verbosity;\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexports.log = (severity, ...args) => {\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch (severity) {\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */\n        if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(',')) {\n    if (tracerName.startsWith('-')) {\n        disabledTracers.add(tracerName.substring(1));\n    }\n    else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has('all');\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        exports.log(severity, new Date().toISOString() + ' | ' + tracer + ' | ' + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return !disabledTracers.has(tracer) &&\n        (allEnabled || enabledTracers.has(tracer));\n}\nexports.isTracerEnabled = isTracerEnabled;\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDMUgsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcz9kNzYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX2EsIF9iLCBfYywgX2Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVHJhY2VyRW5hYmxlZCA9IGV4cG9ydHMudHJhY2UgPSBleHBvcnRzLmxvZyA9IGV4cG9ydHMuc2V0TG9nZ2VyVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmdldExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgREVGQVVMVF9MT0dHRVIgPSB7XG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbn07XG5sZXQgX2xvZ2dlciA9IERFRkFVTFRfTE9HR0VSO1xubGV0IF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG5jb25zdCB2ZXJib3NpdHlTdHJpbmcgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9jZXNzLmVudi5HUlBDX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG5zd2l0Y2ggKHZlcmJvc2l0eVN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnREVCVUcnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdJTkZPJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdFUlJPUic6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05PTkUnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5Lk5PTkU7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgLy8gSWdub3JlIGFueSBvdGhlciB2YWx1ZXNcbn1cbmV4cG9ydHMuZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICAgIHJldHVybiBfbG9nZ2VyO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIF9sb2dnZXIgPSBsb2dnZXI7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgX2xvZ1ZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0cy5sb2cgPSAoc2V2ZXJpdHksIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgbG9nRnVuY3Rpb247XG4gICAgaWYgKHNldmVyaXR5ID49IF9sb2dWZXJib3NpdHkpIHtcbiAgICAgICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc6XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmRlYnVnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTzpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuaW5mbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBGYWxsIGJhY2sgdG8gX2xvZ2dlci5lcnJvciB3aGVuIG90aGVyIG1ldGhvZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yXG4gICAgICAgICAqIGNvbXBhdGlibGl0eSB3aXRoIG9sZGVyIGJlaGF2aW9yIHRoYXQgYWx3YXlzIGxvZ2dlZCB0byBfbG9nZ2VyLmVycm9yICovXG4gICAgICAgIGlmICghbG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uLmJpbmQoX2xvZ2dlcikoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdHJhY2Vyc1N0cmluZyA9IChfZCA9IChfYyA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9UUkFDRSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcHJvY2Vzcy5lbnYuR1JQQ19UUkFDRSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyc7XG5jb25zdCBlbmFibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmNvbnN0IGRpc2FibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmZvciAoY29uc3QgdHJhY2VyTmFtZSBvZiB0cmFjZXJzU3RyaW5nLnNwbGl0KCcsJykpIHtcbiAgICBpZiAodHJhY2VyTmFtZS5zdGFydHNXaXRoKCctJykpIHtcbiAgICAgICAgZGlzYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbmFibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZSk7XG4gICAgfVxufVxuY29uc3QgYWxsRW5hYmxlZCA9IGVuYWJsZWRUcmFjZXJzLmhhcygnYWxsJyk7XG5mdW5jdGlvbiB0cmFjZShzZXZlcml0eSwgdHJhY2VyLCB0ZXh0KSB7XG4gICAgaWYgKGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpKSB7XG4gICAgICAgIGV4cG9ydHMubG9nKHNldmVyaXR5LCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnIHwgJyArIHRyYWNlciArICcgfCAnICsgdGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy50cmFjZSA9IHRyYWNlO1xuZnVuY3Rpb24gaXNUcmFjZXJFbmFibGVkKHRyYWNlcikge1xuICAgIHJldHVybiAhZGlzYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpICYmXG4gICAgICAgIChhbGxFbmFibGVkIHx8IGVuYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpKTtcbn1cbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gaXNUcmFjZXJFbmFibGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest,\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */\nfunction isPrototypePolluted(key) {\n    return ['__proto__', 'prototype', 'constructor'].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name) => {\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === 'string' && name.charAt(0) === '$') {\n            throw new Error('Method names cannot start with $');\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = 'bidi';\n            }\n            else {\n                methodType = 'client_stream';\n            }\n        }\n        else {\n            if (attrs.responseStream) {\n                methodType = 'server_stream';\n            }\n            else {\n                methodType = 'unary';\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] =\n                ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function (...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n    const result = {};\n    for (const serviceFqn in packageDef) {\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split('.');\n            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)) {\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            }\n            else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition;\n//# sourceMappingURL=make-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw2QkFBNkI7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ha2UtY2xpZW50LmpzPzAxYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbi8qKlxuICogTWFwIHdpdGggc2hvcnQgbmFtZXMgZm9yIGVhY2ggb2YgdGhlIHJlcXVlc3RlciBtYWtlciBmdW5jdGlvbnMuIFVzZWQgaW5cbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XG4gICAgdW5hcnk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZVVuYXJ5UmVxdWVzdCxcbiAgICBzZXJ2ZXJfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0LFxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXG4gICAgYmlkaTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlQmlkaVN0cmVhbVJlcXVlc3QsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUsIGlmIGdpdmVuIGtleSBpcyBpbmNsdWRlZCBpbiB0aGUgYmxhY2tsaXN0ZWRcbiAqIGtleXMuXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRlZChrZXkpIHtcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cbiAqIHRoZSBtZXRob2RzIGFyZ3VtZW50LiBUaGUgcmVzdWx0aW5nIGNsYXNzIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBtZXRob2QgZm9yXG4gKiBlYWNoIG1ldGhvZCBpbiB0aGUgc2VydmljZSwgd2hpY2ggaXMgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIG9uZSBvZiB0aGVcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcbiAqIGFuZCBgcmVzcG9uc2VTZXJpYWxpemVgLCB3aXRoIHRoZSBgbWV0aG9kYCwgYHNlcmlhbGl6ZWAsIGFuZCBgZGVzZXJpYWxpemVgXG4gKiBhcmd1bWVudHMgcHJlZGVmaW5lZC5cbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xuICogICAgIG1ldGhvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gc2VydmljZU5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybiBOZXcgY2xpZW50IGNvbnN0cnVjdG9yLCB3aGljaCBpcyBhIHN1YmNsYXNzIG9mXG4gKiAgICAge0BsaW5rIGdycGMuQ2xpZW50fSwgYW5kIGhhcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhhdCBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gbWFrZUNsaWVudENvbnN0cnVjdG9yKG1ldGhvZHMsIHNlcnZpY2VOYW1lLCBjbGFzc09wdGlvbnMpIHtcbiAgICBpZiAoIWNsYXNzT3B0aW9ucykge1xuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY2xhc3MgU2VydmljZUNsaWVudEltcGwgZXh0ZW5kcyBjbGllbnRfMS5DbGllbnQge1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGlmIChpc1Byb3RvdHlwZVBvbGx1dGVkKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBtZXRob2RzW25hbWVdO1xuICAgICAgICBsZXQgbWV0aG9kVHlwZTtcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBWZXJpZnkgdGhhdCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoICQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMucmVxdWVzdFN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50X3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlcl9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICd1bmFyeSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplID0gYXR0cnMucmVxdWVzdFNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemUgPSBhdHRycy5yZXNwb25zZURlc2VyaWFsaXplO1xuICAgICAgICBjb25zdCBtZXRob2RGdW5jID0gcGFydGlhbChyZXF1ZXN0ZXJGdW5jc1ttZXRob2RUeXBlXSwgYXR0cnMucGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSk7XG4gICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZEZ1bmM7XG4gICAgICAgIC8vIEFzc29jaWF0ZSBhbGwgcHJvdmlkZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBtZXRob2RcbiAgICAgICAgT2JqZWN0LmFzc2lnbihTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0sIGF0dHJzKTtcbiAgICAgICAgaWYgKGF0dHJzLm9yaWdpbmFsTmFtZSAmJiAhaXNQcm90b3R5cGVQb2xsdXRlZChhdHRycy5vcmlnaW5hbE5hbWUpKSB7XG4gICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbYXR0cnMub3JpZ2luYWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgU2VydmljZUNsaWVudEltcGwuc2VydmljZSA9IG1ldGhvZHM7XG4gICAgU2VydmljZUNsaWVudEltcGwuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICByZXR1cm4gU2VydmljZUNsaWVudEltcGw7XG59XG5leHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IG1ha2VDbGllbnRDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHBhcnRpYWwoZm4sIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKG9iaikge1xuICAgIHJldHVybiAnZm9ybWF0JyBpbiBvYmo7XG59XG4vKipcbiAqIExvYWQgYSBnUlBDIHBhY2thZ2UgZGVmaW5pdGlvbiBhcyBhIGdSUEMgb2JqZWN0IGhpZXJhcmNoeS5cbiAqIEBwYXJhbSBwYWNrYWdlRGVmIFRoZSBwYWNrYWdlIGRlZmluaXRpb24gb2JqZWN0LlxuICogQHJldHVybiBUaGUgcmVzdWx0aW5nIGdSUEMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBsb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qgc2VydmljZUZxbiBpbiBwYWNrYWdlRGVmKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZURlZiwgc2VydmljZUZxbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwYWNrYWdlRGVmW3NlcnZpY2VGcW5dO1xuICAgICAgICAgICAgY29uc3QgbmFtZUNvbXBvbmVudHMgPSBzZXJ2aWNlRnFuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiAobmFtZUNvbXBvbmVudHMuc29tZSgoY29tcCkgPT4gaXNQcm90b3R5cGVQb2xsdXRlZChjb21wKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gbmFtZUNvbXBvbmVudHNbbmFtZUNvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2YgbmFtZUNvbXBvbmVudHMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhY2thZ2VOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W3BhY2thZ2VOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYWNrYWdlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKHNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBzZXJ2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBtYWtlQ2xpZW50Q29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBsb2FkUGFja2FnZURlZmluaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n    constructor(options, callStream) {\n        super();\n        this.options = options;\n        this.callStream = callStream;\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n    }\n    async sendMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */\n        if (this.maxSendMessageSize === -1) {\n            return message;\n        }\n        else {\n            const concreteMessage = await message;\n            if (concreteMessage.message.length > this.maxSendMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);\n                return Promise.reject('Message too large');\n            }\n            else {\n                return concreteMessage;\n            }\n        }\n    }\n    async receiveMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */\n        if (this.maxReceiveMessageSize === -1) {\n            return message;\n        }\n        else {\n            const concreteMessage = await message;\n            if (concreteMessage.length > this.maxReceiveMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);\n                return Promise.reject('Message too large');\n            }\n            else {\n                return concreteMessage;\n            }\n        }\n    }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n    constructor(options) {\n        this.options = options;\n    }\n    createFilter(callStream) {\n        return new MaxMessageSizeFilter(this.options, callStream);\n    }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;\n//# sourceMappingURL=max-message-size-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyw0QkFBNEI7QUFDbEUsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SCxnQ0FBZ0MsTUFBTSx3QkFBd0I7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkgsd0JBQXdCLE1BQU0sMkJBQTJCO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYXgtbWVzc2FnZS1zaXplLWZpbHRlci5qcz83ZDkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXIgPSB2b2lkIDA7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY2xhc3MgTWF4TWVzc2FnZVNpemVGaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsU3RyZWFtKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FsbFN0cmVhbSA9IGNhbGxTdHJlYW07XG4gICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBBIGNvbmZpZ3VyZWQgc2l6ZSBvZiAtMSBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIGxpbWl0LCBzbyBza2lwIHRoZSBjaGVja1xuICAgICAgICAgKiBlbnRpcmVseSAqL1xuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNyZXRlTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoY29uY3JldGVNZXNzYWdlLm1lc3NhZ2UubGVuZ3RoID4gdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELCBgU2VudCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtjb25jcmV0ZU1lc3NhZ2UubWVzc2FnZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4U2VuZE1lc3NhZ2VTaXplfSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ01lc3NhZ2UgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY3JldGVNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogQSBjb25maWd1cmVkIHNpemUgb2YgLTEgbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBsaW1pdCwgc28gc2tpcCB0aGUgY2hlY2tcbiAgICAgICAgICogZW50aXJlbHkgKi9cbiAgICAgICAgaWYgKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb25jcmV0ZU1lc3NhZ2UgPSBhd2FpdCBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKGNvbmNyZXRlTWVzc2FnZS5sZW5ndGggPiB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsIGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtjb25jcmV0ZU1lc3NhZ2UubGVuZ3RofSB2cy4gJHt0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdNZXNzYWdlIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNyZXRlTWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXIgPSBNYXhNZXNzYWdlU2l6ZUZpbHRlcjtcbmNsYXNzIE1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IE1heE1lc3NhZ2VTaXplRmlsdGVyKHRoaXMub3B0aW9ucywgY2FsbFN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkgPSBNYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXgtbWVzc2FnZS1zaXplLWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        }\n        else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor(options = {}) {\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr) {\n            const clonedValue = value.map((v) => {\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        for (const [key, values] of other.internalRepr) {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    // For compatibility with the other Metadata implementation\n    _getCoreRepresentation() {\n        return this.internalRepr;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */\n    toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)) {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value) => {\n                            result.add(key, Buffer.from(value, 'base64'));\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach((v) => {\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\n                            });\n                        }\n                        else {\n                            result.add(key, Buffer.from(values, 'base64'));\n                        }\n                    }\n                }\n                else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value) => {\n                            result.add(key, value);\n                        });\n                    }\n                    else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            }\n            catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                logging_1.log(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val) => {\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJLElBQUksT0FBTyxJQUFJLGNBQWM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ldGFkYXRhLmpzP2ZjZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBMRUdBTF9LRVlfUkVHRVggPSAvXlswLTlhLXpfLi1dKyQvO1xuY29uc3QgTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWCA9IC9eWyAtfl0qJC87XG5mdW5jdGlvbiBpc0xlZ2FsS2V5KGtleSkge1xuICAgIHJldHVybiBMRUdBTF9LRVlfUkVHRVgudGVzdChrZXkpO1xufVxuZnVuY3Rpb24gaXNMZWdhbE5vbkJpbmFyeVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpbmFyeUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LmVuZHNXaXRoKCctYmluJyk7XG59XG5mdW5jdGlvbiBpc0N1c3RvbU1ldGFkYXRhKGtleSkge1xuICAgIHJldHVybiAha2V5LnN0YXJ0c1dpdGgoJ2dycGMtJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNMZWdhbEtleShrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YWRhdGEga2V5IFwiJyArIGtleSArICdcIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgdGhhdCBlbmQgd2l0aCAnLWJpbicgbXVzdCBoYXZlIEJ1ZmZlciB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgdGhhdCBkb24ndCBlbmQgd2l0aCAnLWJpbicgbXVzdCBoYXZlIFN0cmluZyB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIHN0cmluZyB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyBmb3Igc3RvcmluZyBtZXRhZGF0YS4gS2V5cyBhcmUgbm9ybWFsaXplZCB0byBsb3dlcmNhc2UgQVNDSUkuXG4gKi9cbmNsYXNzIE1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5IGJ5IHJlcGxhY2luZyBhbnkgb3RoZXIgdmFsdWVzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHdob3NlIHZhbHVlIHNob3VsZCBiZSBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuIE11c3QgYmUgYSBidWZmZXIgaWYgYW5kIG9ubHlcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5IGJ5IGFwcGVuZGluZyB0byBhIGxpc3Qgb2YgcHJldmlvdXNcbiAgICAgKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB3aGljaCBhIG5ldyB2YWx1ZSBzaG91bGQgYmUgYXBwZW5kZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuIE11c3QgYmUgYSBidWZmZXIgaWYgYW5kIG9ubHlcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxuICAgICAqL1xuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4ga2V5IGFuZCBhbnkgYXNzb2NpYXRlZCB2YWx1ZXMuIE5vcm1hbGl6ZXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhbGwgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiBBIGxpc3Qgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHBsYWluIG9iamVjdCBtYXBwaW5nIGVhY2gga2V5IHRvIHRoZSBmaXJzdCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICogVGhpcyByZWZsZWN0cyB0aGUgbW9zdCBjb21tb24gd2F5IHRoYXQgcGVvcGxlIHdpbGwgd2FudCB0byBzZWUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybiBBIGtleS92YWx1ZSBtYXBwaW5nIG9mIHRoZSBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodikgPyBCdWZmZXIuZnJvbSh2KSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBtZXRhZGF0YSBvYmplY3QuXG4gICAgICogQHJldHVybiBUaGUgbmV3bHkgY2xvbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgbmV3TWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEodGhpcy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgbmV3SW50ZXJuYWxSZXByID0gbmV3TWV0YWRhdGEuaW50ZXJuYWxSZXByO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkVmFsdWUgPSB2YWx1ZS5tYXAoKHYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3SW50ZXJuYWxSZXByLnNldChrZXksIGNsb25lZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3TWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gYSBnaXZlbiBNZXRhZGF0YSBvYmplY3QgaW50byB0aGlzIG9uZS5cbiAgICAgKiBJZiBib3RoIHRoaXMgb2JqZWN0IGFuZCB0aGUgZ2l2ZW4gb2JqZWN0IGhhdmUgdmFsdWVzIGluIHRoZSBzYW1lIGtleSxcbiAgICAgKiB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgTWV0YWRhdGEgb2JqZWN0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBvYmplY3Qnc1xuICAgICAqIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gb3RoZXIgQSBNZXRhZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIG90aGVyLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkVmFsdWUgPSAodGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW10pLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgbWVyZ2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE91dGdvaW5nSHR0cEhlYWRlcnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgaHR0cDIgQVBJLlxuICAgICAqL1xuICAgIHRvSHR0cDJIZWFkZXJzKCkge1xuICAgICAgICAvLyBOT1RFOiBOb2RlIDw4LjkgZm9ybWF0cyBodHRwMiBoZWFkZXJzIGluY29ycmVjdGx5LlxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGUgdXNlcidzIGludGVyYWN0aW9uIHdpdGggdGhpcyBvYmplY3QgaXMgbGltaXRlZCB0b1xuICAgICAgICAgICAgLy8gdGhyb3VnaCBpdHMgcHVibGljIEFQSSAoaS5lLiBrZXlzIGFuZCB2YWx1ZXMgYXJlIGFscmVhZHkgdmFsaWRhdGVkKS5cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzLm1hcChidWZUb1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb3RoZXIgTWV0YWRhdGEgaW1wbGVtZW50YXRpb25cbiAgICBfZ2V0Q29yZVJlcHJlc2VudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kaWZpZXMgdGhlIGJlaGF2aW9yIG9mIEpTT04uc3RyaW5naWZ5IHRvIHNob3cgYW4gb2JqZWN0XG4gICAgICogcmVwcmVzZW50YXRpb24gb2YgdGhlIG1ldGFkYXRhIG1hcC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgTWV0YWRhdGEgb2JqZWN0IGJhc2VkIGZpZWxkcyBpbiBhIGdpdmVuIEluY29taW5nSHR0cEhlYWRlcnNcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIGhlYWRlcnMgQW4gSW5jb21pbmdIdHRwSGVhZGVycyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IdHRwMkhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWV0YWRhdGEoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIC8vIFJlc2VydmVkIGhlYWRlcnMgKGJlZ2lubmluZyB3aXRoIGA6YCkgYXJlIG5vdCB2YWxpZCBrZXlzLlxuICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnlLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tTWV0YWRhdGEoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zcGxpdCgnLCcpLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHYudHJpbSgpLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgRmFpbGVkIHRvIGFkZCBtZXRhZGF0YSBlbnRyeSAke2tleX06ICR7dmFsdWVzfS4gJHtlcnJvci5tZXNzYWdlfS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9pc3N1ZXMvMTE3M2A7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5NZXRhZGF0YSA9IE1ldGFkYXRhO1xuY29uc3QgYnVmVG9TdHJpbmcgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsLnRvU3RyaW5nKCdiYXNlNjQnKSA6IHZhbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function (PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType = exports.PickResultType || (exports.PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\nclass UnavailablePicker {\n    constructor(status) {\n        if (status !== undefined) {\n            this.status = status;\n        }\n        else {\n            this.status = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'No connection established',\n                metadata: new metadata_1.Metadata(),\n            };\n        }\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            extraFilterFactories: [],\n            onCallStarted: null,\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */\nclass QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer) {\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(() => {\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null,\n        };\n    }\n}\nexports.QueuePicker = QueuePicker;\n//# sourceMappingURL=picker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ3hFLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDLHNCQUFzQixLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzPzAyOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIFBpY2tSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChQaWNrUmVzdWx0VHlwZSkge1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiQ09NUExFVEVcIl0gPSAwXSA9IFwiQ09NUExFVEVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlFVRVVFXCJdID0gMV0gPSBcIlFVRVVFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJUUkFOU0lFTlRfRkFJTFVSRVwiXSA9IDJdID0gXCJUUkFOU0lFTlRfRkFJTFVSRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiRFJPUFwiXSA9IDNdID0gXCJEUk9QXCI7XG59KShQaWNrUmVzdWx0VHlwZSA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgfHwgKGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBUUkFOU0lFTlRfRkFJTFVSRVxuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhbiBVTkFWQUlMQUJMRSBzdGF0dXMuXG4gKi9cbmNsYXNzIFVuYXZhaWxhYmxlUGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5UUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZXh0cmFGaWx0ZXJGYWN0b3JpZXM6IFtdLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gVW5hdmFpbGFibGVQaWNrZXI7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIElETEUgb3IgQ09OTkVDVElOR1xuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhIFFVRVVFIHBpY2sgcmVzdWx0XG4gKiBpbmRpY2F0aW5nIHRoYXQgdGhlIHBpY2sgc2hvdWxkIGJlIHRyaWVkIGFnYWluIHdpdGggdGhlIG5leHQgYFBpY2tlcmAuIEFsc29cbiAqIHJlcG9ydHMgYmFjayB0byB0aGUgbG9hZCBiYWxhbmNlciB0aGF0IGEgY29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWRcbiAqIG9uY2UgYW55IHBpY2sgaXMgYXR0ZW1wdGVkLlxuICovXG5jbGFzcyBRdWV1ZVBpY2tlciB7XG4gICAgLy8gQ29uc3RydWN0ZWQgd2l0aCBhIGxvYWQgYmFsYW5jZXIuIENhbGxzIGV4aXRJZGxlIG9uIGl0IHRoZSBmaXJzdCB0aW1lIHBpY2sgaXMgY2FsbGVkXG4gICAgY29uc3RydWN0b3IobG9hZEJhbGFuY2VyKSB7XG4gICAgICAgIHRoaXMubG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2VyO1xuICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxlZEV4aXRJZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlFVRVVFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIGV4dHJhRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IFF1ZXVlUGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n    const result = [];\n    for (let i = 0; i <\n        Math.max.apply(null, arrays.map((array) => array.length)); i++) {\n        for (const array of arrays) {\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener, channelOptions) {\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n        const hostPort = uri_parser_1.splitHostPort(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n                    },\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            }\n            else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n            metadata: new metadata_1.Metadata(),\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            trace('Returning IP address for target ' + uri_parser_1.uriToString(this.target));\n            setImmediate(() => {\n                this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n            });\n            this.backoff.stop();\n            this.backoff.reset();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace('Failed to parse DNS address ' + uri_parser_1.uriToString(this.target));\n            setImmediate(() => {\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n                    metadata: new metadata_1.Metadata(),\n                });\n            });\n            this.stopNextResolutionTimer();\n        }\n        else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace('Looking up DNS hostname ' + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */\n            this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */\n            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n            this.pendingLookupPromise.then((addressList) => {\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter((addr) => addr.family === 4);\n                const ip6Addresses = addressList.filter((addr) => addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));\n                const allAddressesString = '[' +\n                    this.latestLookupResult\n                        .map((addr) => addr.host + ':' + addr.port)\n                        .join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    uri_parser_1.uriToString(this.target) +\n                    ': ' +\n                    allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err) => {\n                trace('Resolution error for target ' +\n                    uri_parser_1.uriToString(this.target) +\n                    ': ' +\n                    err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */\n            if (this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */\n                this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord) => {\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n                    }\n                    catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: 'Parsing service config failed',\n                            metadata: new metadata_1.Metadata(),\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err) => {\n                    /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */\n                });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.startResolution();\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */\n        if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    resolver_1.registerResolver('dns', DnsResolver);\n    resolver_1.registerDefaultScheme('dns');\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-dns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQ0FBc0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHNDQUFzQztBQUNsRztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsc0NBQXNDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0k7QUFDL0ksYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVKQUF1SjtBQUN2SjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzPzY4OTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoXCJkbnNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdkbnNfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmNvbnN0IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyA9IDMwMDAwO1xuY29uc3QgcmVzb2x2ZVR4dFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMucmVzb2x2ZVR4dCk7XG5jb25zdCBkbnNMb29rdXBQcm9taXNlID0gdXRpbC5wcm9taXNpZnkoZG5zLmxvb2t1cCk7XG4vKipcbiAqIE1lcmdlIGFueSBudW1iZXIgb2YgYXJyYXlzIGludG8gYSBzaW5nbGUgYWx0ZXJuYXRpbmcgYXJyYXlcbiAqIEBwYXJhbSBhcnJheXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPFxuICAgICAgICBNYXRoLm1heC5hcHBseShudWxsLCBhcnJheXMubWFwKChhcnJheSkgPT4gYXJyYXkubGVuZ3RoKSk7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgICAgICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVzb2x2ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBoYW5kbGVzIEROUyBuYW1lcyBhbmQgSVAgYWRkcmVzc2VzLlxuICovXG5jbGFzcyBEbnNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRyYWNlKCdSZXNvbHZlciBjb25zdHJ1Y3RlZCBmb3IgdGFyZ2V0ICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQodGFyZ2V0LnBhdGgpO1xuICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ldF8xLmlzSVB2NChob3N0UG9ydC5ob3N0KSB8fCBuZXRfMS5pc0lQdjYoaG9zdFBvcnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9QT1JULFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZG5zSG9zdG5hbWUgPSBob3N0UG9ydC5ob3N0O1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IChfYiA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfUE9SVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICBkZXRhaWxzOiBgTmFtZSByZXNvbHV0aW9uIGZhaWxlZCBmb3IgdGFyZ2V0ICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KX1gLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmYudW5yZWYoKTtcbiAgICAgICAgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMgPSAoX2MgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVM7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYW4gSVAgYWRkcmVzcywganVzdCBwcm92aWRlIHRoYXQgYWRkcmVzcyBhcyBhIHJlc3VsdC5cbiAgICAgKiBPdGhlcndpc2UsIGluaXRpYXRlIEEsIEFBQUEsIGFuZCBUWFQgbG9va3Vwc1xuICAgICAqL1xuICAgIHN0YXJ0UmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXBSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZXR1cm5pbmcgSVAgYWRkcmVzcyBmb3IgdGFyZ2V0ICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuaXBSZXN1bHQsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRuc0hvc3RuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KX1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSgnTG9va2luZyB1cCBETlMgaG9zdG5hbWUgJyArIHRoaXMuZG5zSG9zdG5hbWUpO1xuICAgICAgICAgICAgLyogV2UgY2xlYXIgb3V0IGxhdGVzdExvb2t1cFJlc3VsdCBoZXJlIHRvIGVuc3VyZSB0aGF0IGl0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgICAgICogbGF0ZXN0IHJlc3VsdCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIHN0YXJ0ZWQgcmVzb2x2aW5nLiBUaGF0IHdheSwgdGhlXG4gICAgICAgICAgICAgKiBUWFQgcmVzb2x1dGlvbiBoYW5kbGVyIGNhbiB1c2UgaXQsIGJ1dCBvbmx5IGlmIGl0IGZpbmlzaGVzIHNlY29uZC4gV2VcbiAgICAgICAgICAgICAqIGRvbid0IGNsZWFyIG91dCBhbnkgcHJldmlvdXMgc2VydmljZSBjb25maWcgcmVzdWx0cyBiZWNhdXNlIGl0J3NcbiAgICAgICAgICAgICAqIGJldHRlciB0byB1c2UgYSBzZXJ2aWNlIGNvbmZpZyB0aGF0J3Mgc2xpZ2h0bHkgb3V0IG9mIGRhdGUgdGhhbiB0b1xuICAgICAgICAgICAgICogcmV2ZXJ0IHRvIGFuIGVmZmVjdGl2ZWx5IGJsYW5rIG9uZS4gKi9cbiAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gdGhpcy5kbnNIb3N0bmFtZTtcbiAgICAgICAgICAgIC8qIFdlIGxvb2t1cCBib3RoIGFkZHJlc3MgZmFtaWxpZXMgaGVyZSBhbmQgdGhlbiBzcGxpdCB0aGVtIHVwIGxhdGVyXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHdoZW4gbG9va2luZyB1cCBhIHNpbmdsZSBmYW1pbHksIGRucy5sb29rdXAgb3V0cHV0cyBhbiBlcnJvclxuICAgICAgICAgICAgICogaWYgdGhlIG5hbWUgZXhpc3RzIGJ1dCB0aGVyZSBhcmUgbm8gcmVjb3JkcyBmb3IgdGhhdCBmYW1pbHksIGFuZCB0aGF0XG4gICAgICAgICAgICAgKiBlcnJvciBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIG90aGVyIGtpbmRzIG9mIGVycm9ycyAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IGRuc0xvb2t1cFByb21pc2UoaG9zdG5hbWUsIHsgYWxsOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZS50aGVuKChhZGRyZXNzTGlzdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXA0QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmZhbWlseSA9PT0gNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXA2QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmZhbWlseSA9PT0gNik7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBtZXJnZUFycmF5cyhpcDZBZGRyZXNzZXMsIGlwNEFkZHJlc3NlcykubWFwKChhZGRyKSA9PiAoeyBob3N0OiBhZGRyLmFkZHJlc3MsIHBvcnQ6ICt0aGlzLnBvcnQgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEFkZHJlc3Nlc1N0cmluZyA9ICdbJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChhZGRyKSA9PiBhZGRyLmhvc3QgKyAnOicgKyBhZGRyLnBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpICtcbiAgICAgICAgICAgICAgICAgICAgJ10nO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHZlZCBhZGRyZXNzZXMgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBhbGxBZGRyZXNzZXNTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIFRYVCBsb29rdXAgaGFzIG5vdCB5ZXQgZmluaXNoZWQsIGJvdGggb2YgdGhlIGxhc3QgdHdvXG4gICAgICAgICAgICAgICAgICogYXJndW1lbnRzIHdpbGwgYmUgbnVsbCwgd2hpY2ggaXMgdGhlIGVxdWl2YWxlbnQgb2YgZ2V0dGluZyBhblxuICAgICAgICAgICAgICAgICAqIGVtcHR5IFRYVCByZXNwb25zZS4gV2hlbiB0aGUgVFhUIGxvb2t1cCBkb2VzIGZpbmlzaCwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgKiBjYW4gdXBkYXRlIHRoZSBzZXJ2aWNlIGNvbmZpZyBieSB1c2luZyB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZywgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IsIG51bGwsIHt9KTtcbiAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVzb2x1dGlvbiBlcnJvciBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIElmIHRoZXJlIGFscmVhZHkgaXMgYSBzdGlsbC1wZW5kaW5nIFRYVCByZXNvbHV0aW9uLCB3ZSBjYW4ganVzdCB1c2VcbiAgICAgICAgICAgICAqIHRoYXQgcmVzdWx0IHdoZW4gaXQgY29tZXMgaW4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdUeHRQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyogV2UgaGFuZGxlIHRoZSBUWFQgcXVlcnkgcHJvbWlzZSBkaWZmZXJlbnRseSB0aGFuIHRoZSBvdGhlcnMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAqIHRoZSBuYW1lIHJlc29sdXRpb24gYXR0ZW1wdCBhcyBhIHdob2xlIGlzIGEgc3VjY2VzcyBldmVuIGlmIHRoZSBUWFRcbiAgICAgICAgICAgICAgICAgKiBsb29rdXAgZmFpbHMgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gcmVzb2x2ZVR4dFByb21pc2UoaG9zdG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UudGhlbigodHh0UmVjb3JkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnID0gc2VydmljZV9jb25maWdfMS5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHRoaXMucGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdQYXJzaW5nIHNlcnZpY2UgY29uZmlnIGZhaWxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogV2UgcmVseSBoZXJlIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGlkZW50aWNhbCBwYXJhbWV0ZXJzIHdpbGwgYmUgZXNzZW50aWFseSBpZGVtcG90ZW50LCBhbmQgY2FsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgd2l0aCB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgYW5kIGEgZGlmZmVyZW50IHNlcnZpY2UgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaG91bGQgcmVzdWx0IGluIGEgZmFzdCBhbmQgc2VhbWxlc3Mgc3dpdGNob3Zlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCwgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnLCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciwgbnVsbCwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBUWFQgbG9va3VwIGZhaWxzIHdlIHNob3VsZCBkbyBub3RoaW5nLCB3aGljaCBtZWFucyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnRpbnVlIHRvIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcbiAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bCBsb29rdXAuIFdlIGRvIG5vdCBzZXQgdGhlIGxhdGVzdFNlcnZpY2VDb25maWdFcnJvclxuICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGJlY2F1c2UgdGhhdCBpcyBzcGVjaWZpY2FsbHkgdXNlZCBmb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBidWJibGUgdXAgYXMgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLiAqL1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJ1bk9uY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxuICAgICAgICAgKiBuZXh0UmVzb2x1dGlvblRpbWVyIG9yIGJhY2tvZmYgdGltZXIgaXMgcnVubmluZywgc2V0IHRoZVxuICAgICAgICAgKiBjb250aW51ZVJlc29sdmluZyBmbGFnIHRvIHJlc29sdmUgd2hlbiB3aGljaGV2ZXIgb2YgdGhvc2UgdGltZXJzXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgfHwgdGhpcy5iYWNrb2ZmLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKCdkbnMnLCBEbnNSZXNvbHZlcik7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUoJ2RucycpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItZG5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'ip_resolver';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = 'ipv4';\nconst IPV6_SCHEME = 'ipv6';\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions) {\n        var _a;\n        this.target = target;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        trace('Resolver constructed for target ' + uri_parser_1.uriToString(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata(),\n            };\n            return;\n        }\n        const pathList = target.path.split(',');\n        for (const path of pathList) {\n            const hostPort = uri_parser_1.splitHostPort(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            if ((target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host)) ||\n                (target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host))) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n            });\n        }\n        this.addresses = addresses;\n        trace('Parsed ' + target.scheme + ' address list ' + this.addresses);\n    }\n    updateResolution() {\n        process.nextTick(() => {\n            if (this.error) {\n                this.listener.onError(this.error);\n            }\n            else {\n                this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n            }\n        });\n    }\n    destroy() {\n        // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(',')[0];\n    }\n}\nfunction setup() {\n    resolver_1.registerResolver(IPV4_SCHEME, IpResolver);\n    resolver_1.registerResolver(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsVUFBVSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxVQUFVLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWlwLmpzPzI0NjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnaXBfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcbmNvbnN0IElQVjZfU0NIRU1FID0gJ2lwdjYnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5jbGFzcyBJcFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aExpc3QgPSB0YXJnZXQucGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQocGF0aCk7XG4gICAgICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgJiYgIW5ldF8xLmlzSVB2NChob3N0UG9ydC5ob3N0KSkgfHxcbiAgICAgICAgICAgICAgICAodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUgJiYgIW5ldF8xLmlzSVB2Nihob3N0UG9ydC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gYWRkcmVzc2VzO1xuICAgICAgICB0cmFjZSgnUGFyc2VkICcgKyB0YXJnZXQuc2NoZW1lICsgJyBhZGRyZXNzIGxpc3QgJyArIHRoaXMuYWRkcmVzc2VzKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmFkZHJlc3NlcywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVGhpcyByZXNvbHZlciBvd25zIG5vIHJlc291cmNlcywgc28gd2UgZG8gbm90aGluZyBoZXJlLlxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoLnNwbGl0KCcsJylbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcbiAgICByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIoSVBWNl9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItaXAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions) {\n        this.listener = listener;\n        this.addresses = [];\n        let path;\n        if (target.authority === '') {\n            path = '/' + target.path;\n        }\n        else {\n            path = target.path;\n        }\n        this.addresses = [{ path }];\n    }\n    updateResolution() {\n        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n    }\n    destroy() {\n        // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return 'localhost';\n    }\n}\nfunction setup() {\n    resolver_1.registerResolver('unix', UdsResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-uds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLXVkcy5qcz8xODMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSB2b2lkIDA7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jbGFzcyBVZHNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgaWYgKHRhcmdldC5hdXRob3JpdHkgPT09ICcnKSB7XG4gICAgICAgICAgICBwYXRoID0gJy8nICsgdGFyZ2V0LnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gdGFyZ2V0LnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbeyBwYXRoIH1dO1xuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgdGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVGhpcyByZXNvbHZlciBvd25zIG5vIHJlc291cmNlcywgc28gd2UgZG8gbm90aGluZyBoZXJlLlxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuICdsb2NhbGhvc3QnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcigndW5peCcsIFVkc1Jlc29sdmVyKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLXVkcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    }\n    else {\n        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    }\n    else {\n        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: uri_parser_1.uriToString(target),\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0I7QUFDN0kscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQ0FBaUM7QUFDcEc7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQ0FBaUM7QUFDM0U7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanM/MDFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXBVcmlEZWZhdWx0U2NoZW1lID0gZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0U2NoZW1lID0gZXhwb3J0cy5yZWdpc3RlclJlc29sdmVyID0gdm9pZCAwO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHJlZ2lzdGVyZWRSZXNvbHZlcnMgPSB7fTtcbmxldCBkZWZhdWx0U2NoZW1lID0gbnVsbDtcbi8qKlxuICogUmVnaXN0ZXIgYSByZXNvbHZlciBjbGFzcyB0byBoYW5kbGUgdGFyZ2V0IG5hbWVzIHByZWZpeGVkIHdpdGggdGhlIGBwcmVmaXhgXG4gKiBzdHJpbmcuIFRoaXMgcHJlZml4IHNob3VsZCBjb3JyZXNwb25kIHRvIGEgVVJJIHNjaGVtZSBuYW1lIGxpc3RlZCBpbiB0aGVcbiAqIFtnUlBDIE5hbWUgUmVzb2x1dGlvbiBkb2N1bWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvbmFtaW5nLm1kKVxuICogQHBhcmFtIHByZWZpeFxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSZXNvbHZlcihzY2hlbWUsIHJlc29sdmVyQ2xhc3MpIHtcbiAgICByZWdpc3RlcmVkUmVzb2x2ZXJzW3NjaGVtZV0gPSByZXNvbHZlckNsYXNzO1xufVxuZXhwb3J0cy5yZWdpc3RlclJlc29sdmVyID0gcmVnaXN0ZXJSZXNvbHZlcjtcbi8qKlxuICogUmVnaXN0ZXIgYSBkZWZhdWx0IHJlc29sdmVyIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aFxuICogYW55IHJlZ2lzdGVyZWQgcHJlZml4LlxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0U2NoZW1lKHNjaGVtZSkge1xuICAgIGRlZmF1bHRTY2hlbWUgPSBzY2hlbWU7XG59XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IHJlZ2lzdGVyRGVmYXVsdFNjaGVtZTtcbi8qKlxuICogQ3JlYXRlIGEgbmFtZSByZXNvbHZlciBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQsIGlmIHBvc3NpYmxlLiBUaHJvd3MgYW5cbiAqIGVycm9yIGlmIG5vIHN1Y2ggbmFtZSByZXNvbHZlciBjYW4gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcih0YXJnZXQsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkUmVzb2x2ZXJzW3RhcmdldC5zY2hlbWVdKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNvbHZlciBjb3VsZCBiZSBjcmVhdGVkIGZvciB0YXJnZXQgJHt1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGFyZ2V0KX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gY3JlYXRlUmVzb2x2ZXI7XG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LCBpZiBwb3NzaWJsZS4gVGhyb3dzIGFuXG4gKiBlcnJvciBpZiBubyByZWdpc3RlcmVkIG5hbWUgcmVzb2x2ZXIgY2FuIHBhcnNlIHRoYXQgdGFyZ2V0IHN0cmluZy5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFJlc29sdmVyc1t0YXJnZXQuc2NoZW1lXS5nZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFyZ2V0ICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZ2V0RGVmYXVsdEF1dGhvcml0eTtcbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09IHVuZGVmaW5lZCB8fCAhKHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBkZWZhdWx0U2NoZW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhdGg6IHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0YXJnZXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBtYXBVcmlEZWZhdWx0U2NoZW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split('/').filter((x) => x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n        if (serviceConfig && serviceConfig.methodConfig) {\n            for (const methodConfig of serviceConfig.methodConfig) {\n                for (const name of methodConfig.name) {\n                    if (name.service === service &&\n                        (name.method === undefined || name.method === method)) {\n                        return {\n                            methodConfig: methodConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK,\n                            dynamicFilterFactories: []\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            methodConfig: { name: [] },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: []\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */\n        this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        if (channelOptions['grpc.service_config']) {\n            this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n        }\n        else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: [],\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker) => {\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = resolver_1.createResolver(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n                var _a;\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */\n                if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    }\n                    else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        }\n                        else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                }\n                else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: 'All load balancer options in service config are not compatible',\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error) => {\n                this.handleResolutionFailure(error);\n            },\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace(uri_parser_1.uriToString(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHNDQUFzQyxtQkFBTyxDQUFDLGtIQUErQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmluZy1sb2FkLWJhbGFuY2VyLmpzP2NiOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgREVGQVVMVF9MT0FEX0JBTEFOQ0VSX05BTUUgPSAncGlja19maXJzdCc7XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3Ioc2VydmljZUNvbmZpZykge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWZhdWx0Q29uZmlnU2VsZWN0b3IobWV0aG9kTmFtZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc3BsaXROYW1lID0gbWV0aG9kTmFtZS5zcGxpdCgnLycpLmZpbHRlcigoeCkgPT4geC5sZW5ndGggPiAwKTtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IChfYSA9IHNwbGl0TmFtZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IChfYiA9IHNwbGl0TmFtZVsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnICYmIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZENvbmZpZyBvZiBzZXJ2aWNlQ29uZmlnLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobmFtZS5tZXRob2QgPT09IHVuZGVmaW5lZCB8fCBuYW1lLm1ldGhvZCA9PT0gbWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RDb25maWc6IG1ldGhvZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJGYWN0b3JpZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2RDb25maWc6IHsgbmFtZTogW10gfSxcbiAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXG4gICAgICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJGYWN0b3JpZXM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmNsYXNzIFJlc29sdmluZ0xvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIGBMb2FkQmFsYW5jZXJgIGFuZCBhbHNvIGhhbmRsZXMgbmFtZVxuICAgICAqIHJlc29sdXRpb24gaW50ZXJuYWxseS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBhZGRyZXNzIG9mIHRoZSBiYWNrZW5kIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICogQHBhcmFtIGRlZmF1bHRTZXJ2aWNlQ29uZmlnIFRoZSBkZWZhdWx0IHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkXG4gICAgICogICAgIGlmIG5vbmUgaXMgcHJvdmlkZWQgYnkgdGhlIG5hbWUgcmVzb2x2ZXIuIEEgYG51bGxgIHZhbHVlIGluZGljYXRlc1xuICAgICAqICAgICB0aGF0IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNob3VsZCBiZSB0aGUgZGVmYXVsdCB1bmNvbmZpZ3VyZWQgYmVoYXZpb3IuXG4gICAgICogICAgIEluIHByYWN0aWNlLCB0aGF0IG1lYW5zIHVzaW5nIHRoZSBcInBpY2sgZmlyc3RcIiBsb2FkIGJhbGFuY2VyXG4gICAgICogICAgIGltcGxtZW50YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBjaGFubmVsT3B0aW9ucywgb25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgb25GYWlsZWRSZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBjaGFubmVsT3B0aW9ucztcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uID0gb25TdWNjZXNzZnVsUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc29sdXRpb24gPSBvbkZhaWxlZFJlc29sdXRpb247XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHJlc29sdmluZyBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VydmljZSBjb25maWcgb2JqZWN0IGZyb20gdGhlIGxhc3Qgc3VjY2Vzc2Z1bCByZXNvbHV0aW9uLCBpZlxuICAgICAgICAgKiBhdmFpbGFibGUuIEEgdmFsdWUgb2YgbnVsbCBpbmRpY2F0ZXMgdGhhdCB3ZSBoYXZlIG5vdCB5ZXQgcmVjZWl2ZWQgYSB2YWxpZFxuICAgICAgICAgKiBzZXJ2aWNlIGNvbmZpZyBmcm9tIHRoZSByZXNvbHZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHdlIHNob3VsZCBhdHRlbXB0IHRvIHJlc29sdmUgYWdhaW4gYWZ0ZXIgdGhlIGJhY2tvZmZcbiAgICAgICAgICogdGltZXIgcnVucyBvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0gc2VydmljZV9jb25maWdfMS52YWxpZGF0ZVNlcnZpY2VDb25maWcoSlNPTi5wYXJzZShjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoe1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZlRpbWVvdXQgaXMgcnVubmluZywgd2UncmUgc3RpbGwgYmFja2luZyBvZmYgZnJvbVxuICAgICAgICAgICAgICAgICAqIG1ha2luZyByZXNvbHZlIHJlcXVlc3RzLCBzbyB3ZSBzaG91bGRuJ3QgbWFrZSBhbm90aGVyIG9uZSBoZXJlLlxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXG4gICAgICAgICAgICAgICAgICogdXBkYXRlUmVzb2x1dGlvbiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAobmV3U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyID0gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcih0YXJnZXQsIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yLCBjb25maWdTZWxlY3RvciwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgd29ya2luZ1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8qIFRoaXMgZmlyc3QgZ3JvdXAgb2YgY29uZGl0aW9uYWxzIGltcGxlbWVudHMgdGhlIGFsZ29yaXRobSBkZXNjcmliZWRcbiAgICAgICAgICAgICAgICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMjEtc2VydmljZS1jb25maWctZXJyb3ItaGFuZGxpbmcubWRcbiAgICAgICAgICAgICAgICAgKiBpbiB0aGUgc2VjdGlvbiBjYWxsZWQgXCJCZWhhdmlvciBvbiByZWNlaXZpbmcgYSBuZXcgZ1JQQyBDb25maWdcIi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQgYW5kIDVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWdFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA1XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNC5paVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoc2VydmljZUNvbmZpZ0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNC5pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBzZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3b3JraW5nQ29uZmlnTGlzdCA9IChfYSA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSBudWxsIHx8IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3b3JraW5nU2VydmljZUNvbmZpZy5sb2FkQmFsYW5jaW5nQ29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkQmFsYW5jaW5nQ29uZmlnID0gbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKHdvcmtpbmdDb25maWdMaXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZEJhbGFuY2luZ0NvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3ZXJlIGxvYWQgYmFsYW5jaW5nIGNvbmZpZ3MgYnV0IG5vbmUgYXJlIHN1cHBvcnRlZC4gVGhpcyBjb3VudHMgYXMgYSByZXNvbHV0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQWxsIGxvYWQgYmFsYW5jZXIgb3B0aW9ucyBpbiBzZXJ2aWNlIGNvbmZpZyBhcmUgbm90IGNvbXBhdGlibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2VydmljZUNvbmZpZyA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSBudWxsICYmIHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSB2b2lkIDAgPyB3b3JraW5nU2VydmljZUNvbmZpZyA6IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKGNvbmZpZ1NlbGVjdG9yICE9PSBudWxsICYmIGNvbmZpZ1NlbGVjdG9yICE9PSB2b2lkIDAgPyBjb25maWdTZWxlY3RvciA6IGdldERlZmF1bHRDb25maWdTZWxlY3RvcihmaW5hbFNlcnZpY2VDb25maWcpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5sYXRlc3RDaGlsZFN0YXRlLCB0aGlzLmxhdGVzdENoaWxkUGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgIHRyYWNlKHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbY29ubmVjdGl2aXR5U3RhdGVdKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhpcy5leGl0SWRsZSgpIGlzIGNhbGxlZCBieSB0aGUgcGlja2VyXG4gICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgcGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIGhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENoaWxkU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcihlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5vbkZhaWxlZFJlc29sdXRpb24oZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHwgdGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVBZGRyZXNzTGlzdCBub3Qgc3VwcG9ydGVkIG9uIFJlc29sdmluZ0xvYWRCYWxhbmNlcicpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04sIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gUmVzb2x2aW5nTG9hZEJhbGFuY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'server_call';\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultResponseHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n    [GRPC_ENCODING_HEADER]: 'identity',\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request) {\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once('drain', callback);\n                return;\n            }\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.emit('error', err);\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: 'OK',\n            metadata: this.trailingMetadata,\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on('error', (err) => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read =\n    ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n    ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n    ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options) {\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.options = options;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit('cancelled', 'cancelled');\n                this.emit('streamEnd', false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: 'Cancelled by client',\n                    metadata: null,\n                });\n            }\n        });\n        this.stream.on('drain', () => {\n            this.emit('drain');\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        if (encoding === 'deflate') {\n            return inflate(message.subarray(5));\n        }\n        else if (encoding === 'gzip') {\n            return unzip(message.subarray(5));\n        }\n        else if (encoding === 'identity') {\n            return message.subarray(5);\n        }\n        return Promise.reject({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n        });\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace('Request to ' +\n                this.handler.path +\n                ' received headers ' +\n                JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error('Invalid deadline');\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    receiveUnaryMessage(encoding, next) {\n        const { stream } = this;\n        let receivedLength = 0;\n        const call = this;\n        const body = [];\n        const limit = this.maxReceiveMessageSize;\n        stream.on('data', onData);\n        stream.on('end', onEnd);\n        stream.on('error', onEnd);\n        function onData(chunk) {\n            receivedLength += chunk.byteLength;\n            if (limit !== -1 && receivedLength > limit) {\n                stream.removeListener('data', onData);\n                stream.removeListener('end', onEnd);\n                stream.removeListener('error', onEnd);\n                next({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n                });\n                return;\n            }\n            body.push(chunk);\n        }\n        function onEnd(err) {\n            stream.removeListener('data', onData);\n            stream.removeListener('end', onEnd);\n            stream.removeListener('error', onEnd);\n            if (err !== undefined) {\n                next({ code: constants_1.Status.INTERNAL, details: err.message });\n                return;\n            }\n            if (receivedLength === 0) {\n                next({ code: constants_1.Status.INTERNAL, details: 'received empty unary message' });\n                return;\n            }\n            call.emit('receiveMessage');\n            const requestBytes = Buffer.concat(body, receivedLength);\n            const compressed = requestBytes.readUInt8(0) === 1;\n            const compressedMessageEncoding = compressed ? encoding : 'identity';\n            const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n            if (Buffer.isBuffer(decompressedMessage)) {\n                call.safeDeserializeMessage(decompressedMessage, next);\n                return;\n            }\n            decompressedMessage.then((decompressed) => call.safeDeserializeMessage(decompressed, next), (err) => next(err.code\n                ? err\n                : {\n                    code: constants_1.Status.INTERNAL,\n                    details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n                }));\n        }\n    }\n    safeDeserializeMessage(buffer, next) {\n        try {\n            next(null, this.deserializeMessage(buffer));\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            next(err);\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\n        }\n        catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.sendError(err);\n        }\n    }\n    sendStatus(statusObj) {\n        var _a;\n        this.emit('callEnd', statusObj.code);\n        this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[statusObj.code] +\n            ' details: ' +\n            statusObj.details);\n        if (this.deadlineTimer)\n            clearTimeout(this.deadlineTimer);\n        if (!this.wantTrailers) {\n            this.wantTrailers = true;\n            this.stream.once('wantTrailers', () => {\n                var _a;\n                const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                this.stream.sendTrailers(trailersToSend);\n                this.statusSent = true;\n            });\n            this.sendMetadata();\n            this.stream.end();\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: 'message' in error ? error.message : 'Unknown Error',\n            metadata: 'metadata' in error && error.metadata !== undefined\n                ? error.metadata\n                : null,\n        };\n        if ('code' in error &&\n            typeof error.code === 'number' &&\n            Number.isInteger(error.code)) {\n            status.code = error.code;\n            if ('details' in error && typeof error.details === 'string') {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit('sendMessage');\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once('cancelled', (reason) => {\n            call.cancelled = true;\n            call.emit('cancelled', reason);\n        });\n        this.once('callEnd', (status) => call.emit('callEnd', status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = () => {\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on('data', async (data) => {\n            const messages = decoder.write(data);\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages) {\n                if (this.maxReceiveMessageSize !== -1 &&\n                    message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n                    });\n                    return;\n                }\n                this.emit('receiveMessage');\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\n                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage)\n                    return;\n                this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            maybePushEnd();\n        });\n        this.stream.once('end', () => {\n            readsDone = true;\n            maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while (this.messagesToPush.length > 0) {\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        }\n        else {\n            this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace('Received end of stream');\n            if (this.canPush) {\n                readable.push(null);\n            }\n            else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace('Received message of length ' + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            }\n            else {\n                this.messagesToPush.push(deserialized);\n            }\n        }\n        catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            if (!('code' in error &&\n                typeof error.code === 'number' &&\n                Number.isInteger(error.code) &&\n                error.code >= constants_1.Status.OK &&\n                error.code <= constants_1.Status.UNAUTHENTICATED)) {\n                // The error code is not a valid gRPC code so its being overwritten.\n                error.code = constants_1.Status.INTERNAL;\n            }\n            readable.emit('error', error);\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        const socket = this.stream.session.socket;\n        if (socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error('Deadline exceeded');\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit('cancelled', 'deadline');\n}\n//# sourceMappingURL=server-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkI7QUFDbEssaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ25ELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUztBQUN4RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0IsTUFBTSxNQUFNO0FBQzlGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQXlEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0RUFBNEU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVMsUUFBUSxVQUFVO0FBQzVGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFzRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkZBQTJGO0FBQ2xKO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsTUFBTSx3QkFBd0I7QUFDdEcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQixNQUFNLDJCQUEyQjtBQUN2SCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCLEdBQUcsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanM/NjA5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBleHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJVbmFyeUNhbGxJbXBsID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzZXJ2ZXJfY2FsbCc7XG5jb25zdCB1bnppcCA9IHV0aWxfMS5wcm9taXNpZnkoemxpYi51bnppcCk7XG5jb25zdCBpbmZsYXRlID0gdXRpbF8xLnByb21pc2lmeSh6bGliLmluZmxhdGUpO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1lbmNvZGluZyc7XG5jb25zdCBHUlBDX01FU1NBR0VfSEVBREVSID0gJ2dycGMtbWVzc2FnZSc7XG5jb25zdCBHUlBDX1NUQVRVU19IRUFERVIgPSAnZ3JwYy1zdGF0dXMnO1xuY29uc3QgR1JQQ19USU1FT1VUX0hFQURFUiA9ICdncnBjLXRpbWVvdXQnO1xuY29uc3QgREVBRExJTkVfUkVHRVggPSAvKFxcZHsxLDh9KVxccyooW0hNU211bl0pLztcbmNvbnN0IGRlYWRsaW5lVW5pdHNUb01zID0ge1xuICAgIEg6IDM2MDAwMDAsXG4gICAgTTogNjAwMDAsXG4gICAgUzogMTAwMCxcbiAgICBtOiAxLFxuICAgIHU6IDAuMDAxLFxuICAgIG46IDAuMDAwMDAxLFxufTtcbmNvbnN0IGRlZmF1bHRSZXNwb25zZUhlYWRlcnMgPSB7XG4gICAgLy8gVE9ETyhjamlocmlnKTogUmVtb3ZlIHRoZXNlIGVuY29kaW5nIGhlYWRlcnMgZnJvbSB0aGUgZGVmYXVsdCByZXNwb25zZVxuICAgIC8vIG9uY2UgY29tcHJlc3Npb24gaXMgaW50ZWdyYXRlZC5cbiAgICBbR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcsXG4gICAgW0dSUENfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5JyxcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfT0ssXG4gICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTogJ2FwcGxpY2F0aW9uL2dycGMrcHJvdG8nLFxufTtcbmNvbnN0IGRlZmF1bHRSZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgd2FpdEZvclRyYWlsZXJzOiB0cnVlLFxufTtcbmNsYXNzIFNlcnZlclVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCByZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclVuYXJ5Q2FsbEltcGwgPSBTZXJ2ZXJVbmFyeUNhbGxJbXBsO1xuY2xhc3MgU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBkZXNlcmlhbGl6ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFJlYWRhYmxlKHRoaXMsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgX3JlYWQoc2l6ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbC5jb25zdW1lVW5wdXNoZWRNZXNzYWdlcyh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbC5yZXN1bWUoKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsID0gU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBzZXJpYWxpemUsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuY2FsbC5zZXJpYWxpemVNZXNzYWdlKGNodW5rKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsLndyaXRlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5vbmNlKCdkcmFpbicsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBfZmluYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgZGV0YWlsczogJ09LJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLnRyYWlsaW5nTWV0YWRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlbmQobWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRhZGF0YSwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBSZWFkYWJsZSh0aGlzLCBlbmNvZGluZyk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlbmQobWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gU2VydmVyRHVwbGV4U3RyZWFtSW1wbDtcblNlcnZlckR1cGxleFN0cmVhbUltcGwucHJvdG90eXBlLl9yZWFkID1cbiAgICBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9yZWFkO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX3dyaXRlID1cbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl93cml0ZTtcblNlcnZlckR1cGxleFN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbCA9XG4gICAgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsLnByb3RvdHlwZS5fZmluYWw7XG4vLyBJbnRlcm5hbCBjbGFzcyB0aGF0IHdyYXBzIHRoZSBIVFRQMiByZXF1ZXN0LlxuY2xhc3MgSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlYWRsaW5lID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWV0YWRhdGFTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2ggPSBbXTtcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgLyogV2UgbmVlZCBhbiBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHVuY2F1Z2h0IGVycm9yIGV2ZW50IGV4Y2VwdGlvbnMsIGJ1dFxuICAgICAgICAgICAgICogdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gcmVhc29uYWJseSBkbyBoZXJlLiBBbnkgZXJyb3IgZXZlbnQgc2hvdWxkXG4gICAgICAgICAgICAgKiBoYXZlIGEgY29ycmVzcG9uZGluZyBjbG9zZSBldmVudCwgd2hpY2ggaGFuZGxlcyBlbWl0dGluZyB0aGUgY2FuY2VsbGVkXG4gICAgICAgICAgICAgKiBldmVudC4gQW5kIHRoZSBzdHJlYW0gaXMgbm93IGluIGEgYmFkIHN0YXRlLCBzbyB3ZSBjYW4ndCByZWFzb25hYmx5XG4gICAgICAgICAgICAgKiBleHBlY3QgdG8gYmUgYWJsZSB0byBzZW5kIGFuIGVycm9yIG92ZXIgaXQuICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICsgKChfYSA9IHRoaXMuaGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGgpICtcbiAgICAgICAgICAgICAgICAnIHN0cmVhbSBjbG9zZWQgd2l0aCByc3RDb2RlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c1NlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjYW5jZWxsZWQnLCAnY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW1FbmQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ0NhbmNlbGxlZCBieSBjbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0NhbmNlbGxlZCgpIHtcbiAgICAgICAgLyogSW4gc29tZSBjYXNlcyB0aGUgc3RyZWFtIGNhbiBiZWNvbWUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2xvc2UgZXZlbnRcbiAgICAgICAgICogZmlyZXMuIFRoYXQgY3JlYXRlcyBhIHJhY2UgY29uZGl0aW9uIHRoYXQgdGhpcyBjaGVjayB3b3JrcyBhcm91bmQgKi9cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmRlc3Ryb3llZCB8fCB0aGlzLnN0cmVhbS5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldERlY29tcHJlc3NlZE1lc3NhZ2UobWVzc2FnZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZsYXRlKG1lc3NhZ2Uuc3ViYXJyYXkoNSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnppcChtZXNzYWdlLnN1YmFycmF5KDUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc3ViYXJyYXkoNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgY29tcHJlc3NlZCB3aXRoIHVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHtlbmNvZGluZ31cImAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEoY3VzdG9tTWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhU2VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0YWRhdGFTZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY3VzdG9tID0gY3VzdG9tTWV0YWRhdGEgPyBjdXN0b21NZXRhZGF0YS50b0h0dHAySGVhZGVycygpIDogbnVsbDtcbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogSW5jbHVkZSBjb21wcmVzc2lvbiBoZWFkZXJzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzKSwgY3VzdG9tKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ucmVzcG9uZChoZWFkZXJzLCBkZWZhdWx0UmVzcG9uc2VPcHRpb25zKTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICAgICAnIHJlY2VpdmVkIGhlYWRlcnMgJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEudG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBSZWNlaXZlIGNvbXByZXNzaW9uIG1ldGFkYXRhLlxuICAgICAgICBjb25zdCB0aW1lb3V0SGVhZGVyID0gbWV0YWRhdGEuZ2V0KEdSUENfVElNRU9VVF9IRUFERVIpO1xuICAgICAgICBpZiAodGltZW91dEhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRpbWVvdXRIZWFkZXJbMF0udG9TdHJpbmcoKS5tYXRjaChERUFETElORV9SRUdFWCk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0ludmFsaWQgZGVhZGxpbmUnKTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5PVVRfT0ZfUkFOR0U7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gKCttYXRjaFsxXSAqIGRlYWRsaW5lVW5pdHNUb01zW21hdGNoWzJdXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSBub3cuc2V0TWlsbGlzZWNvbmRzKG5vdy5nZXRNaWxsaXNlY29uZHMoKSArIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dChoYW5kbGVFeHBpcmVkRGVhZGxpbmUsIHRpbWVvdXQsIHRoaXMpO1xuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKEdSUENfVElNRU9VVF9IRUFERVIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBzZXZlcmFsIGhlYWRlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByb3BhZ2F0ZWQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0FDQ0VQVF9FTkNPRElORyk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1RFKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWFjY2VwdC1lbmNvZGluZycpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJlY2VpdmVVbmFyeU1lc3NhZ2UoZW5jb2RpbmcsIG5leHQpIHtcbiAgICAgICAgY29uc3QgeyBzdHJlYW0gfSA9IHRoaXM7XG4gICAgICAgIGxldCByZWNlaXZlZExlbmd0aCA9IDA7XG4gICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzO1xuICAgICAgICBjb25zdCBib2R5ID0gW107XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemU7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgb25FbmQpO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICBmdW5jdGlvbiBvbkRhdGEoY2h1bmspIHtcbiAgICAgICAgICAgIHJlY2VpdmVkTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IC0xICYmIHJlY2VpdmVkTGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgbmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtyZWNlaXZlZExlbmd0aH0gdnMuICR7bGltaXR9KWAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkVuZChlcnIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0KHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBkZXRhaWxzOiBlcnIubWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjZWl2ZWRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXh0KHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBkZXRhaWxzOiAncmVjZWl2ZWQgZW1wdHkgdW5hcnkgbWVzc2FnZScgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbC5lbWl0KCdyZWNlaXZlTWVzc2FnZScpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJ5dGVzID0gQnVmZmVyLmNvbmNhdChib2R5LCByZWNlaXZlZExlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gcmVxdWVzdEJ5dGVzLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkID8gZW5jb2RpbmcgOiAnaWRlbnRpdHknO1xuICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VkTWVzc2FnZSA9IGNhbGwuZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShyZXF1ZXN0Qnl0ZXMsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkZWNvbXByZXNzZWRNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGNhbGwuc2FmZURlc2VyaWFsaXplTWVzc2FnZShkZWNvbXByZXNzZWRNZXNzYWdlLCBuZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvbXByZXNzZWRNZXNzYWdlLnRoZW4oKGRlY29tcHJlc3NlZCkgPT4gY2FsbC5zYWZlRGVzZXJpYWxpemVNZXNzYWdlKGRlY29tcHJlc3NlZCwgbmV4dCksIChlcnIpID0+IG5leHQoZXJyLmNvZGVcbiAgICAgICAgICAgICAgICA/IGVyclxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBcImdycGMtZW5jb2RpbmdcIiBoZWFkZXIgXCIke2VuY29kaW5nfVwiIGJ1dCAke2VuY29kaW5nfSBkZWNvbXByZXNzaW9uIGZhaWxlZGAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhZmVEZXNlcmlhbGl6ZU1lc3NhZ2UoYnVmZmVyLCBuZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXh0KG51bGwsIHRoaXMuZGVzZXJpYWxpemVNZXNzYWdlKGJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlcmlhbGl6ZU1lc3NhZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IHRoaXMuaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBDYWxsIGNvbXByZXNzaW9uIGF3YXJlIHNlcmlhbGl6ZU1lc3NhZ2UoKS5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IG1lc3NhZ2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVMZW5ndGggKyA1KTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKGJ5dGVMZW5ndGgsIDEpO1xuICAgICAgICBtZXNzYWdlQnVmZmVyLmNvcHkob3V0cHV0LCA1KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZGVzZXJpYWxpemVNZXNzYWdlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGVzZXJpYWxpemUoYnl0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVW5hcnlNZXNzYWdlKGVyciwgdmFsdWUsIG1ldGFkYXRhLCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsICdtZXRhZGF0YScpICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSywgZGV0YWlsczogJ09LJywgbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRTdGF0dXMoc3RhdHVzT2JqKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbWl0KCdjYWxsRW5kJywgc3RhdHVzT2JqLmNvZGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbUVuZCcsIHN0YXR1c09iai5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spO1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgKyAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xuICAgICAgICAgICAgJyBlbmRlZCB3aXRoIHN0YXR1cyBjb2RlOiAnICtcbiAgICAgICAgICAgIGNvbnN0YW50c18xLlN0YXR1c1tzdGF0dXNPYmouY29kZV0gK1xuICAgICAgICAgICAgJyBkZXRhaWxzOiAnICtcbiAgICAgICAgICAgIHN0YXR1c09iai5kZXRhaWxzKTtcbiAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmVUaW1lcilcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICBpZiAoIXRoaXMud2FudFRyYWlsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLndhbnRUcmFpbGVycyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCd3YW50VHJhaWxlcnMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbih7IFtHUlBDX1NUQVRVU19IRUFERVJdOiBzdGF0dXNPYmouY29kZSwgW0dSUENfTUVTU0FHRV9IRUFERVJdOiBlbmNvZGVVUkkoc3RhdHVzT2JqLmRldGFpbHMpIH0sIChfYSA9IHN0YXR1c09iai5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSHR0cDJIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnNlbmRUcmFpbGVycyh0cmFpbGVyc1RvU2VuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRFcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgIGRldGFpbHM6ICdtZXNzYWdlJyBpbiBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBFcnJvcicsXG4gICAgICAgICAgICBtZXRhZGF0YTogJ21ldGFkYXRhJyBpbiBlcnJvciAmJiBlcnJvci5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBlcnJvci5tZXRhZGF0YVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGVycm9yLmNvZGUpKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgICAgICBpZiAoJ2RldGFpbHMnIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5kZXRhaWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gZXJyb3IuZGV0YWlscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRTdGF0dXMoc3RhdHVzKTtcbiAgICB9XG4gICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSAhPT0gLTEgJiZcbiAgICAgICAgICAgIGNodW5rLmxlbmd0aCA+IHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VudCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtjaHVuay5sZW5ndGh9IHZzLiAke3RoaXMubWF4U2VuZE1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzZW5kTWVzc2FnZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUoY2h1bmspO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICBzZXR1cFN1cmZhY2VDYWxsKGNhbGwpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdjYW5jZWxsZWQnLCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBjYWxsLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uY2UoJ2NhbGxFbmQnLCAoc3RhdHVzKSA9PiBjYWxsLmVtaXQoJ2NhbGxFbmQnLCBzdGF0dXMpKTtcbiAgICB9XG4gICAgc2V0dXBSZWFkYWJsZShyZWFkYWJsZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIoKTtcbiAgICAgICAgbGV0IHJlYWRzRG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBwdXNoZWRFbmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF5YmVQdXNoRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwdXNoZWRFbmQgJiYgcmVhZHNEb25lICYmICFwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7bWVzc2FnZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlY2VpdmVNZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IG1lc3NhZ2UucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkID8gZW5jb2RpbmcgOiAnaWRlbnRpdHknO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmdldERlY29tcHJlc3NlZE1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgLy8gRW5jb3VudGVyZWQgYW4gZXJyb3Igd2l0aCBkZWNvbXByZXNzaW9uOyBpdCdsbCBhbHJlYWR5IGhhdmUgYmVlbiBwcm9wb2dhdGVkIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIGlmICghZGVjb21wcmVzc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgZGVjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICByZWFkc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdW1lVW5wdXNoZWRNZXNzYWdlcyhyZWFkYWJsZSkge1xuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy5tZXNzYWdlc1RvUHVzaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMubWVzc2FnZXNUb1B1c2guc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhblB1c2ggPSByZWFkYWJsZS5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChuZXh0TWVzc2FnZSA9PT0gbnVsbCB8fCBjYW5QdXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhblB1c2g7XG4gICAgfVxuICAgIHB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5pc1B1c2hQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlQnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZWNlaXZlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGFibGUucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2VCeXRlcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRhYmxlLnB1c2goZGVzZXJpYWxpemVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoLnB1c2goZGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgcmVtYWluaW5nIG1lc3NhZ2VzIHdoZW4gZXJyb3JzIG9jY3VyLlxuICAgICAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoISgnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGVycm9yLmNvZGUpICYmXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA+PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlIDw9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFVVEhFTlRJQ0FURUQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGNvZGUgaXMgbm90IGEgdmFsaWQgZ1JQQyBjb2RlIHNvIGl0cyBiZWluZyBvdmVyd3JpdHRlbi5cbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGFibGUuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuc3RyZWFtLnNlc3Npb24uc29ja2V0O1xuICAgICAgICBpZiAoc29ja2V0LnJlbW90ZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucmVtb3RlUG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzb2NrZXQucmVtb3RlQWRkcmVzc306JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVhZGxpbmU7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU2VydmVyQ2FsbFN0cmVhbSA9IEh0dHAyU2VydmVyQ2FsbFN0cmVhbTtcbmZ1bmN0aW9uIGhhbmRsZUV4cGlyZWREZWFkbGluZShjYWxsKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdEZWFkbGluZSBleGNlZWRlZCcpO1xuICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVEO1xuICAgIGNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgY2FsbC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGNhbGwuZW1pdCgnY2FuY2VsbGVkJywgJ2RlYWRsaW5lJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError('rootCerts must be null or a Buffer');\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError('keyCertPairs must be an array');\n        }\n        if (typeof checkClientCertificate !== 'boolean') {\n            throw new TypeError('checkClientCertificate must be a boolean');\n        }\n        const cert = [];\n        const key = [];\n        for (let i = 0; i < keyCertPairs.length; i++) {\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== 'object') {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || tls_helpers_1.getDefaultRootsData() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options) {\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n}\n//# sourceMappingURL=server-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanM/ZDEzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcbmNsYXNzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscygpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywga2V5Q2VydFBhaXJzLCBjaGVja0NsaWVudENlcnRpZmljYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvb3RDZXJ0cyBtdXN0IGJlIG51bGwgb3IgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5Q2VydFBhaXJzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q2VydFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xuICAgICAgICAgICAgaWYgKHBhaXIgPT09IG51bGwgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0gbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIucHJpdmF0ZV9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0ucHJpdmF0ZV9rZXkgbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5jZXJ0X2NoYWluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLmNlcnRfY2hhaW4gbXVzdCBiZSBhIEJ1ZmZlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VydC5wdXNoKHBhaXIuY2VydF9jaGFpbik7XG4gICAgICAgICAgICBrZXkucHVzaChwYWlyLnByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKHtcbiAgICAgICAgICAgIGNhOiByb290Q2VydHMgfHwgdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjaGVja0NsaWVudENlcnRpZmljYXRlLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gU2VydmVyQ3JlZGVudGlhbHM7XG5jbGFzcyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() { }\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`,\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch (handlerType) {\n        case 'unary':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options) {\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.serverAddressString = 'null';\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Server created');\n        }\n        this.trace('Server constructed');\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return () => {\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n                    remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n                };\n            }\n            else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (service === null ||\n            typeof service !== 'object' ||\n            implementation === null ||\n            typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach((name) => {\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                }\n                else {\n                    methodType = 'clientStream';\n                }\n            }\n            else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                }\n                else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            }\n            else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== 'object') {\n            throw new Error('removeService() requires object as argument');\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name) => {\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError('creds must be a ServerCredentials object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const initialPortUri = uri_parser_1.parseUri(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n        };\n        if ('grpc-node.max_session_memory' in this.options) {\n            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        }\n        else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */\n            serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n            };\n        }\n        const deferredCallback = (error, port) => {\n            process.nextTick(() => callback(error, port));\n        };\n        const setupServer = () => {\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on('secureConnection', (socket) => {\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */\n                    socket.on('error', (e) => {\n                        this.trace('An incoming TLS connection closed with error: ' + e.message);\n                    });\n                });\n            }\n            else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: portNum, count: previousCount });\n            }\n            return Promise.all(addressList.map((address) => {\n                this.trace('Attempting to bind ' + subchannel_address_1.subchannelAddressToString(address));\n                let addr;\n                if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum,\n                    };\n                }\n                else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject) => {\n                    const onError = (err) => {\n                        this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once('error', onError);\n                    http2Server.listen(addr, () => {\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === 'string') {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        }\n                        else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        let channelzRef;\n                        channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({ server: http2Server, channelzRef: channelzRef });\n                        this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                        resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            })).then((results) => {\n                let count = 0;\n                for (const result of results) {\n                    if (typeof result === 'number') {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error('Invalid state: multiple port numbers added from single address');\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount,\n                };\n            });\n        };\n        const bindWildcardPort = (addressList) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: 0, count: 0 });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject) => {\n                const onError = (err) => {\n                    this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once('error', onError);\n                http2Server.listen(address, () => {\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    let channelzRef;\n                    channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({ server: http2Server, channelzRef: channelzRef });\n                    this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener('error', onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = () => { };\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    }\n                    else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                }\n                else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult) => {\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    }\n                    else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error) => {\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error) => {\n                deferredCallback(new Error(error.details), 0);\n            },\n        };\n        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {\n            if (http2Server.listening) {\n                http2Server.close(() => {\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session) => {\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name,\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 ||\n            this.http2ServerList.every(({ server: http2Server }) => http2Server.listening !== true)) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Starting');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error) => {\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(() => {\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session) => {\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== 'string' ||\n            !contentType.startsWith('application/grpc')) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n            }, { endStream: true });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(headers) {\n        const path = headers[HTTP2_HEADER_PATH];\n        this.trace('Received call to method ' +\n            path +\n            ' at address ' +\n            this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace('No handler registered for method ' +\n                path +\n                '. Sending UNIMPLEMENTED status.');\n            throw getUnimplementedStatusResponse(path);\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        }\n        catch (err) {\n            this._respondWithError(err, stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once('callEnd', (code) => {\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            }\n            else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once('streamEnd', (success) => {\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                }\n                else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on('sendMessage', () => {\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on('receiveMessage', () => {\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        }\n        catch (err) {\n            this._respondWithError(err, stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n        metadata.remove('grpc-encoding');\n        const { type } = handler;\n        if (type === 'unary') {\n            handleUnary(call, handler, metadata, encoding);\n        }\n        else if (type === 'clientStream') {\n            handleClientStreaming(call, handler, metadata, encoding);\n        }\n        else if (type === 'serverStream') {\n            handleServerStreaming(call, handler, metadata, encoding);\n        }\n        else if (type === 'bidi') {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        }\n        else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n        if (serverAddress) {\n            if (typeof serverAddress === 'string') {\n                serverAddressString = serverAddress;\n            }\n            else {\n                serverAddressString =\n                    serverAddress.address + ':' + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled\n            ? this._channelzHandler\n            : this._streamHandler;\n        http2Server.on('stream', handler.bind(this));\n        http2Server.on('session', (session) => {\n            var _a;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            let channelzRef;\n            channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            session.on('close', () => {\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    channelz_1.unregisterChannelzRef(channelzRef);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request) => {\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags) => {\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request) => {\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n}\n//# sourceMappingURL=server.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3Qyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFDQUFxQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELCtDQUErQztBQUNuRztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELCtDQUErQztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsb0JBQW9CO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsa0JBQWtCLCtCQUErQixvQkFBb0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHlFQUF5RSxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzPzFjZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHNlcnZlcl9jYWxsXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY2FsbFwiKTtcbmNvbnN0IHNlcnZlcl9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCB7IEhUVFAyX0hFQURFUl9QQVRIIH0gPSBodHRwMi5jb25zdGFudHM7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzZXJ2ZXInO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgZGV0YWlsczogYFRoZSBzZXJ2ZXIgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBtZXRob2QgJHttZXRob2ROYW1lfWAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRIYW5kbGVyKGhhbmRsZXJUeXBlLCBtZXRob2ROYW1lKSB7XG4gICAgY29uc3QgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlID0gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpO1xuICAgIHN3aXRjaCAoaGFuZGxlclR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5hcnknOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdjbGllbnRTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzZXJ2ZXJTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdlcnJvcicsIHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiaWRpJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgnZXJyb3InLCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBoYW5kbGVyVHlwZSAke2hhbmRsZXJUeXBlfWApO1xuICAgIH1cbn1cbmNsYXNzIFNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmh0dHAyU2VydmVyTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICAvLyBDaGFubmVseiBJbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNlcnZlcigoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1NlcnZlciBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnU2VydmVyIGNvbnN0cnVjdGVkJyk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGxpc3RlbmVyQ2hpbGRyZW46IHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgc2Vzc2lvbkNoaWxkcmVuOiB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENoYW5uZWx6U2Vzc2lvbkluZm9HZXR0ZXIoc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHNlc3Npb24uc29ja2V0O1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcyA/IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3Moc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzID8gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB0bHNJbmZvO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gc2Vzc2lvblNvY2tldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVlckNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIHRsc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVPdGhlck5hbWU6IGNpcGhlckluZm8uc3RhbmRhcmROYW1lID8gbnVsbCA6IGNpcGhlckluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogKGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlKSA/IGNlcnRpZmljYXRlLnJhdyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiAocGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZSkgPyBwZWVyQ2VydGlmaWNhdGUucmF3IDogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiBzZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogc2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSBzZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0SW5mbztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdGV4dCk7XG4gICAgfVxuICAgIGFkZFByb3RvU2VydmljZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuIFVzZSBhZGRTZXJ2aWNlKCkgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBhZGRTZXJ2aWNlKHNlcnZpY2UsIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlID09PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2Ygc2VydmljZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgaW1wbGVtZW50YXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFNlcnZpY2UoKSByZXF1aXJlcyB0d28gb2JqZWN0cyBhcyBhcmd1bWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xuICAgICAgICBpZiAoc2VydmljZUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYW4gZW1wdHkgc2VydmljZSB0byBhIHNlcnZlcicpO1xuICAgICAgICB9XG4gICAgICAgIHNlcnZpY2VLZXlzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gc2VydmljZVtuYW1lXTtcbiAgICAgICAgICAgIGxldCBtZXRob2RUeXBlO1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50U3RyZWFtJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJTdHJlYW0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICd1bmFyeSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGltcGxGbiA9IGltcGxlbWVudGF0aW9uW25hbWVdO1xuICAgICAgICAgICAgbGV0IGltcGw7XG4gICAgICAgICAgICBpZiAoaW1wbEZuID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGF0dHJzLm9yaWdpbmFsTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbXBsRm4gPSBpbXBsZW1lbnRhdGlvblthdHRycy5vcmlnaW5hbE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltcGxGbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW1wbCA9IGltcGxGbi5iaW5kKGltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcGwgPSBnZXREZWZhdWx0SGFuZGxlcihtZXRob2RUeXBlLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLnJlZ2lzdGVyKGF0dHJzLnBhdGgsIGltcGwsIGF0dHJzLnJlc3BvbnNlU2VyaWFsaXplLCBhdHRycy5yZXF1ZXN0RGVzZXJpYWxpemUsIG1ldGhvZFR5cGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2QgaGFuZGxlciBmb3IgJHthdHRycy5wYXRofSBhbHJlYWR5IHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlU2VydmljZShzZXJ2aWNlKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlID09PSBudWxsIHx8IHR5cGVvZiBzZXJ2aWNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVTZXJ2aWNlKCkgcmVxdWlyZXMgb2JqZWN0IGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmljZUtleXMgPSBPYmplY3Qua2V5cyhzZXJ2aWNlKTtcbiAgICAgICAgc2VydmljZUtleXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGF0dHJzLnBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmluZChwb3J0LCBjcmVkcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVXNlIGJpbmRBc3luYygpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYmluZEFzeW5jKHBvcnQsIGNyZWRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBvcnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwb3J0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlZHMgPT09IG51bGwgfHwgIShjcmVkcyBpbnN0YW5jZW9mIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY3JlZHMgbXVzdCBiZSBhIFNlcnZlckNyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3J0VXJpID0gdXJpX3BhcnNlcl8xLnBhcnNlVXJpKHBvcnQpO1xuICAgICAgICBpZiAoaW5pdGlhbFBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3J0VXJpID0gcmVzb2x2ZXJfMS5tYXBVcmlEZWZhdWx0U2NoZW1lKGluaXRpYWxQb3J0VXJpKTtcbiAgICAgICAgaWYgKHBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBhIGRlZmF1bHQgc2NoZW1lIGZvciBwb3J0IFwiJHtwb3J0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeScgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBzZXJ2ZXJPcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSB0aGlzLm9wdGlvbnNbJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEJ5IGRlZmF1bHQsIHNldCBhIHZlcnkgbGFyZ2UgbWF4IHNlc3Npb24gbWVtb3J5IGxpbWl0LCB0byBlZmZlY3RpdmVseVxuICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAqIGJlaGF2aW9yIGRlZ3JhZGVzIGJhZGx5IHdoZW4gdGhpcyBsaW1pdCBpcyByZWFjaGVkLCBzbyB3ZSBzb2x2ZSB0aGF0XG4gICAgICAgICAgICAgKiBieSBkaXNhYmxpbmcgdGhlIGNoZWNrIGVudGlyZWx5LiAqL1xuICAgICAgICAgICAgc2VydmVyT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgc2VydmVyT3B0aW9ucy5zZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50U3RyZWFtczogdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmZXJyZWRDYWxsYmFjayA9IChlcnJvciwgcG9ydCkgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBjYWxsYmFjayhlcnJvciwgcG9ydCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXR1cFNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBodHRwMlNlcnZlcjtcbiAgICAgICAgICAgIGlmIChjcmVkcy5faXNTZWN1cmUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3VyZVNlcnZlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHNlcnZlck9wdGlvbnMsIGNyZWRzLl9nZXRTZXR0aW5ncygpKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlY3VyZVNlcnZlcihzZWN1cmVTZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc2VjdXJlQ29ubmVjdGlvbicsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlc2UgZXJyb3JzIG5lZWQgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXNlciBvZiBIdHRwMlNlY3VyZVNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICogYWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU4MjQgKi9cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdBbiBpbmNvbWluZyBUTFMgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvcjogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIgPSBodHRwMi5jcmVhdGVTZXJ2ZXIoc2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodHRwMlNlcnZlci5zZXRUaW1lb3V0KDAsIG5vb3ApO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gaHR0cDJTZXJ2ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpbmRTcGVjaWZpY1BvcnQgPSAoYWRkcmVzc0xpc3QsIHBvcnROdW0sIHByZXZpb3VzQ291bnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcG9ydDogcG9ydE51bSwgY291bnQ6IHByZXZpb3VzQ291bnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYWRkcmVzc0xpc3QubWFwKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQXR0ZW1wdGluZyB0byBiaW5kICcgKyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogYWRkcmVzcy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogcG9ydE51bSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHIgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBodHRwMlNlcnZlciA9IHNldHVwU2VydmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBiaW5kICcgKyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpICsgJyB3aXRoIGVycm9yICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmxpc3RlbihhZGRyLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZEFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm91bmRTdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYm91bmRBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGJvdW5kQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5uZWx6UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogYm91bmRTdWJjaGFubmVsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goeyBzZXJ2ZXI6IGh0dHAyU2VydmVyLCBjaGFubmVselJlZjogY2hhbm5lbHpSZWYgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYm91bmRTdWJjaGFubmVsQWRkcmVzcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgncG9ydCcgaW4gYm91bmRTdWJjaGFubmVsQWRkcmVzcyA/IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MucG9ydCA6IHBvcnROdW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gcG9ydE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogbXVsdGlwbGUgcG9ydCBudW1iZXJzIGFkZGVkIGZyb20gc2luZ2xlIGFkZHJlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0TnVtLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKyBwcmV2aW91c0NvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmluZFdpbGRjYXJkUG9ydCA9IChhZGRyZXNzTGlzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBwb3J0OiAwLCBjb3VudDogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzTGlzdFswXTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gc2V0dXBTZXJ2ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcykgKyAnIHdpdGggZXJyb3IgJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShiaW5kV2lsZGNhcmRQb3J0KGFkZHJlc3NMaXN0LnNsaWNlKDEpKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmxpc3RlbihhZGRyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGJvdW5kQWRkcmVzcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5uZWx6UmVmO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldChzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogYm91bmRTdWJjaGFubmVsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goeyBzZXJ2ZXI6IGh0dHAyU2VydmVyLCBjaGFubmVselJlZjogY2hhbm5lbHpSZWYgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1N1Y2Nlc3NmdWxseSBib3VuZCAnICsgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdC5zbGljZSgxKSwgYm91bmRBZGRyZXNzLnBvcnQsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uZSByZXNvbHV0aW9uIHJlc3VsdC4gRGlzY2FyZCBhbGwgZnV0dXJlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXNvbHZlckxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihgTm8gYWRkcmVzc2VzIHJlc29sdmVkIGZvciBwb3J0ICR7cG9ydH1gKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJpbmRSZXN1bHRQcm9taXNlO1xuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3NMaXN0WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3RbMF0ucG9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kV2lsZGNhcmRQb3J0KGFkZHJlc3NMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlID0gYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdCwgYWRkcmVzc0xpc3RbMF0ucG9ydCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhbiBhcmJpdHJhcnkgbm9uLXplcm8gcG9ydCBmb3Igbm9uLVRDUCBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kU3BlY2lmaWNQb3J0KGFkZHJlc3NMaXN0LCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UudGhlbigoYmluZFJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZFJlc3VsdC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSBgTm8gYWRkcmVzcyBhZGRlZCBvdXQgb2YgdG90YWwgJHthZGRyZXNzTGlzdC5sZW5ndGh9IHJlc29sdmVkYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JTdHJpbmcpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5kUmVzdWx0LmNvdW50IDwgYWRkcmVzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sIGBXQVJOSU5HIE9ubHkgJHtiaW5kUmVzdWx0LmNvdW50fSBhZGRyZXNzZXMgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhudWxsLCBiaW5kUmVzdWx0LnBvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gYE5vIGFkZHJlc3MgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGA7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihlcnJvclN0cmluZyksIDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yLmRldGFpbHMpLCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcihwb3J0VXJpLCByZXNvbHZlckxpc3RlbmVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICByZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgfVxuICAgIGZvcmNlU2h1dGRvd24oKSB7XG4gICAgICAgIC8vIENsb3NlIHRoZSBzZXJ2ZXIgaWYgaXQgaXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgZm9yIChjb25zdCB7IHNlcnZlcjogaHR0cDJTZXJ2ZXIsIGNoYW5uZWx6UmVmOiByZWYgfSBvZiB0aGlzLmh0dHAyU2VydmVyTGlzdCkge1xuICAgICAgICAgICAgaWYgKGh0dHAyU2VydmVyLmxpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQWx3YXlzIGRlc3Ryb3kgYW55IGF2YWlsYWJsZSBzZXNzaW9ucy4gSXQncyBwb3NzaWJsZSB0aGF0IG9uZSBvciBtb3JlXG4gICAgICAgIC8vIHRyeVNodXRkb3duKCkgY2FsbHMgYXJlIGluIHByb2dyZXNzLiBEb24ndCB3YWl0IG9uIHRoZW0gdG8gZmluaXNoLlxuICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKGNoYW5uZWx6SW5mbywgc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgLy8gQ2FzdCBOR0hUVFAyX0NBTkNFTCB0byBhbnkgYmVjYXVzZSBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2VlbSB0b1xuICAgICAgICAgICAgLy8gcmVjb2duaXplIGRlc3Ryb3koY29kZSkgYXMgYSB2YWxpZCBzaWduYXR1cmUuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlc3Npb25zLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXIobmFtZSwgaGFuZGxlciwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXJzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBmdW5jOiBoYW5kbGVyLFxuICAgICAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICAgICAgZGVzZXJpYWxpemUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogbmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTZXJ2ZXJMaXN0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlckxpc3QuZXZlcnkoKHsgc2VydmVyOiBodHRwMlNlcnZlciB9KSA9PiBodHRwMlNlcnZlci5saXN0ZW5pbmcgIT09IHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBtdXN0IGJlIGJvdW5kIGluIG9yZGVyIHRvIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgaXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3RhcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0cnlTaHV0ZG93bihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcGVuZGluZ0NoZWNrcyA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBwZW5kaW5nQ2hlY2tzLS07XG4gICAgICAgICAgICBpZiAocGVuZGluZ0NoZWNrcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlIHRoZSBzZXJ2ZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHNlcnZlcjogaHR0cDJTZXJ2ZXIsIGNoYW5uZWx6UmVmOiByZWYgfSBvZiB0aGlzLmh0dHAyU2VydmVyTGlzdCkge1xuICAgICAgICAgICAgaWYgKGh0dHAyU2VydmVyLmxpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdDaGVja3MrKztcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKGNoYW5uZWx6SW5mbywgc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdDaGVja3MgKz0gMTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKG1heWJlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBlbmRpbmdDaGVja3MgPT09IDApIHtcbiAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEh0dHAyUG9ydCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBzZXJ2ZXIuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgc2VydmVyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBfdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVyc1todHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV07XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudFR5cGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhY29udGVudFR5cGUuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vZ3JwYycpKSB7XG4gICAgICAgICAgICBzdHJlYW0ucmVzcG9uZCh7XG4gICAgICAgICAgICAgICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfU1RBVFVTXTogaHR0cDIuY29uc3RhbnRzLkhUVFBfU1RBVFVTX1VOU1VQUE9SVEVEX01FRElBX1RZUEUsXG4gICAgICAgICAgICB9LCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3JldHJpZXZlSGFuZGxlcihoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgY2FsbCB0byBtZXRob2QgJyArXG4gICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICcgYXQgYWRkcmVzcyAnICtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQWRkcmVzc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnTm8gaGFuZGxlciByZWdpc3RlcmVkIGZvciBtZXRob2QgJyArXG4gICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgJy4gU2VuZGluZyBVTklNUExFTUVOVEVEIHN0YXR1cy4nKTtcbiAgICAgICAgICAgIHRocm93IGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgX3Jlc3BvbmRXaXRoRXJyb3IoZXJyLCBzdHJlYW0sIGNoYW5uZWx6U2Vzc2lvbkluZm8gPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgc2VydmVyX2NhbGxfMS5IdHRwMlNlcnZlckNhbGxTdHJlYW0oc3RyZWFtLCBudWxsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIH1cbiAgICBfY2hhbm5lbHpIYW5kbGVyKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc3RyZWFtLnNlc3Npb24pO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5fcmV0cmlldmVIYW5kbGVyKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRXaXRoRXJyb3IoZXJyLCBzdHJlYW0sIGNoYW5uZWx6U2Vzc2lvbkluZm8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgc2VydmVyX2NhbGxfMS5IdHRwMlNlcnZlckNhbGxTdHJlYW0oc3RyZWFtLCBoYW5kbGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBjYWxsLm9uY2UoJ2NhbGxFbmQnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbm5lbHpTZXNzaW9uSW5mbykge1xuICAgICAgICAgICAgY2FsbC5vbmNlKCdzdHJlYW1FbmQnLCAoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbC5vbignc2VuZE1lc3NhZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGwub24oJ3JlY2VpdmVNZXNzYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIsIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIGNhbGwuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFVua25vd24gaGFuZGxlciB0eXBlOiAke2hhbmRsZXIudHlwZX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RyZWFtSGFuZGxlcihzdHJlYW0sIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9yZXRyaWV2ZUhhbmRsZXIoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZFdpdGhFcnJvcihlcnIsIHN0cmVhbSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbCA9IG5ldyBzZXJ2ZXJfY2FsbF8xLkh0dHAyU2VydmVyQ2FsbFN0cmVhbShzdHJlYW0sIGhhbmRsZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5fcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlciwgaGVhZGVycykpIHtcbiAgICAgICAgICAgIGNhbGwuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFVua25vd24gaGFuZGxlciB0eXBlOiAke2hhbmRsZXIudHlwZX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlciwgaGVhZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY2FsbC5yZWNlaXZlTWV0YWRhdGEoaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gKF9hID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJylbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdpZGVudGl0eSc7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGhhbmRsZXI7XG4gICAgICAgIGlmICh0eXBlID09PSAndW5hcnknKSB7XG4gICAgICAgICAgICBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjbGllbnRTdHJlYW0nKSB7XG4gICAgICAgICAgICBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2VydmVyU3RyZWFtJykge1xuICAgICAgICAgICAgaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZGknKSB7XG4gICAgICAgICAgICBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9zZXR1cEhhbmRsZXJzKGh0dHAyU2VydmVyKSB7XG4gICAgICAgIGlmIChodHRwMlNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICBpZiAoc2VydmVyQWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3MuYWRkcmVzcyArICc6JyArIHNlcnZlckFkZHJlc3MucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzU3RyaW5nO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5jaGFubmVsekVuYWJsZWRcbiAgICAgICAgICAgID8gdGhpcy5fY2hhbm5lbHpIYW5kbGVyXG4gICAgICAgICAgICA6IHRoaXMuX3N0cmVhbUhhbmRsZXI7XG4gICAgICAgIGh0dHAyU2VydmVyLm9uKCdzdHJlYW0nLCBoYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICBodHRwMlNlcnZlci5vbignc2Vzc2lvbicsIChzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGFubmVselJlZjtcbiAgICAgICAgICAgIGNoYW5uZWx6UmVmID0gY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KChfYSA9IHNlc3Npb24uc29ja2V0LnJlbW90ZUFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1bmtub3duJywgdGhpcy5nZXRDaGFubmVselNlc3Npb25JbmZvR2V0dGVyKHNlc3Npb24pLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0ge1xuICAgICAgICAgICAgICAgIHJlZjogY2hhbm5lbHpSZWYsXG4gICAgICAgICAgICAgICAgc3RyZWFtVHJhY2tlcjogbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5zZXQoc2Vzc2lvbiwgY2hhbm5lbHpTZXNzaW9uSW5mbyk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRBZGRyZXNzID0gc2Vzc2lvbi5zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGVzdGFibGlzaGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmZ1bmN0aW9uIGhhbmRsZVVuYXJ5KGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNhbGwucmVjZWl2ZVVuYXJ5TWVzc2FnZShlbmNvZGluZywgKGVyciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQgfHwgY2FsbC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyVW5hcnlDYWxsSW1wbChjYWxsLCBtZXRhZGF0YSwgcmVxdWVzdCk7XG4gICAgICAgIGhhbmRsZXIuZnVuYyhlbWl0dGVyLCAoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpID0+IHtcbiAgICAgICAgICAgIGNhbGwuc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xpZW50U3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbChjYWxsLCBtZXRhZGF0YSwgaGFuZGxlci5kZXNlcmlhbGl6ZSwgZW5jb2RpbmcpO1xuICAgIGZ1bmN0aW9uIHJlc3BvbmQoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgY2FsbC5zZW5kVW5hcnlNZXNzYWdlKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlc3BvbmQpO1xuICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0sIHJlc3BvbmQpO1xufVxuZnVuY3Rpb24gaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNhbGwucmVjZWl2ZVVuYXJ5TWVzc2FnZShlbmNvZGluZywgKGVyciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQgfHwgY2FsbC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuc2VyaWFsaXplLCByZXF1ZXN0KTtcbiAgICAgICAgaGFuZGxlci5mdW5jKHN0cmVhbSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlckR1cGxleFN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuc2VyaWFsaXplLCBoYW5kbGVyLmRlc2VyaWFsaXplLCBlbmNvZGluZyk7XG4gICAgaWYgKGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlci5mdW5jKHN0cmVhbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = __webpack_require__(/*! os */ \"os\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n    if (!('service' in obj) || typeof obj.service !== 'string') {\n        throw new Error('Invalid method config name: invalid service');\n    }\n    const result = {\n        service: obj.service,\n    };\n    if ('method' in obj) {\n        if (typeof obj.method === 'string') {\n            result.method = obj.method;\n        }\n        else {\n            throw new Error('Invalid method config name: invalid method');\n        }\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: [],\n    };\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\n        throw new Error('Invalid method config: invalid name array');\n    }\n    for (const name of obj.name) {\n        result.name.push(validateName(name));\n    }\n    if ('waitForReady' in obj) {\n        if (typeof obj.waitForReady !== 'boolean') {\n            throw new Error('Invalid method config: invalid waitForReady');\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if ('timeout' in obj) {\n        if (typeof obj.timeout === 'object') {\n            if (!('seconds' in obj.timeout) ||\n                !(typeof obj.timeout.seconds === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.seconds');\n            }\n            if (!('nanos' in obj.timeout) ||\n                !(typeof obj.timeout.nanos === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.nanos');\n            }\n            result.timeout = obj.timeout;\n        }\n        else if (typeof obj.timeout === 'string' &&\n            TIMEOUT_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout\n                .substring(0, obj.timeout.length - 1)\n                .split('.');\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,\n            };\n        }\n        else {\n            throw new Error('Invalid method config: invalid timeout');\n        }\n    }\n    if ('maxRequestBytes' in obj) {\n        if (typeof obj.maxRequestBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if ('maxResponseBytes' in obj) {\n        if (typeof obj.maxResponseBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    return result;\n}\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n    };\n    if ('loadBalancingPolicy' in obj) {\n        if (typeof obj.loadBalancingPolicy === 'string') {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\n        }\n    }\n    if ('loadBalancingConfig' in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig) {\n                result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));\n            }\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\n        }\n    }\n    if ('methodConfig' in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig) {\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig) {\n        for (const name of methodConfig.name) {\n            for (const seenName of seenMethodNames) {\n                if (name.service === seenName.service &&\n                    name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!('serviceConfig' in obj)) {\n        throw new Error('Invalid service config choice: missing service config');\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\n    };\n    if ('clientLanguage' in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage) {\n                if (typeof lang === 'string') {\n                    result.clientLanguage.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n    }\n    if ('clientHostname' in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname) {\n                if (typeof lang === 'string') {\n                    result.clientHostname.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientHostname');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n    }\n    if ('percentage' in obj) {\n        if (typeof obj.percentage === 'number' &&\n            0 <= obj.percentage &&\n            obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid percentage');\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        'clientLanguage',\n        'percentage',\n        'clientHostname',\n        'serviceConfig',\n    ];\n    for (const field in obj) {\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error('Invalid service config list');\n    }\n    for (const config of obj) {\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */\n        if (typeof validatedConfig.percentage === 'number' &&\n            percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname) {\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage) {\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord) {\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n            const recordString = record.join('').substring('grpc_config='.length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\n//# sourceMappingURL=service-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUMsR0FBRyw2QkFBNkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxhQUFhLEdBQUcsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZpY2UtY29uZmlnLmpzP2NiYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZvaWQgMDtcbi8qIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGdSRkMgQTIgYW5kIHRoZSBzZXJ2aWNlIGNvbmZpZyBzcGVjOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTItc2VydmljZS1jb25maWdzLWluLWRucy5tZFxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2Mvc2VydmljZV9jb25maWcubWQuIEVhY2hcbiAqIGZ1bmN0aW9uIGhlcmUgdGFrZXMgYW4gb2JqZWN0IHdpdGggdW5rbm93biBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgaXRzXG4gKiBzcGVjaWZpYyBvYmplY3QgdHlwZSBpZiB0aGUgaW5wdXQgaGFzIHRoZSByaWdodCBzdHJ1Y3R1cmUsIGFuZCB0aHJvd3MgYW5cbiAqIGVycm9yIG90aGVyd2lzZS4gKi9cbi8qIFRoZSBhbnkgdHlwZSBpcyBwdXJwb3NlbHkgdXNlZCBoZXJlLiBBbGwgZnVuY3Rpb25zIHZhbGlkYXRlIHRoZWlyIGlucHV0IGF0XG4gKiBydW50aW1lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG4vKipcbiAqIFJlY29nbml6ZXMgYSBudW1iZXIgd2l0aCB1cCB0byA5IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZm9sbG93ZWQgYnlcbiAqIGFuIFwic1wiLCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuY29uc3QgVElNRU9VVF9SRUdFWCA9IC9eXFxkKyhcXC5cXGR7MSw5fSk/cyQvO1xuLyoqXG4gKiBDbGllbnQgbGFuZ3VhZ2UgbmFtZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY2xpZW50IG1hdGNoZXMgYVxuICogYFNlcnZpY2VDb25maWdDYW5hcnlDb25maWdgJ3MgYGNsaWVudExhbmd1YWdlYCBsaXN0LlxuICovXG5jb25zdCBDTElFTlRfTEFOR1VBR0VfU1RSSU5HID0gJ25vZGUnO1xuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKG9iaikge1xuICAgIGlmICghKCdzZXJ2aWNlJyBpbiBvYmopIHx8IHR5cGVvZiBvYmouc2VydmljZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBzZXJ2aWNlJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VydmljZTogb2JqLnNlcnZpY2UsXG4gICAgfTtcbiAgICBpZiAoJ21ldGhvZCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXRob2QgPSBvYmoubWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBtZXRob2QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RDb25maWcob2JqKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogW10sXG4gICAgfTtcbiAgICBpZiAoISgnbmFtZScgaW4gb2JqKSB8fCAhQXJyYXkuaXNBcnJheShvYmoubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbmFtZSBhcnJheScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb2JqLm5hbWUpIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUucHVzaCh2YWxpZGF0ZU5hbWUobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoJ3dhaXRGb3JSZWFkeScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLndhaXRGb3JSZWFkeSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB3YWl0Rm9yUmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdEZvclJlYWR5ID0gb2JqLndhaXRGb3JSZWFkeTtcbiAgICB9XG4gICAgaWYgKCd0aW1lb3V0JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICghKCdzZWNvbmRzJyBpbiBvYmoudGltZW91dCkgfHxcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBvYmoudGltZW91dC5zZWNvbmRzID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0LnNlY29uZHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKCduYW5vcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQubmFub3MgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQubmFub3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0gb2JqLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iai50aW1lb3V0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgVElNRU9VVF9SRUdFWC50ZXN0KG9iai50aW1lb3V0KSkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFBhcnRzID0gb2JqLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIG9iai50aW1lb3V0Lmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IHtcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiB0aW1lb3V0UGFydHNbMF0gfCAwLFxuICAgICAgICAgICAgICAgIG5hbm9zOiAoKF9hID0gdGltZW91dFBhcnRzWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSB8IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWF4UmVxdWVzdEJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVxdWVzdEJ5dGVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbWF4UmVxdWVzdEJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1heFJlcXVlc3RCeXRlcyA9IG9iai5tYXhSZXF1ZXN0Qnl0ZXM7XG4gICAgfVxuICAgIGlmICgnbWF4UmVzcG9uc2VCeXRlcycgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlc3BvbnNlQnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVzcG9uc2VCeXRlcyA9IG9iai5tYXhSZXNwb25zZUJ5dGVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTZXJ2aWNlQ29uZmlnKG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbG9hZEJhbGFuY2luZ0NvbmZpZzogW10sXG4gICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgfTtcbiAgICBpZiAoJ2xvYWRCYWxhbmNpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5sb2FkQmFsYW5jaW5nUG9saWN5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0LmxvYWRCYWxhbmNpbmdQb2xpY3kgPSBvYmoubG9hZEJhbGFuY2luZ1BvbGljeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nUG9saWN5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nQ29uZmlnJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmxvYWRCYWxhbmNpbmdDb25maWcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmoubG9hZEJhbGFuY2luZ0NvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nQ29uZmlnLnB1c2gobG9hZF9iYWxhbmNlcl8xLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyhjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2Ygb2JqLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBtZXRob2QgbmFtZSB1bmlxdWVuZXNzXG4gICAgY29uc3Qgc2Vlbk1ldGhvZE5hbWVzID0gW107XG4gICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2YgcmVzdWx0Lm1ldGhvZENvbmZpZykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWV0aG9kQ29uZmlnLm5hbWUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vlbk5hbWUgb2Ygc2Vlbk1ldGhvZE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc2VydmljZSA9PT0gc2Vlbk5hbWUuc2VydmljZSAmJlxuICAgICAgICAgICAgICAgICAgICBuYW1lLm1ldGhvZCA9PT0gc2Vlbk5hbWUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogZHVwbGljYXRlIG5hbWUgJHtuYW1lLnNlcnZpY2V9LyR7bmFtZS5tZXRob2R9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbk1ldGhvZE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudmFsaWRhdGVTZXJ2aWNlQ29uZmlnID0gdmFsaWRhdGVTZXJ2aWNlQ29uZmlnO1xuZnVuY3Rpb24gdmFsaWRhdGVDYW5hcnlDb25maWcob2JqKSB7XG4gICAgaWYgKCEoJ3NlcnZpY2VDb25maWcnIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogbWlzc2luZyBzZXJ2aWNlIGNvbmZpZycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlcnZpY2VDb25maWc6IHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmouc2VydmljZUNvbmZpZyksXG4gICAgfTtcbiAgICBpZiAoJ2NsaWVudExhbmd1YWdlJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmcgb2Ygb2JqLmNsaWVudExhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50TGFuZ3VhZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdjbGllbnRIb3N0bmFtZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRIb3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudEhvc3RuYW1lLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgncGVyY2VudGFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAwIDw9IG9iai5wZXJjZW50YWdlICYmXG4gICAgICAgICAgICBvYmoucGVyY2VudGFnZSA8PSAxMDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50YWdlID0gb2JqLnBlcmNlbnRhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIHBlcmNlbnRhZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGF0IG5vIHVuZXhwZWN0ZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gICAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFtcbiAgICAgICAgJ2NsaWVudExhbmd1YWdlJyxcbiAgICAgICAgJ3BlcmNlbnRhZ2UnLFxuICAgICAgICAnY2xpZW50SG9zdG5hbWUnLFxuICAgICAgICAnc2VydmljZUNvbmZpZycsXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG9iaikge1xuICAgICAgICBpZiAoIWFsbG93ZWRGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiB1bmV4cGVjdGVkIGZpZWxkICR7ZmllbGR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnKG9iaiwgcGVyY2VudGFnZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBsaXN0Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG9iaikge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRDb25maWcgPSB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhjb25maWcpO1xuICAgICAgICAvKiBGb3IgZWFjaCBmaWVsZCwgd2UgY2hlY2sgaWYgaXQgaXMgcHJlc2VudCwgdGhlbiBvbmx5IGRpc2NhcmQgdGhlXG4gICAgICAgICAqIGNvbmZpZyBpZiB0aGUgZmllbGQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgY2xpZW50ICovXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBwZXJjZW50YWdlID4gdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBob3N0bmFtZU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RuYW1lID09PSBvcy5ob3N0bmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFob3N0bmFtZU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICBsZXQgbGFuZ3VhZ2VNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSA9PT0gQ0xJRU5UX0xBTkdVQUdFX1NUUklORykge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2VNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZENvbmZpZy5zZXJ2aWNlQ29uZmlnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hdGNoaW5nIHNlcnZpY2UgY29uZmlnIGZvdW5kJyk7XG59XG4vKipcbiAqIEZpbmQgdGhlIFwiZ3JwY19jb25maWdcIiByZWNvcmQgYW1vbmcgdGhlIFRYVCByZWNvcmRzLCBwYXJzZSBpdHMgdmFsdWUgYXMgSlNPTiwgdmFsaWRhdGUgaXRzIGNvbnRlbnRzLFxuICogYW5kIHNlbGVjdCBhIHNlcnZpY2UgY29uZmlnIHdpdGggc2VsZWN0aW9uIGZpZWxkcyB0aGF0IGFsbCBtYXRjaCB0aGlzIGNsaWVudC4gTW9zdCBvZiB0aGVzZSBzdGVwc1xuICogY2FuIGZhaWwgd2l0aCBhbiBlcnJvcjsgdGhlIGNhbGxlciBtdXN0IGhhbmRsZSBhbnkgZXJyb3JzIHRocm93biB0aGlzIHdheS5cbiAqIEBwYXJhbSB0eHRSZWNvcmQgVGhlIFRYVCByZWNvcmQgYXJyYXkgdGhhdCBpcyBvdXRwdXQgZnJvbSBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBkbnMucmVzb2x2ZVR4dFxuICogQHBhcmFtIHBlcmNlbnRhZ2UgQSBudW1iZXIgY2hvc2VuIGZyb20gdGhlIHJhbmdlIFswLCAxMDApIHRoYXQgaXMgdXNlZCB0byBzZWxlY3Qgd2hpY2ggY29uZmlnIHRvIHVzZVxuICogQHJldHVybiBUaGUgc2VydmljZSBjb25maWd1cmF0aW9uIHRvIHVzZSwgZ2l2ZW4gdGhlIHBlcmNlbnRhZ2UgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHNlcnZpY2UgY29uZmlnXG4gKiAgICAgZGF0YSBoYXMgYSB2YWxpZCBmb3JtYXQgYnV0IG5vbmUgb2YgdGhlIG9wdGlvbnMgbWF0Y2ggdGhlIGN1cnJlbnQgY2xpZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHBlcmNlbnRhZ2UpIHtcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiB0eHRSZWNvcmQpIHtcbiAgICAgICAgaWYgKHJlY29yZC5sZW5ndGggPiAwICYmIHJlY29yZFswXS5zdGFydHNXaXRoKCdncnBjX2NvbmZpZz0nKSkge1xuICAgICAgICAgICAgLyogVHJlYXQgdGhlIGxpc3Qgb2Ygc3RyaW5ncyBpbiB0aGlzIHJlY29yZCBhcyBhIHNpbmdsZSBzdHJpbmcgYW5kIHJlbW92ZVxuICAgICAgICAgICAgICogXCJncnBjX2NvbmZpZz1cIiBmcm9tIHRoZSBiZWdpbm5pbmcuIFRoZSByZXN0IHNob3VsZCBiZSBhIEpTT04gc3RyaW5nICovXG4gICAgICAgICAgICBjb25zdCByZWNvcmRTdHJpbmcgPSByZWNvcmQuam9pbignJykuc3Vic3RyaW5nKCdncnBjX2NvbmZpZz0nLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRKc29uID0gSlNPTi5wYXJzZShyZWNvcmRTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnKHJlY29yZEpzb24sIHBlcmNlbnRhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyA9IGV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */\nclass StatusBuilder {\n    constructor() {\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */\n    withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */\n    withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */\n    withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */\n    build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder;\n//# sourceMappingURL=status-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcz9kYzBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSB2b2lkIDA7XG4vKipcbiAqIEEgYnVpbGRlciBmb3IgZ1JQQyBzdGF0dXMgb2JqZWN0cy5cbiAqL1xuY2xhc3MgU3RhdHVzQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3RhdHVzIGNvZGUgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aENvZGUoY29kZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBkZXRhaWxzIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhEZXRhaWxzKGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbWV0YWRhdGEgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgc3RhdHVzIG9iamVjdC5cbiAgICAgKi9cbiAgICBidWlsZCgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge307XG4gICAgICAgIGlmICh0aGlzLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRldGFpbHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gdGhpcy5kZXRhaWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gU3RhdHVzQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXR1cy1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor() {\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while (readHead < data.length) {\n            switch (this.readState) {\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        }\n                        else {\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize,\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error('Unexpected read state');\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder;\n//# sourceMappingURL=stream-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcz9jOTJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSB2b2lkIDA7XG52YXIgUmVhZFN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiTk9fREFUQVwiXSA9IDBdID0gXCJOT19EQVRBXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfU0laRVwiXSA9IDFdID0gXCJSRUFESU5HX1NJWkVcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19NRVNTQUdFXCJdID0gMl0gPSBcIlJFQURJTkdfTUVTU0FHRVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuY2xhc3MgU3RyZWFtRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XG4gICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgPSA0O1xuICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlID0gW107XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgIGxldCByZWFkSGVhZCA9IDA7XG4gICAgICAgIGxldCB0b1JlYWQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAocmVhZEhlYWQgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnJlYWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLk5PX0RBVEE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyA9IGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfU0laRTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUuZmlsbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLlJFQURJTkdfU0laRTpcbiAgICAgICAgICAgICAgICAgICAgdG9SZWFkID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSByZWFkSGVhZCwgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29weSh0aGlzLnJlYWRQYXJ0aWFsU2l6ZSwgNCAtIHRoaXMucmVhZFNpemVSZW1haW5pbmcsIHJlYWRIZWFkLCByZWFkSGVhZCArIHRvUmVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRTaXplUmVtYWluaW5nID49MCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRTaXplUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IHRoaXMucmVhZFBhcnRpYWxTaXplLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSB0aGlzLnJlYWRNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlYWRDb21wcmVzc0ZsYWcsIHRoaXMucmVhZFBhcnRpYWxTaXplXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U6XG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZS5wdXNoKGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRNZXNzYWdlUmVtYWluaW5nID49MCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHJlYWQgYSBmdWxsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2VCdWZmZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KGZyYW1lZE1lc3NhZ2VCdWZmZXJzLCB0aGlzLnJlYWRNZXNzYWdlU2l6ZSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZWFkIHN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSBTdHJlYW1EZWNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return 'port' in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (isTcpSubchannelAddress(address1)) {\n        return (isTcpSubchannelAddress(address2) &&\n            address1.host === address2.host &&\n            address1.port === address2.port);\n    }\n    else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + ':' + address.port;\n    }\n    else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if (net_1.isIP(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n        };\n    }\n    else {\n        return {\n            path: addressString\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\n//# sourceMappingURL=subchannel-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsaUNBQWlDLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCO0FBQ3ZJLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtYWRkcmVzcy5qcz9jNTFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MgPSBleHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBleHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwgPSBleHBvcnRzLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5mdW5jdGlvbiBpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gJ3BvcnQnIGluIGFkZHJlc3M7XG59XG5leHBvcnRzLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MgPSBpc1RjcFN1YmNoYW5uZWxBZGRyZXNzO1xuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChhZGRyZXNzMSwgYWRkcmVzczIpIHtcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMSkpIHtcbiAgICAgICAgcmV0dXJuIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MyKSAmJlxuICAgICAgICAgICAgYWRkcmVzczEuaG9zdCA9PT0gYWRkcmVzczIuaG9zdCAmJlxuICAgICAgICAgICAgYWRkcmVzczEucG9ydCA9PT0gYWRkcmVzczIucG9ydCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gIWlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmIGFkZHJlc3MxLnBhdGggPT09IGFkZHJlc3MyLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gc3ViY2hhbm5lbEFkZHJlc3NFcXVhbDtcbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcykge1xuICAgIGlmIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLmhvc3QgKyAnOicgKyBhZGRyZXNzLnBvcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyA9IHN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmc7XG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5mdW5jdGlvbiBzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3NTdHJpbmcsIHBvcnQpIHtcbiAgICBpZiAobmV0XzEuaXNJUChhZGRyZXNzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogYWRkcmVzc1N0cmluZyxcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQgIT09IG51bGwgJiYgcG9ydCAhPT0gdm9pZCAwID8gcG9ydCA6IERFRkFVTFRfUE9SVFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGFkZHJlc3NTdHJpbmdcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MgPSBzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child) {\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;\n//# sourceMappingURL=subchannel-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWludGVyZmFjZS5qcz8yZmY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IHZvaWQgMDtcbmNsYXNzIEJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICB9XG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoaWxkLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICAgIHN0YXJ0Q29ubmVjdGluZygpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDaGFubmVselJlZigpO1xuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IEJhc2VTdWJjaGFubmVsV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtaW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */\n    constructor() {\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */\n        this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */\n    unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */\n        // eslint-disable-disable-next-line:forin\n        for (const channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */\n            this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */\n        // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n    ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(() => {\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = uri_parser_1.uriToString(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray) {\n                if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) &&\n                    channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) &&\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel,\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    }\n    else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool;\n//# sourceMappingURL=subchannel-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ2xELDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtcG9vbC5qcz81ZDBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxfb3B0aW9uc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1vcHRpb25zXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbFwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbi8vIDEwIHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeS5cbi8qKlxuICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gY2hlY2tzIGZvciBkcm9wcGluZyBzdWJjaGFubmVscyB0aGF0IGhhdmUgbm9cbiAqIG90aGVyIHJlZmVyZW5jZXNcbiAqL1xuY29uc3QgUkVGX0NIRUNLX0lOVEVSVkFMID0gMTAwMDA7XG5jbGFzcyBTdWJjaGFubmVsUG9vbCB7XG4gICAgLyoqXG4gICAgICogQSBwb29sIG9mIHN1YmNoYW5uZWxzIHVzZSBmb3IgbWFraW5nIGNvbm5lY3Rpb25zLiBTdWJjaGFubmVscyB3aXRoIHRoZVxuICAgICAqIGV4YWN0IHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJldXNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wb29sID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZXIgb2YgYSB0YXNrIHBlcmZvcm1pbmcgYSBwZXJpb2RpYyBzdWJjaGFubmVsIGNsZWFudXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVmcyBhbGwgdW51c2VkIHN1YmNoYW5uZWxzIGFuZCBjYW5jZWxzIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsXG4gICAgICogc3ViY2hhbm5lbHMgaGF2ZSBiZWVuIHVucmVmZWQuXG4gICAgICovXG4gICAgdW5yZWZVbnVzZWRTdWJjaGFubmVscygpIHtcbiAgICAgICAgbGV0IGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IHRydWU7XG4gICAgICAgIC8qIFRoZXNlIG9iamVjdHMgYXJlIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpLCBzbyB0aGV5IGRvIG5vdFxuICAgICAgICAgKiBoYXZlIGEgcHJvdG90eXBlLCB3aGljaCBtZWFucyB0aGF0IGZvciAoLi4uIGluIC4uLikgbG9vcHMgb3ZlciB0aGVtXG4gICAgICAgICAqIGRvIG5vdCBuZWVkIHRvIGJlIGZpbHRlcmVkICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgICAgIGZvciAoY29uc3QgY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVkU3ViY2hhbm5lbHMgPSBzdWJjaGFubmVsT2JqQXJyYXkuZmlsdGVyKCh2YWx1ZSkgPT4gIXZhbHVlLnN1YmNoYW5uZWwudW5yZWZJZk9uZVJlZigpKTtcbiAgICAgICAgICAgIGlmIChyZWZlZFN1YmNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIEZvciBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIHBvb2wsIHRyeSB0byB1bnJlZiBpdCBpZiBpdCBoYXNcbiAgICAgICAgICAgICAqIGV4YWN0bHkgb25lIHJlZiAod2hpY2ggaXMgdGhlIHJlZiBmcm9tIHRoZSBwb29sIGl0c2VsZikuIElmIHRoYXRcbiAgICAgICAgICAgICAqIGRvZXMgaGFwcGVuLCByZW1vdmUgdGhlIHN1YmNoYW5uZWwgZnJvbSB0aGUgcG9vbCAqL1xuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gcmVmZWRTdWJjaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICAvKiBDdXJyZW50bHkgd2UgZG8gbm90IGRlbGV0ZSBrZXlzIHdpdGggZW1wdHkgdmFsdWVzLiBJZiB0aGF0IHJlc3VsdHNcbiAgICAgICAgICogaW4gc2lnbmlmaWNhbnQgbWVtb3J5IHVzYWdlIHdlIHNob3VsZCBjaGFuZ2UgaXQuICovXG4gICAgICAgIC8vIENhbmNlbCB0aGUgY2xlYW51cCB0YXNrIGlmIGFsbCBzdWJjaGFubmVscyBoYXZlIGJlZW4gdW5yZWZlZC5cbiAgICAgICAgaWYgKGFsbFN1YmNoYW5uZWxzVW5yZWZlZCAmJiB0aGlzLmNsZWFudXBUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBjbGVhbnVwIHRhc2sgaXMgc3Bhd25lZC5cbiAgICAgKi9cbiAgICBlbnN1cmVDbGVhbnVwVGFzaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICAgICAgICAgIH0sIFJFRl9DSEVDS19JTlRFUlZBTCk7XG4gICAgICAgICAgICAvLyBVbnJlZiBiZWNhdXNlIHRoaXMgdGltZXIgc2hvdWxkIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAvLyBDYWxsIHVucmVmIG9ubHkgaWYgaXQgZXhpc3RzIHRvIGFkZHJlc3MgZWxlY3Ryb24vZWxlY3Ryb24jMjExNjJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2xlYW51cFRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN1YmNoYW5uZWwgaWYgb25lIGFscmVhZHkgZXhpc3RzIHdpdGggZXhhY3RseSBtYXRjaGluZyBwYXJhbWV0ZXJzLlxuICAgICAqIE90aGVyd2lzZSwgY3JlYXRlIGFuZCBzYXZlIGEgc3ViY2hhbm5lbCB3aXRoIHRob3NlIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXRcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBjaGFubmVsQXJndW1lbnRzXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFsc1xuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlU3ViY2hhbm5lbChjaGFubmVsVGFyZ2V0VXJpLCBzdWJjaGFubmVsVGFyZ2V0LCBjaGFubmVsQXJndW1lbnRzLCBjaGFubmVsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDbGVhbnVwVGFzaygpO1xuICAgICAgICBjb25zdCBjaGFubmVsVGFyZ2V0ID0gdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKGNoYW5uZWxUYXJnZXRVcmkpO1xuICAgICAgICBpZiAoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbE9iaiBvZiBzdWJjaGFubmVsT2JqQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChzdWJjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWxBZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsX29wdGlvbnNfMS5jaGFubmVsT3B0aW9uc0VxdWFsKGNoYW5uZWxBcmd1bWVudHMsIHN1YmNoYW5uZWxPYmouY2hhbm5lbEFyZ3VtZW50cykgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMoc3ViY2hhbm5lbE9iai5jaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBubyBtYXRjaGluZyBzdWJjaGFubmVsIHdhcyBmb3VuZFxuICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gbmV3IHN1YmNoYW5uZWxfMS5TdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscyk7XG4gICAgICAgIGlmICghKGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSkge1xuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdLnB1c2goe1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3M6IHN1YmNoYW5uZWxUYXJnZXQsXG4gICAgICAgICAgICBjaGFubmVsQXJndW1lbnRzLFxuICAgICAgICAgICAgY2hhbm5lbENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgc3ViY2hhbm5lbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgIHJldHVybiBzdWJjaGFubmVsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSBTdWJjaGFubmVsUG9vbDtcbmNvbnN0IGdsb2JhbFN1YmNoYW5uZWxQb29sID0gbmV3IFN1YmNoYW5uZWxQb29sKCk7XG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGdsb2JhbCBzdWJjaGFubmVsIHBvb2wsIG9yIGEgbmV3IHN1YmNoYW5uZWwgcG9vbC5cbiAqIEBwYXJhbSBnbG9iYWxcbiAqL1xuZnVuY3Rpb24gZ2V0U3ViY2hhbm5lbFBvb2woZ2xvYmFsKSB7XG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU3ViY2hhbm5lbFBvb2w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmNoYW5uZWxQb29sKCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTdWJjaGFubmVsUG9vbCA9IGdldFN1YmNoYW5uZWxQb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1wb29sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subchannel = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */\n    constructor(channelTarget, subchannelAddress, options, credentials) {\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */\n        this.session = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */\n        this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */\n        this.stateListeners = [];\n        /**\n         * A list of listener functions that will be called when the underlying\n         * socket disconnects. Used for ending active calls with an UNAVAILABLE\n         * status.\n         */\n        this.disconnectListeners = new Set();\n        /**\n         * The amount of time in between sending pings\n         */\n        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */\n        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */\n        this.keepaliveWithoutCalls = false;\n        /**\n         * Tracks calls with references to this subchannel\n         */\n        this.callRefcount = 0;\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */\n        this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.channelzSocketRef = null;\n        /**\n         * Name of the remote server, if it is not the same as the subchannel\n         * address, i.e. if connecting through an HTTP CONNECT proxy.\n         */\n        this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'],\n            `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent'],\n        ]\n            .filter((e) => e)\n            .join(' '); // remove falsey values first\n        if ('grpc.keepalive_time_ms' in options) {\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n        }\n        if ('grpc.keepalive_timeout_ms' in options) {\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n        }\n        if ('grpc.keepalive_permit_without_calls' in options) {\n            this.keepaliveWithoutCalls =\n                options['grpc.keepalive_permit_without_calls'] === 1;\n        }\n        else {\n            this.keepaliveWithoutCalls = false;\n        }\n        this.keepaliveIntervalId = setTimeout(() => { }, 0);\n        clearTimeout(this.keepaliveIntervalId);\n        this.keepaliveTimeoutId = setTimeout(() => { }, 0);\n        clearTimeout(this.keepaliveTimeoutId);\n        const backoffOptions = {\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n        }\n        this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    getChannelzSocketInfo() {\n        var _a, _b, _c;\n        if (this.session === null) {\n            return null;\n        }\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n                remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n            };\n        }\n        else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    resetChannelzSocketInfo() {\n        if (!this.channelzEnabled) {\n            return;\n        }\n        if (this.channelzSocketRef) {\n            channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n            this.childrenTracker.unrefChild(this.channelzSocketRef);\n            this.channelzSocketRef = null;\n        }\n        this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        }\n        else {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */\n    startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    sendPing() {\n        var _a, _b;\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n        this.keepaliveTimeoutId = setTimeout(() => {\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.handleDisconnect();\n        }, this.keepaliveTimeoutMs);\n        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        try {\n            this.session.ping((err, duration, payload) => {\n                this.keepaliveTrace('Received ping response');\n                clearTimeout(this.keepaliveTimeoutId);\n            });\n        }\n        catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */\n            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    startKeepalivePings() {\n        var _a, _b;\n        this.keepaliveIntervalId = setInterval(() => {\n            this.sendPing();\n        }, this.keepaliveTimeMs);\n        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        /* Don't send a ping immediately because whatever caused us to start\n         * sending pings should also involve some network activity. */\n    }\n    /**\n     * Stop keepalive pings when terminating a connection. This discards the\n     * outstanding ping timeout, so it should not be called if the same\n     * connection will still be used.\n     */\n    stopKeepalivePings() {\n        clearInterval(this.keepaliveIntervalId);\n        clearTimeout(this.keepaliveTimeoutId);\n    }\n    createSession(proxyConnectionResult) {\n        var _a, _b, _c;\n        if (proxyConnectionResult.realTarget) {\n            this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n            this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n        }\n        else {\n            this.remoteName = null;\n            this.trace('creating HTTP/2 session');\n        }\n        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n        let connectionOptions = this.credentials._getConnectionOptions() || {};\n        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n        if ('grpc-node.max_session_memory' in this.options) {\n            connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        }\n        else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */\n            connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        let addressScheme = 'http://';\n        if ('secureContext' in connectionOptions) {\n            addressScheme = 'https://';\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n                // We want to always set servername to support SNI\n                connectionOptions.servername = authorityHostname;\n            }\n            if (proxyConnectionResult.socket) {\n                /* This is part of the workaround for\n                 * https://github.com/nodejs/node/issues/32922. Without that bug,\n                 * proxyConnectionResult.socket would always be a plaintext socket and\n                 * this would say\n                 * connectionOptions.socket = proxyConnectionResult.socket; */\n                connectionOptions.createConnection = (authority, option) => {\n                    return proxyConnectionResult.socket;\n                };\n            }\n        }\n        else {\n            /* In all but the most recent versions of Node, http2.connect does not use\n             * the options when establishing plaintext connections, so we need to\n             * establish that connection explicitly. */\n            connectionOptions.createConnection = (authority, option) => {\n                if (proxyConnectionResult.socket) {\n                    return proxyConnectionResult.socket;\n                }\n                else {\n                    /* net.NetConnectOpts is declared in a way that is more restrictive\n                     * than what net.connect will actually accept, so we use the type\n                     * assertion to work around that. */\n                    return net.connect(this.subchannelAddress);\n                }\n            };\n        }\n        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n        /* http2.connect uses the options here:\n         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n         * The spread operator overides earlier values with later ones, so any port\n         * or host values in the options will be used rather than any values extracted\n         * from the first argument. In addition, the path overrides the host and port,\n         * as documented for plaintext connections here:\n         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n         * and for TLS connections here:\n         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n         * earlier versions of Node, http2.connect passes these options to\n         * tls.connect but not net.connect, so in the insecure case we still need\n         * to set the createConnection option above to create the connection\n         * explicitly. We cannot do that in the TLS case because http2.connect\n         * passes necessary additional options to tls.connect.\n         * The first argument just needs to be parseable as a URL and the scheme\n         * determines whether the connection will be established over TLS or not.\n         */\n        const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n        this.session = session;\n        this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.childrenTracker.refChild(this.channelzSocketRef);\n        }\n        session.unref();\n        /* For all of these events, check if the session at the time of the event\n         * is the same one currently attached to this subchannel, to ensure that\n         * old events from previous connection attempts cannot cause invalid state\n         * transitions. */\n        session.once('connect', () => {\n            if (this.session === session) {\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n            }\n        });\n        session.once('close', () => {\n            if (this.session === session) {\n                this.trace('connection closed');\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n                /* Transitioning directly to IDLE here should be OK because we are not\n                 * doing any backoff, because a connection was established at some\n                 * point */\n                this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n            if (this.session === session) {\n                /* See the last paragraph of\n                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n                if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n                    opaqueData.equals(tooManyPingsData)) {\n                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n                }\n                this.trace('connection closed by GOAWAY with code ' +\n                    errorCode);\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once('error', (error) => {\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */\n            this.trace('connection closed with error ' +\n                error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on('remoteSettings', (settings) => {\n                this.trace('new settings received' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n            session.on('localSettings', (settings) => {\n                this.trace('local settings acknowledged by remote' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n        }\n    }\n    startConnectingInternal() {\n        var _a, _b;\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n        const connectionOptions = this.credentials._getConnectionOptions() || {};\n        if ('secureContext' in connectionOptions) {\n            connectionOptions.ALPNProtocols = ['h2'];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                if ('grpc.http_connect_target' in this.options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */\n                    const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n                        path: 'localhost',\n                    });\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n        }\n        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {\n            this.createSession(result);\n        }, (reason) => {\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        });\n    }\n    handleDisconnect() {\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        for (const listener of this.disconnectListeners.values()) {\n            listener();\n        }\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n    transitionToState(oldStates, newState) {\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch (newState) {\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                const session = this.session;\n                session.socket.once('close', () => {\n                    if (this.session === session) {\n                        this.handleDisconnect();\n                    }\n                });\n                if (this.keepaliveWithoutCalls) {\n                    this.startKeepalivePings();\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n                if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(() => {\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        /* We use a shallow copy of the stateListeners array in case a listener\n         * is removed during this iteration */\n        for (const listener of [...this.stateListeners]) {\n            listener(this, previousState, newState);\n        }\n        return true;\n    }\n    /**\n     * Check if the subchannel associated with zero calls and with zero channels.\n     * If so, shut it down.\n     */\n    checkBothRefcounts() {\n        /* If no calls, channels, or subchannel pools have any more references to\n         * this subchannel, we can be sure it will never be used again. */\n        if (this.callRefcount === 0 && this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n            }\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n        }\n    }\n    callRef() {\n        this.refTrace('callRefcount ' +\n            this.callRefcount +\n            ' -> ' +\n            (this.callRefcount + 1));\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.ref();\n            }\n            this.backoffTimeout.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.startKeepalivePings();\n            }\n        }\n        this.callRefcount += 1;\n    }\n    callUnref() {\n        this.refTrace('callRefcount ' +\n            this.callRefcount +\n            ' -> ' +\n            (this.callRefcount - 1));\n        this.callRefcount -= 1;\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.unref();\n            }\n            this.backoffTimeout.unref();\n            if (!this.keepaliveWithoutCalls) {\n                clearInterval(this.keepaliveIntervalId);\n            }\n            this.checkBothRefcounts();\n        }\n    }\n    ref() {\n        this.refTrace('refcount ' +\n            this.refcount +\n            ' -> ' +\n            (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace('refcount ' +\n            this.refcount +\n            ' -> ' +\n            (this.refcount - 1));\n        this.refcount -= 1;\n        this.checkBothRefcounts();\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Start a stream on the current session with the given `metadata` as headers\n     * and then attach it to the `callStream`. Must only be called if the\n     * subchannel's current connectivity state is READY.\n     * @param metadata\n     * @param callStream\n     */\n    startCallStream(metadata, callStream, extraFilters) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n        headers[HTTP2_HEADER_TE] = 'trailers';\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */\n        try {\n            http2Stream = this.session.request(headers);\n        }\n        catch (e) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n            throw e;\n        }\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' +\n            '(' + this.channelzRef.id + ') ' +\n            this.subchannelAddressString +\n            ' with headers\\n' +\n            headersString);\n        this.flowControlTrace('local window size: ' +\n            this.session.state.localWindowSize +\n            ' remote window size: ' +\n            this.session.state.remoteWindowSize);\n        const streamSession = this.session;\n        this.internalsTrace('session.closed=' +\n            streamSession.closed +\n            ' session.destroyed=' +\n            streamSession.destroyed +\n            ' session.socket.destroyed=' +\n            streamSession.socket.destroyed);\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            callStream.addStatusWatcher(status => {\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                }\n                else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n            this.streamTracker.addCallStarted();\n            callStream.addStreamEndWatcher(success => {\n                if (streamSession === this.session) {\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.streamTracker.addCallFailed();\n                    }\n                }\n            });\n            statsTracker = {\n                addMessageSent: () => {\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                },\n                addMessageReceived: () => {\n                    this.messagesReceived += 1;\n                }\n            };\n        }\n        else {\n            statsTracker = {\n                addMessageSent: () => { },\n                addMessageReceived: () => { }\n            };\n        }\n        callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n    startConnecting() {\n        /* First, try to transition from IDLE to connecting. If that doesn't happen\n         * because the state is not currently IDLE, check if it is\n         * TRANSIENT_FAILURE, and if so indicate that it should go back to\n         * connecting after the backoff timer ends. Otherwise do nothing */\n        if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.continueConnecting = true;\n            }\n        }\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n    getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.add(listener);\n    }\n    removeDisconnectListener(listener) {\n        this.disconnectListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n}\nexports.Subchannel = Subchannel;\n//# sourceMappingURL=subchannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxzQkFBc0IsMEdBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUlBQXVJO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsOENBQThDLEtBQUssOEJBQThCLDBFQUEwRSxzQkFBc0I7QUFDbFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxTQUFTO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzPzRmM2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3ViY2hhbm5lbCA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbCc7XG5jb25zdCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbF9mbG93Y3RybCc7XG5jb25zdCBNSU5fQ09OTkVDVF9USU1FT1VUX01TID0gMjAwMDA7XG5jb25zdCBJTklUSUFMX0JBQ0tPRkZfTVMgPSAxMDAwO1xuY29uc3QgQkFDS09GRl9NVUxUSVBMSUVSID0gMS42O1xuY29uc3QgTUFYX0JBQ0tPRkZfTVMgPSAxMjAwMDA7XG5jb25zdCBCQUNLT0ZGX0pJVFRFUiA9IDAuMjtcbi8qIHNldEludGVydmFsIGFuZCBzZXRUaW1lb3V0IG9ubHkgYWNjZXB0IHNpZ25lZCAzMiBiaXQgaW50ZWdlcnMuIEpTIGRvZXNuJ3RcbiAqIGhhdmUgYSBjb25zdGFudCBmb3IgdGhlIG1heCBzaWduZWQgMzIgYml0IGludGVnZXIsIHNvIHRoaXMgaXMgYSBzaW1wbGUgd2F5XG4gKiB0byBjYWxjdWxhdGUgaXQgKi9cbmNvbnN0IEtFRVBBTElWRV9NQVhfVElNRV9NUyA9IH4oMSA8PCAzMSk7XG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfQVVUSE9SSVRZLCBIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFLCBIVFRQMl9IRUFERVJfTUVUSE9ELCBIVFRQMl9IRUFERVJfUEFUSCwgSFRUUDJfSEVBREVSX1RFLCBIVFRQMl9IRUFERVJfVVNFUl9BR0VOVCwgfSA9IGh0dHAyLmNvbnN0YW50cztcbi8qKlxuICogR2V0IGEgbnVtYmVyIHVuaWZvcm1seSBhdCByYW5kb20gaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqL1xuZnVuY3Rpb24gdW5pZm9ybVJhbmRvbShtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59XG5jb25zdCB0b29NYW55UGluZ3NEYXRhID0gQnVmZmVyLmZyb20oJ3Rvb19tYW55X3BpbmdzJywgJ2FzY2lpJyk7XG5jbGFzcyBTdWJjaGFubmVsIHtcbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgYmFja2VuZC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZyBmb3IgdGhlIGNoYW5uZWwgYXMgYSB3aG9sZVxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsQWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIGJhY2tlbmQgdGhhdCB0aGlzIHN1YmNoYW5uZWxcbiAgICAgKiAgICAgd2lsbCBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNoYW5uZWwgb3B0aW9ucywgcGx1cyBhbnkgc3BlY2lmaWMgc3ViY2hhbm5lbCBvcHRpb25zXG4gICAgICogICAgIGZvciB0aGlzIHN1YmNoYW5uZWxcbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNoYW5uZWwgY3JlZGVudGlhbHMgdXNlZCB0byBlc3RhYmxpc2ggdGhpc1xuICAgICAqICAgICBjb25uZWN0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFRhcmdldCwgc3ViY2hhbm5lbEFkZHJlc3MsIG9wdGlvbnMsIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MgPSBzdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS4gSW52YXJpYW50OiBgc2Vzc2lvbmAgPT09IGBudWxsYFxuICAgICAgICAgKiBpZiBhbmQgb25seSBpZiBgY29ubmVjdGl2aXR5U3RhdGVgIGlzIElETEUgb3IgVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGh0dHAyIHNlc3Npb24gdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBzdWJjaGFubmVsIHNob3VsZCB0cmFuc2l0aW9uIGZyb20gVFJBTlNJRU5UX0ZBSUxVUkUgdG9cbiAgICAgICAgICogQ09OTkVDVElORyBpbnN0ZWFkIG9mIElETEUgd2hlbiB0aGUgYmFja29mZiB0aW1lb3V0IGVuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjb25uZWN0aXZpdHlcbiAgICAgICAgICogc3RhdGUgY2hhbmdlcy4gV2lsbCBiZSBtb2RpZmllZCBieSBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmAgYW5kXG4gICAgICAgICAqIGByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICogc29ja2V0IGRpc2Nvbm5lY3RzLiBVc2VkIGZvciBlbmRpbmcgYWN0aXZlIGNhbGxzIHdpdGggYW4gVU5BVkFJTEFCTEVcbiAgICAgICAgICogc3RhdHVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gc2VuZGluZyBwaW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBLRUVQQUxJVkVfTUFYX1RJTUVfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGFmdGVyIHNlbmRpbmcgYSBwaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IEtFRVBBTElWRV9USU1FT1VUX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIga2VlcGFsaXZlIHBpbmdzIHNob3VsZCBiZSBzZW50IHdpdGhvdXQgYW55IGFjdGl2ZSBjYWxsc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyBjYWxscyB3aXRoIHJlZmVyZW5jZXMgdG8gdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxSZWZjb3VudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3MgY2hhbm5lbHMgYW5kIHN1YmNoYW5uZWwgcG9vbHMgd2l0aCByZWZlcmVuY2VzIHRvIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIC8vIENoYW5uZWx6IHNvY2tldCBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGUgcmVtb3RlIHNlcnZlciwgaWYgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzdWJjaGFubmVsXG4gICAgICAgICAqIGFkZHJlc3MsIGkuZS4gaWYgY29ubmVjdGluZyB0aHJvdWdoIGFuIEhUVFAgQ09OTkVDVCBwcm94eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAvLyBCdWlsZCB1c2VyLWFnZW50IHN0cmluZy5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBbXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnByaW1hcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICAgICAgYGdycGMtbm9kZS1qcy8ke2NsaWVudFZlcnNpb259YCxcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gZSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7IC8vIHJlbW92ZSBmYWxzZXkgdmFsdWVzIGZpcnN0XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9XG4gICAgICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnXSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBvcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBvcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3ViY2hhbm5lbCBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnU3ViY2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHRoaXMuc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MgPyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzID8gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpIDogbnVsbDtcbiAgICAgICAgbGV0IHRsc0luZm87XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgY29uc3QgY2lwaGVySW5mbyA9IHRsc1NvY2tldC5nZXRDaXBoZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICB0bHNJbmZvID0ge1xuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWUgPyBudWxsIDogY2lwaGVySW5mby5uYW1lLFxuICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IChjZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBjZXJ0aWZpY2F0ZSkgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiAocGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZSkgPyBwZWVyQ2VydGlmaWNhdGUucmF3IDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRsc0luZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiByZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZU5hbWU6IHRoaXMucmVtb3RlTmFtZSxcbiAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbWVzc2FnZXNTZW50OiB0aGlzLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IHRoaXMubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiB0aGlzLmtlZXBhbGl2ZXNTZW50LFxuICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogdGhpcy5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9jID0gdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgfVxuICAgIHJlc2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYpIHtcbiAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZCh0aGlzLmNoYW5uZWx6U29ja2V0UmVmKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJlZlRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdzdWJjaGFubmVsX3JlZmNvdW50JywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGZsb3dDb250cm9sVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgaW50ZXJuYWxzVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3N1YmNoYW5uZWxfaW50ZXJuYWxzJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGtlZXBhbGl2ZVRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdrZWVwYWxpdmUnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgaGFuZGxlQmFja29mZlRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb250aW51ZUNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgYmFja29mZiB0aW1lciB3aXRoIHRoZSBjdXJyZW50IG5leHRCYWNrb2ZmIHRpbWVvdXRcbiAgICAgKi9cbiAgICBzdGFydEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xuICAgIH1cbiAgICBzdG9wQmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICB9XG4gICAgc2VuZFBpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHRpbWVvdXQgcGFzc2VkIHdpdGhvdXQgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMua2VlcGFsaXZlVGltZW91dElkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdSZWNlaXZlZCBwaW5nIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZW91dElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSBmYWlsIHRvIHNlbmQgYSBwaW5nLCB0aGUgY29ubmVjdGlvbiBpcyBubyBsb25nZXIgZnVuY3Rpb25hbCwgc29cbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBkaXNjYXJkIGl0LiAqL1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRLZWVwYWxpdmVQaW5ncygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kUGluZygpO1xuICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVNcyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMua2VlcGFsaXZlSW50ZXJ2YWxJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgLyogRG9uJ3Qgc2VuZCBhIHBpbmcgaW1tZWRpYXRlbHkgYmVjYXVzZSB3aGF0ZXZlciBjYXVzZWQgdXMgdG8gc3RhcnRcbiAgICAgICAgICogc2VuZGluZyBwaW5ncyBzaG91bGQgYWxzbyBpbnZvbHZlIHNvbWUgbmV0d29yayBhY3Rpdml0eS4gKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBrZWVwYWxpdmUgcGluZ3Mgd2hlbiB0ZXJtaW5hdGluZyBhIGNvbm5lY3Rpb24uIFRoaXMgZGlzY2FyZHMgdGhlXG4gICAgICogb3V0c3RhbmRpbmcgcGluZyB0aW1lb3V0LCBzbyBpdCBzaG91bGQgbm90IGJlIGNhbGxlZCBpZiB0aGUgc2FtZVxuICAgICAqIGNvbm5lY3Rpb24gd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIHN0b3BLZWVwYWxpdmVQaW5ncygpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZUludGVydmFsSWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjcmVhdGVTZXNzaW9uKHByb3h5Q29ubmVjdGlvblJlc3VsdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcocHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRpbmcgSFRUUC8yIHNlc3Npb24gdGhyb3VnaCBwcm94eSB0byAnICsgcHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0aW5nIEhUVFAvMiBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0QXV0aG9yaXR5ID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KChfYSA9IHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNoYW5uZWxUYXJnZXQpO1xuICAgICAgICBsZXQgY29ubmVjdGlvbk9wdGlvbnMgPSB0aGlzLmNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSB0aGlzLm9wdGlvbnNbJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEJ5IGRlZmF1bHQsIHNldCBhIHZlcnkgbGFyZ2UgbWF4IHNlc3Npb24gbWVtb3J5IGxpbWl0LCB0byBlZmZlY3RpdmVseVxuICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAqIGJlaGF2aW9yIGRlZ3JhZGVzIGJhZGx5IHdoZW4gdGhpcyBsaW1pdCBpcyByZWFjaGVkLCBzbyB3ZSBzb2x2ZSB0aGF0XG4gICAgICAgICAgICAgKiBieSBkaXNhYmxpbmcgdGhlIGNoZWNrIGVudGlyZWx5LiAqL1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzU2NoZW1lID0gJ2h0dHA6Ly8nO1xuICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBhZGRyZXNzU2NoZW1lID0gJ2h0dHBzOi8vJztcbiAgICAgICAgICAgIC8vIElmIHByb3ZpZGVkLCB0aGUgdmFsdWUgb2YgZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIHRoZSB0YXJnZXQgaG9zdG5hbWUgd2hlbiBjaGVja2luZyBzZXJ2ZXIgaWRlbnRpdHkuXG4gICAgICAgICAgICAvLyBUaGlzIG9wdGlvbiBpcyB1c2VkIGZvciB0ZXN0aW5nIG9ubHkuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gdGhpcy5vcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGxzXzEuY2hlY2tTZXJ2ZXJJZGVudGl0eShzc2xUYXJnZXROYW1lT3ZlcnJpZGUsIGNlcnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHNzbFRhcmdldE5hbWVPdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml0eUhvc3RuYW1lID0gKF9jID0gKF9iID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQodGFyZ2V0QXV0aG9yaXR5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhvc3QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdsb2NhbGhvc3QnO1xuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gYWx3YXlzIHNldCBzZXJ2ZXJuYW1lIHRvIHN1cHBvcnQgU05JXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IGF1dGhvcml0eUhvc3RuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIHBhcnQgb2YgdGhlIHdvcmthcm91bmQgZm9yXG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMi4gV2l0aG91dCB0aGF0IGJ1ZyxcbiAgICAgICAgICAgICAgICAgKiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0IHdvdWxkIGFsd2F5cyBiZSBhIHBsYWludGV4dCBzb2NrZXQgYW5kXG4gICAgICAgICAgICAgICAgICogdGhpcyB3b3VsZCBzYXlcbiAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9uT3B0aW9ucy5zb2NrZXQgPSBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0OyAqL1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEluIGFsbCBidXQgdGhlIG1vc3QgcmVjZW50IHZlcnNpb25zIG9mIE5vZGUsIGh0dHAyLmNvbm5lY3QgZG9lcyBub3QgdXNlXG4gICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyB3aGVuIGVzdGFibGlzaGluZyBwbGFpbnRleHQgY29ubmVjdGlvbnMsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAqIGVzdGFibGlzaCB0aGF0IGNvbm5lY3Rpb24gZXhwbGljaXRseS4gKi9cbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIG5ldC5OZXRDb25uZWN0T3B0cyBpcyBkZWNsYXJlZCBpbiBhIHdheSB0aGF0IGlzIG1vcmUgcmVzdHJpY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICogdGhhbiB3aGF0IG5ldC5jb25uZWN0IHdpbGwgYWN0dWFsbHkgYWNjZXB0LCBzbyB3ZSB1c2UgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICogYXNzZXJ0aW9uIHRvIHdvcmsgYXJvdW5kIHRoYXQuICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXQuY29ubmVjdCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0aW9uT3B0aW9ucyksIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICAvKiBodHRwMi5jb25uZWN0IHVzZXMgdGhlIG9wdGlvbnMgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNzBjMzJhNmQxOTBlMmI1ZDdiOWZmOWQ1YjZhNDU5ZDE0ZThiN2Q1OS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMzAyOC1MMzAzNlxuICAgICAgICAgKiBUaGUgc3ByZWFkIG9wZXJhdG9yIG92ZXJpZGVzIGVhcmxpZXIgdmFsdWVzIHdpdGggbGF0ZXIgb25lcywgc28gYW55IHBvcnRcbiAgICAgICAgICogb3IgaG9zdCB2YWx1ZXMgaW4gdGhlIG9wdGlvbnMgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIGFueSB2YWx1ZXMgZXh0cmFjdGVkXG4gICAgICAgICAqIGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50LiBJbiBhZGRpdGlvbiwgdGhlIHBhdGggb3ZlcnJpZGVzIHRoZSBob3N0IGFuZCBwb3J0LFxuICAgICAgICAgKiBhcyBkb2N1bWVudGVkIGZvciBwbGFpbnRleHQgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0bGlzdGVuZXJcbiAgICAgICAgICogYW5kIGZvciBUTFMgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90bHMuaHRtbCN0bHNfdGxzX2Nvbm5lY3Rfb3B0aW9uc19jYWxsYmFjay4gSW5cbiAgICAgICAgICogZWFybGllciB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IHBhc3NlcyB0aGVzZSBvcHRpb25zIHRvXG4gICAgICAgICAqIHRscy5jb25uZWN0IGJ1dCBub3QgbmV0LmNvbm5lY3QsIHNvIGluIHRoZSBpbnNlY3VyZSBjYXNlIHdlIHN0aWxsIG5lZWRcbiAgICAgICAgICogdG8gc2V0IHRoZSBjcmVhdGVDb25uZWN0aW9uIG9wdGlvbiBhYm92ZSB0byBjcmVhdGUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICogZXhwbGljaXRseS4gV2UgY2Fubm90IGRvIHRoYXQgaW4gdGhlIFRMUyBjYXNlIGJlY2F1c2UgaHR0cDIuY29ubmVjdFxuICAgICAgICAgKiBwYXNzZXMgbmVjZXNzYXJ5IGFkZGl0aW9uYWwgb3B0aW9ucyB0byB0bHMuY29ubmVjdC5cbiAgICAgICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IGp1c3QgbmVlZHMgdG8gYmUgcGFyc2VhYmxlIGFzIGEgVVJMIGFuZCB0aGUgc2NoZW1lXG4gICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkIG92ZXIgVExTIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGFkZHJlc3NTY2hlbWUgKyB0YXJnZXRBdXRob3JpdHksIGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5jaGFubmVselNvY2tldFJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6U29ja2V0SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQodGhpcy5jaGFubmVselNvY2tldFJlZik7XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICAvKiBGb3IgYWxsIG9mIHRoZXNlIGV2ZW50cywgY2hlY2sgaWYgdGhlIHNlc3Npb24gYXQgdGhlIHRpbWUgb2YgdGhlIGV2ZW50XG4gICAgICAgICAqIGlzIHRoZSBzYW1lIG9uZSBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBzdWJjaGFubmVsLCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgKiBvbGQgZXZlbnRzIGZyb20gcHJldmlvdXMgY29ubmVjdGlvbiBhdHRlbXB0cyBjYW5ub3QgY2F1c2UgaW52YWxpZCBzdGF0ZVxuICAgICAgICAgKiB0cmFuc2l0aW9ucy4gKi9cbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKTtcbiAgICAgICAgICAgICAgICAvKiBUcmFuc2l0aW9uaW5nIGRpcmVjdGx5IHRvIElETEUgaGVyZSBzaG91bGQgYmUgT0sgYmVjYXVzZSB3ZSBhcmUgbm90XG4gICAgICAgICAgICAgICAgICogZG9pbmcgYW55IGJhY2tvZmYsIGJlY2F1c2UgYSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCBhdCBzb21lXG4gICAgICAgICAgICAgICAgICogcG9pbnQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24gPT09IHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAvKiBTZWUgdGhlIGxhc3QgcGFyYWdyYXBoIG9mXG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTgtY2xpZW50LXNpZGUta2VlcGFsaXZlLm1kI2Jhc2ljLWtlZXBhbGl2ZSAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNICYmXG4gICAgICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gTWF0aC5taW4oMiAqIHRoaXMua2VlcGFsaXZlVGltZU1zLCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBDb25uZWN0aW9uIHRvICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMuY2hhbm5lbFRhcmdldCl9IGF0ICR7dGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZ30gcmVqZWN0ZWQgYnkgc2VydmVyIGJlY2F1c2Ugb2YgZXhjZXNzIHBpbmdzLiBJbmNyZWFzaW5nIHBpbmcgaW50ZXJ2YWwgdG8gJHt0aGlzLmtlZXBhbGl2ZVRpbWVNc30gbXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgYnkgR09BV0FZIHdpdGggY29kZSAnICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyBoZXJlLiBBbnkgZXJyb3Igc2hvdWxkIGFsc28gdHJpZ2dlciBhIGNsb3NlIGV2ZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgICogd2hlcmUgd2Ugd2FudCB0byBoYW5kbGUgdGhhdC4gICovXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xuICAgICAgICAgICAgc2Vzc2lvbi5vbigncmVtb3RlU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCduZXcgc2V0dGluZ3MgcmVjZWl2ZWQnICtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdsb2NhbFNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbG9jYWwgc2V0dGluZ3MgYWNrbm93bGVkZ2VkIGJ5IHJlbW90ZScgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLyogUGFzcyBjb25uZWN0aW9uIG9wdGlvbnMgdGhyb3VnaCB0byB0aGUgcHJveHkgc28gdGhhdCBpdCdzIGFibGUgdG9cbiAgICAgICAgICogdXBncmFkZSBpdCdzIGNvbm5lY3Rpb24gdG8gc3VwcG9ydCB0bHMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uT3B0aW9ucyA9IHRoaXMuY3JlZGVudGlhbHMuX2dldENvbm5lY3Rpb25PcHRpb25zKCkgfHwge307XG4gICAgICAgIGlmICgnc2VjdXJlQ29udGV4dCcgaW4gY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XG4gICAgICAgICAgICAvLyBJZiBwcm92aWRlZCwgdGhlIHZhbHVlIG9mIGdycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAvLyB0byBvdmVycmlkZSB0aGUgdGFyZ2V0IGhvc3RuYW1lIHdoZW4gY2hlY2tpbmcgc2VydmVyIGlkZW50aXR5LlxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzbFRhcmdldE5hbWVPdmVycmlkZSA9IHRoaXMub3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRsc18xLmNoZWNrU2VydmVySWRlbnRpdHkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBzc2xUYXJnZXROYW1lT3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgaXMgbW9yZSBvciBsZXNzIGhvdyBzZXJ2ZXJuYW1lIHdpbGwgYmUgc2V0IGluIGNyZWF0ZVNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICogaWYgYSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHByb3h5IGlzIG5vdCB1c2VkLCB0aGVzZSBjb25uZWN0aW9uT3B0aW9ucyBhcmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgICAqIGFueXdheSAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KChfYSA9IHVyaV9wYXJzZXJfMS5wYXJzZVVyaSh0aGlzLm9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCddKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gKF9iID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRhcmdldFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0dHBfcHJveHlfMS5nZXRQcm94aWVkQ29ubmVjdGlvbih0aGlzLnN1YmNoYW5uZWxBZGRyZXNzLCB0aGlzLm9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2Vzc2lvbihyZXN1bHQpO1xuICAgICAgICB9LCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XG4gICAgICogc3RhdGUuIElmIHRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eVN0YXRlIGlzIG5vdCBpbiBvbGRTdGF0ZXMsIGRvIG5vdGhpbmcuXG4gICAgICogQHBhcmFtIG9sZFN0YXRlcyBUaGUgc2V0IG9mIHN0YXRlcyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGlmIChvbGRTdGF0ZXMuaW5kZXhPZih0aGlzLmNvbm5lY3Rpdml0eVN0YXRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICsgJyAtPiAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uc29ja2V0Lm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uID09PSBzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0S2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wS2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZiB0aW1lciBoYXMgYWxyZWFkeSBlbmRlZCBieSB0aGUgdGltZSB3ZSBnZXQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgc3RhdGUsIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgdHJhbnNpdGlvbiBvdXQgb2ZcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBhcyB0aG91Z2ggdGhlIGJhY2tvZmYgdGltZXIgaXMgZW5kaW5nIHJpZ2h0IG5vdyAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDaGFubmVselNvY2tldEluZm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BLZWVwYWxpdmVQaW5ncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGU6IHVua25vd24gQ29ubmVjdGl2aXR5U3RhdGUgJHtuZXdTdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBXZSB1c2UgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHN0YXRlTGlzdGVuZXJzIGFycmF5IGluIGNhc2UgYSBsaXN0ZW5lclxuICAgICAgICAgKiBpcyByZW1vdmVkIGR1cmluZyB0aGlzIGl0ZXJhdGlvbiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi50aGlzLnN0YXRlTGlzdGVuZXJzXSkge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc3ViY2hhbm5lbCBhc3NvY2lhdGVkIHdpdGggemVybyBjYWxscyBhbmQgd2l0aCB6ZXJvIGNoYW5uZWxzLlxuICAgICAqIElmIHNvLCBzaHV0IGl0IGRvd24uXG4gICAgICovXG4gICAgY2hlY2tCb3RoUmVmY291bnRzKCkge1xuICAgICAgICAvKiBJZiBubyBjYWxscywgY2hhbm5lbHMsIG9yIHN1YmNoYW5uZWwgcG9vbHMgaGF2ZSBhbnkgbW9yZSByZWZlcmVuY2VzIHRvXG4gICAgICAgICAqIHRoaXMgc3ViY2hhbm5lbCwgd2UgY2FuIGJlIHN1cmUgaXQgd2lsbCBuZXZlciBiZSB1c2VkIGFnYWluLiAqL1xuICAgICAgICBpZiAodGhpcy5jYWxsUmVmY291bnQgPT09IDAgJiYgdGhpcy5yZWZjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1NodXR0aW5nIGRvd24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZih0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdjYWxsUmVmY291bnQgJyArXG4gICAgICAgICAgICB0aGlzLmNhbGxSZWZjb3VudCArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgKHRoaXMuY2FsbFJlZmNvdW50ICsgMSkpO1xuICAgICAgICBpZiAodGhpcy5jYWxsUmVmY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlZigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRLZWVwYWxpdmVQaW5ncygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFJlZmNvdW50ICs9IDE7XG4gICAgfVxuICAgIGNhbGxVbnJlZigpIHtcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgnY2FsbFJlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVmY291bnQgK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgICh0aGlzLmNhbGxSZWZjb3VudCAtIDEpKTtcbiAgICAgICAgdGhpcy5jYWxsUmVmY291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZUludGVydmFsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGVja0JvdGhSZWZjb3VudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5yZWZjb3VudCArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgKHRoaXMucmVmY291bnQgKyAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5yZWZjb3VudCArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgKHRoaXMucmVmY291bnQgLSAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgLT0gMTtcbiAgICAgICAgdGhpcy5jaGVja0JvdGhSZWZjb3VudHMoKTtcbiAgICB9XG4gICAgdW5yZWZJZk9uZVJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWYoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBzdHJlYW0gb24gdGhlIGN1cnJlbnQgc2Vzc2lvbiB3aXRoIHRoZSBnaXZlbiBgbWV0YWRhdGFgIGFzIGhlYWRlcnNcbiAgICAgKiBhbmQgdGhlbiBhdHRhY2ggaXQgdG8gdGhlIGBjYWxsU3RyZWFtYC4gTXVzdCBvbmx5IGJlIGNhbGxlZCBpZiB0aGVcbiAgICAgKiBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUgaXMgUkVBRFkuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGNhbGxTdHJlYW1cbiAgICAgKi9cbiAgICBzdGFydENhbGxTdHJlYW0obWV0YWRhdGEsIGNhbGxTdHJlYW0sIGV4dHJhRmlsdGVycykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQVVUSE9SSVRZXSA9IGNhbGxTdHJlYW0uZ2V0SG9zdCgpO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9VU0VSX0FHRU5UXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL2dycGMnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ1BPU1QnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IGNhbGxTdHJlYW0uZ2V0TWV0aG9kKCk7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1RFXSA9ICd0cmFpbGVycyc7XG4gICAgICAgIGxldCBodHRwMlN0cmVhbTtcbiAgICAgICAgLyogSW4gdGhlb3J5LCBpZiBhbiBlcnJvciBpcyB0aHJvd24gYnkgc2Vzc2lvbi5yZXF1ZXN0IGJlY2F1c2Ugc2Vzc2lvbiBoYXNcbiAgICAgICAgICogYmVjb21lIHVudXNhYmxlIChlLmcuIGJlY2F1c2UgaXQgaGFzIHJlY2VpdmVkIGEgZ29hd2F5KSwgdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqIHNob3VsZCBzb29uIHNlZSB0aGUgY29ycmVzcG9uZGluZyBjbG9zZSBvciBnb2F3YXkgZXZlbnQgYW55d2F5IGFuZCBsZWF2ZVxuICAgICAgICAgKiBSRUFEWS4gQnV0IHdlIGhhdmUgc2VlbiByZXBvcnRzIHRoYXQgdGhpcyBkb2VzIG5vdCBoYXBwZW5cbiAgICAgICAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL25vZGVqcy1maXJlc3RvcmUvaXNzdWVzLzEwMjMjaXNzdWVjb21tZW50LTY1MzIwNDA5NilcbiAgICAgICAgICogc28gZm9yIGRlZmVuc2UgaW4gZGVwdGgsIHdlIGp1c3QgZGlzY2FyZCB0aGUgc2Vzc2lvbiB3aGVuIHdlIHNlZSBhblxuICAgICAgICAgKiBlcnJvciBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGh0dHAyU3RyZWFtID0gdGhpcy5zZXNzaW9uLnJlcXVlc3QoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NhbGxfc3RyZWFtJywgJ1N0YXJ0aW5nIHN0cmVhbSBbJyArIGNhbGxTdHJlYW0uZ2V0Q2FsbE51bWJlcigpICsgJ10gb24gc3ViY2hhbm5lbCAnICtcbiAgICAgICAgICAgICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyB3aXRoIGhlYWRlcnNcXG4nICtcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICB0aGlzLmZsb3dDb250cm9sVHJhY2UoJ2xvY2FsIHdpbmRvdyBzaXplOiAnICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUgK1xuICAgICAgICAgICAgJyByZW1vdGUgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpO1xuICAgICAgICBjb25zdCBzdHJlYW1TZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB0aGlzLmludGVybmFsc1RyYWNlKCdzZXNzaW9uLmNsb3NlZD0nICtcbiAgICAgICAgICAgIHN0cmVhbVNlc3Npb24uY2xvc2VkICtcbiAgICAgICAgICAgICcgc2Vzc2lvbi5kZXN0cm95ZWQ9JyArXG4gICAgICAgICAgICBzdHJlYW1TZXNzaW9uLmRlc3Ryb3llZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uc29ja2V0LmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHN0cmVhbVNlc3Npb24uc29ja2V0LmRlc3Ryb3llZCk7XG4gICAgICAgIGxldCBzdGF0c1RyYWNrZXI7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgY2FsbFN0cmVhbS5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgY2FsbFN0cmVhbS5hZGRTdHJlYW1FbmRXYXRjaGVyKHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1TZXNzaW9uID09PSB0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHsgfSxcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsU3RyZWFtLmF0dGFjaEh0dHAyU3RyZWFtKGh0dHAyU3RyZWFtLCB0aGlzLCBleHRyYUZpbHRlcnMsIHN0YXRzVHJhY2tlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnRseSBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFuZCBzd2l0Y2ggdG8gdGhlXG4gICAgICogQ09OTkVDVElORyBzdGF0ZS4gSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudCBpbiBUUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxuICAgICAqIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIC8qIEZpcnN0LCB0cnkgdG8gdHJhbnNpdGlvbiBmcm9tIElETEUgdG8gY29ubmVjdGluZy4gSWYgdGhhdCBkb2Vzbid0IGhhcHBlblxuICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXG4gICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLCBhbmQgaWYgc28gaW5kaWNhdGUgdGhhdCBpdCBzaG91bGQgZ28gYmFjayB0b1xuICAgICAgICAgKiBjb25uZWN0aW5nIGFmdGVyIHRoZSBiYWNrb2ZmIHRpbWVyIGVuZHMuIE90aGVyd2lzZSBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN1YmNoYW5uZWwnc1xuICAgICAqIGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogICAgIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqL1xuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJJbmRleCA9IHRoaXMuc3RhdGVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChsaXN0ZW5lckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZERpc2Nvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRGlzY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgYmFja29mZiB0aW1lb3V0LCBhbmQgaW1tZWRpYXRlbHkgc3RhcnQgY29ubmVjdGluZyBpZiBpbiBiYWNrb2ZmLlxuICAgICAqL1xuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZztcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsID0gU3ViY2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData;\n//# sourceMappingURL=tls-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanM/MmUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREZWZhdWx0Um9vdHNEYXRhID0gZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5leHBvcnRzLkNJUEhFUl9TVUlURVMgPSBwcm9jZXNzLmVudi5HUlBDX1NTTF9DSVBIRVJfU1VJVEVTO1xuY29uc3QgREVGQVVMVF9ST09UU19GSUxFX1BBVEggPSBwcm9jZXNzLmVudi5HUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSDtcbmxldCBkZWZhdWx0Um9vdHNEYXRhID0gbnVsbDtcbmZ1bmN0aW9uIGdldERlZmF1bHRSb290c0RhdGEoKSB7XG4gICAgaWYgKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Um9vdHNEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Um9vdHNEYXRhID0gZnMucmVhZEZpbGVTeW5jKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFJvb3RzRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBnZXREZWZhdWx0Um9vdHNEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGxzLWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3],\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith('[')) {\n        const hostEnd = path.indexOf(']');\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */\n        if (host.indexOf(':') === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === ':') {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString,\n                    };\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host,\n            };\n        }\n    }\n    else {\n        const splitPath = path.split(':');\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */\n        if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1],\n                };\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host: path,\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = '';\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + ':';\n    }\n    if (uri.authority !== undefined) {\n        result += '//' + uri.authority + '/';\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString;\n//# sourceMappingURL=uri-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3VyaS1wYXJzZXIuanM/Y2ZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51cmlUb1N0cmluZyA9IGV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IGV4cG9ydHMucGFyc2VVcmkgPSB2b2lkIDA7XG4vKlxuICogVGhlIGdyb3VwcyBjb3JyZXNwb25kIHRvIFVSSSBwYXJ0cyBhcyBmb2xsb3dzOlxuICogMS4gc2NoZW1lXG4gKiAyLiBhdXRob3JpdHlcbiAqIDMuIHBhdGhcbiAqL1xuY29uc3QgVVJJX1JFR0VYID0gL14oPzooW0EtWmEtejAtOSsuLV0rKTopPyg/OlxcL1xcLyhbXi9dKilcXC8pPyguKykkLztcbmZ1bmN0aW9uIHBhcnNlVXJpKHVyaVN0cmluZykge1xuICAgIGNvbnN0IHBhcnNlZFVyaSA9IFVSSV9SRUdFWC5leGVjKHVyaVN0cmluZyk7XG4gICAgaWYgKHBhcnNlZFVyaSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBwYXJzZWRVcmlbMV0sXG4gICAgICAgIGF1dGhvcml0eTogcGFyc2VkVXJpWzJdLFxuICAgICAgICBwYXRoOiBwYXJzZWRVcmlbM10sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VVcmkgPSBwYXJzZVVyaTtcbmNvbnN0IE5VTUJFUl9SRUdFWCA9IC9eXFxkKyQvO1xuZnVuY3Rpb24gc3BsaXRIb3N0UG9ydChwYXRoKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgIGNvbnN0IGhvc3RFbmQgPSBwYXRoLmluZGV4T2YoJ10nKTtcbiAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0ID0gcGF0aC5zdWJzdHJpbmcoMSwgaG9zdEVuZCk7XG4gICAgICAgIC8qIE9ubHkgYW4gSVB2NiBhZGRyZXNzIHNob3VsZCBiZSBpbiBicmFja2V0ZWQgbm90YXRpb24sIGFuZCBhbiBJUHY2XG4gICAgICAgICAqIGFkZHJlc3Mgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGNvbG9uICovXG4gICAgICAgIGlmIChob3N0LmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IGhvc3RFbmQgKyAxKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtob3N0RW5kICsgMV0gPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRTdHJpbmcgPSBwYXRoLnN1YnN0cmluZyhob3N0RW5kICsgMik7XG4gICAgICAgICAgICAgICAgaWYgKE5VTUJFUl9SRUdFWC50ZXN0KHBvcnRTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogK3BvcnRTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNwbGl0UGF0aCA9IHBhdGguc3BsaXQoJzonKTtcbiAgICAgICAgLyogRXhhY3RseSBvbmUgY29sb24gbWVhbnMgdGhhdCB0aGlzIGlzIGhvc3Q6cG9ydC4gWmVybyBjb2xvbnMgbWVhbnMgdGhhdFxuICAgICAgICAgKiB0aGVyZSBpcyBubyBwb3J0LiBBbmQgbXVsdGlwbGUgY29sb25zIG1lYW5zIHRoYXQgdGhpcyBpcyBhIGJhcmUgSVB2NlxuICAgICAgICAgKiBhZGRyZXNzIHdpdGggbm8gcG9ydCAqL1xuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKE5VTUJFUl9SRUdFWC50ZXN0KHNwbGl0UGF0aFsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiBzcGxpdFBhdGhbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtzcGxpdFBhdGhbMV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0OiBwYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IHNwbGl0SG9zdFBvcnQ7XG5mdW5jdGlvbiB1cmlUb1N0cmluZyh1cmkpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgaWYgKHVyaS5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gdXJpLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgaWYgKHVyaS5hdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gJy8vJyArIHVyaS5hdXRob3JpdHkgKyAnLyc7XG4gICAgfVxuICAgIHJlc3VsdCArPSB1cmkucGF0aDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51cmlUb1N0cmluZyA9IHVyaVRvU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function (IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item) => {\n        for (const [key, value] of Object.entries(item)) {\n            switch (key) {\n                case 'uninterpreted_option':\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: [],\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsdUNBQXVDLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLFlBQVk7QUFDek0sa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHFIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsb0dBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFNO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz8zZDRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbnZhciBJZGVtcG90ZW5jeUxldmVsO1xuKGZ1bmN0aW9uIChJZGVtcG90ZW5jeUxldmVsKSB7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTkNZX1VOS05PV05cIl0gPSBcIklERU1QT1RFTkNZX1VOS05PV05cIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gXCJOT19TSURFX0VGRkVDVFNcIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IFwiSURFTVBPVEVOVFwiO1xufSkoSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCB8fCAoZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0ge30pKTtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFwTWV0aG9kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zIHx8IFtdKS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmludGVycHJldGVkX29wdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIG9iai51bmludGVycHJldGVkX29wdGlvbi5wdXNoKGl0ZW0udW5pbnRlcnByZXRlZF9vcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge1xuICAgICAgICBkZXByZWNhdGVkOiBmYWxzZSxcbiAgICAgICAgaWRlbXBvdGVuY3lfbGV2ZWw6IElkZW1wb3RlbmN5TGV2ZWwuSURFTVBPVEVOQ1lfVU5LTk9XTixcbiAgICAgICAgdW5pbnRlcnByZXRlZF9vcHRpb246IFtdLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgb3B0aW9uczogbWFwTWV0aG9kT3B0aW9ucyhtZXRob2QucGFyc2VkT3B0aW9ucyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKHNlcnZpY2UsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHNlcnZpY2UubWV0aG9kc0FycmF5KSB7XG4gICAgICAgIGRlZlttZXRob2QubmFtZV0gPSBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG1lc3NhZ2UsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEZXNjcmlwdG9yID0gbWVzc2FnZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIERlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IG1lc3NhZ2VEZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2VEZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVudW1EZWZpbml0aW9uKGVudW1UeXBlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBlbnVtRGVzY3JpcHRvciA9IGVudW1UeXBlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRW51bURlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IGVudW1EZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KGVudW1EZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbi8qKlxuICogZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlNlcnZpY2UsIG5hbWU6IHN0cmluZywgb3B0aW9uczpcbiAqIE9wdGlvbnMpOiBTZXJ2aWNlRGVmaW5pdGlvbjsgZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlR5cGUsXG4gKiBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOiBNZXNzYWdlVHlwZURlZmluaXRpb247IGZ1bmN0aW9uXG4gKiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuRW51bSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTpcbiAqIEVudW1UeXBlRGVmaW5pdGlvbjtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW51bURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG1pc21hdGNoIGluIHJlZmxlY3Rpb24gb2JqZWN0IGhhbmRsaW5nJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JMaXN0ID0gcm9vdC50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpLmZpbGU7XG4gICAgY29uc3QgYnVmZmVyTGlzdCA9IGRlc2NyaXB0b3JMaXN0Lm1hcCh2YWx1ZSA9PiBCdWZmZXIuZnJvbShkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yUHJvdG8uZW5jb2RlKHZhbHVlKS5maW5pc2goKSkpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIG9ial0gb2YgZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKHJvb3QsICcnKSkge1xuICAgICAgICBkZWZbbmFtZV0gPSBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgYnVmZmVyTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgcm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbURlc2NyaXB0b3IoZGVjb2RlZERlc2NyaXB0b3JTZXQpO1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKTtcbn1cbi8qKlxuICogTG9hZCBhIC5wcm90byBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLlxuICogQHBhcmFtIGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlIHBhdGhzIHRvIGxvYWQuIENhbiBiZSBhbiBhYnNvbHV0ZSBwYXRoXG4gKiAgICAgb3IgcmVsYXRpdmUgdG8gYW4gaW5jbHVkZSBwYXRoLlxuICogQHBhcmFtIG9wdGlvbnMua2VlcENhc2UgUHJlc2VydmUgZmllbGQgbmFtZXMuIFRoZSBkZWZhdWx0IGlzIHRvIGNoYW5nZSB0aGVtXG4gKiAgICAgdG8gY2FtZWwgY2FzZS5cbiAqIEBwYXJhbSBvcHRpb25zLmxvbmdzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBsb25nYCB2YWx1ZXMuXG4gKiAgICAgVmFsaWQgb3B0aW9ucyBhcmUgYE51bWJlcmAgYW5kIGBTdHJpbmdgLiBEZWZhdWx0cyB0byBhIGBMb25nYCBvYmplY3QgdHlwZVxuICogICAgIGZyb20gYSBsaWJyYXJ5LlxuICogQHBhcmFtIG9wdGlvbnMuZW51bXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGVudW1gIHZhbHVlcy5cbiAqICAgICBUaGUgb25seSB2YWxpZCBvcHRpb24gaXMgYFN0cmluZ2AuIERlZmF1bHRzIHRvIHRoZSBudW1lcmljIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuYnl0ZXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGJ5dGVzYFxuICogICAgIHZhbHVlcy4gVmFsaWQgb3B0aW9ucyBhcmUgYEFycmF5YCBhbmQgYFN0cmluZ2AuIFRoZSBkZWZhdWx0IGlzIHRvIHVzZVxuICogICAgIGBCdWZmZXJgLlxuICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHMgU2V0IGRlZmF1bHQgdmFsdWVzIG9uIG91dHB1dCBvYmplY3RzLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5hcnJheXMgU2V0IGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyBhcnJheSB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9iamVjdHMgU2V0IGVtcHR5IG9iamVjdHMgZm9yIG1pc3Npbmcgb2JqZWN0IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub25lb2ZzIFNldCB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgdG8gdGhlIHByZXNlbnQgZmllbGQnc1xuICogICAgIG5hbWVcbiAqIEBwYXJhbSBvcHRpb25zLmpzb24gUmVwcmVzZW50IEluZmluaXR5IGFuZCBOYU4gYXMgc3RyaW5ncyBpbiBmbG9hdCBmaWVsZHMsXG4gKiAgICAgYW5kIGF1dG9tYXRpY2FsbHkgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5BbnkgdmFsdWVzLlxuICogQHBhcmFtIG9wdGlvbnMuaW5jbHVkZURpcnMgUGF0aHMgdG8gc2VhcmNoIGZvciBpbXBvcnRlZCBgLnByb3RvYCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9ucykoZmlsZW5hbWUsIG9wdGlvbnMpLnRoZW4obG9hZGVkUm9vdCA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMpKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbUpTT04oanNvbik7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcihkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdChkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmZyb21PYmplY3QoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdDtcbigwLCB1dGlsXzEuYWRkQ29tbW9uUHJvdG9zKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */\nfunction addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkI7QUFDM0YsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsd0NBQXdDLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxnSUFBcUM7QUFDdkUsaUNBQWlDLG1CQUFPLENBQUMsOElBQTRDO0FBQ3JGLG9DQUFvQyxtQkFBTyxDQUFDLHNKQUFnRDtBQUM1RiwyQkFBMkIsbUJBQU8sQ0FBQyxrSUFBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL3V0aWwuanM/ZmZmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZENvbW1vblByb3RvcyA9IGV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBQcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xuZnVuY3Rpb24gYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBpbmNsdWRlUGF0aHMpIHtcbiAgICBjb25zdCBvcmlnaW5hbFJlc29sdmVQYXRoID0gcm9vdC5yZXNvbHZlUGF0aDtcbiAgICByb290LnJlc29sdmVQYXRoID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmlzQWJzb2x1dGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRpcmVjdG9yeSBvZiBpbmNsdWRlUGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnMuYWNjZXNzU3luYyhmdWxsUGF0aCwgZnMuY29uc3RhbnRzLlJfT0spO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGAke3RhcmdldH0gbm90IGZvdW5kIGluIGFueSBvZiB0aGUgaW5jbHVkZSBwYXRocyAke2luY2x1ZGVQYXRoc31gKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVzb2x2ZVBhdGgob3JpZ2luLCB0YXJnZXQpO1xuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUHJvdG9zV2l0aE9wdGlvbnMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByb290ID0gbmV3IFByb3RvYnVmLlJvb3QoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoISFvcHRpb25zLmluY2x1ZGVEaXJzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVEaXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIGluY2x1ZGVEaXJzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5JykpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBhd2FpdCByb290LmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBsb2FkZWRSb290O1xufVxuZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnMgPSBsb2FkUHJvdG9zV2l0aE9wdGlvbnM7XG5mdW5jdGlvbiBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY2x1ZGVEaXJzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IHJvb3QubG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBsb2FkZWRSb290O1xufVxuZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYztcbi8qKlxuICogTG9hZCBHb29nbGUncyB3ZWxsLWtub3duIHByb3RvIGZpbGVzIHRoYXQgYXJlbid0IGV4cG9zZWQgYnkgUHJvdG9idWYuanMuXG4gKi9cbmZ1bmN0aW9uIGFkZENvbW1vblByb3RvcygpIHtcbiAgICAvLyBQcm90b2J1Zi5qcyBleHBvc2VzOiBhbnksIGR1cmF0aW9uLCBlbXB0eSwgZmllbGRfbWFzaywgc3RydWN0LCB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdyYXBwZXJzLiBjb21waWxlci9wbHVnaW4gaXMgZXhjbHVkZWQgaW4gUHJvdG9idWYuanMgYW5kIGhlcmUuXG4gICAgLy8gVXNpbmcgY29uc3RhbnQgc3RyaW5ncyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRvb2xzIGxpa2UgV2VicGFja1xuICAgIGNvbnN0IGFwaURlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9hcGkuanNvbicpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5qc29uJyk7XG4gICAgY29uc3Qgc291cmNlQ29udGV4dERlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9zb3VyY2VfY29udGV4dC5qc29uJyk7XG4gICAgY29uc3QgdHlwZURlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi90eXBlLmpzb24nKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ2FwaScsIGFwaURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ2Rlc2NyaXB0b3InLCBkZXNjcmlwdG9yRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbignc291cmNlX2NvbnRleHQnLCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbigndHlwZScsIHR5cGVEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG59XG5leHBvcnRzLmFkZENvbW1vblByb3RvcyA9IGFkZENvbW1vblByb3Rvcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\r\nvar $protobuf = __webpack_require__(/*! ../.. */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\");\r\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(__webpack_require__(/*! ../../google/protobuf/descriptor.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\r\n\r\nvar Namespace = $protobuf.Namespace,\r\n    Root      = $protobuf.Root,\r\n    Enum      = $protobuf.Enum,\r\n    Type      = $protobuf.Type,\r\n    Field     = $protobuf.Field,\r\n    MapField  = $protobuf.MapField,\r\n    OneOf     = $protobuf.OneOf,\r\n    Service   = $protobuf.Service,\r\n    Method    = $protobuf.Method;\r\n\r\n// --- Root ---\r\n\r\n/**\r\n * Properties of a FileDescriptorSet message.\r\n * @interface IFileDescriptorSet\r\n * @property {IFileDescriptorProto[]} file Files\r\n */\r\n\r\n/**\r\n * Properties of a FileDescriptorProto message.\r\n * @interface IFileDescriptorProto\r\n * @property {string} [name] File name\r\n * @property {string} [package] Package\r\n * @property {*} [dependency] Not supported\r\n * @property {*} [publicDependency] Not supported\r\n * @property {*} [weakDependency] Not supported\r\n * @property {IDescriptorProto[]} [messageType] Nested message types\r\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\r\n * @property {IServiceDescriptorProto[]} [service] Nested services\r\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\r\n * @property {IFileOptions} [options] Options\r\n * @property {*} [sourceCodeInfo] Not supported\r\n * @property {string} [syntax=\"proto2\"] Syntax\r\n */\r\n\r\n/**\r\n * Properties of a FileOptions message.\r\n * @interface IFileOptions\r\n * @property {string} [javaPackage]\r\n * @property {string} [javaOuterClassname]\r\n * @property {boolean} [javaMultipleFiles]\r\n * @property {boolean} [javaGenerateEqualsAndHash]\r\n * @property {boolean} [javaStringCheckUtf8]\r\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\r\n * @property {string} [goPackage]\r\n * @property {boolean} [ccGenericServices]\r\n * @property {boolean} [javaGenericServices]\r\n * @property {boolean} [pyGenericServices]\r\n * @property {boolean} [deprecated]\r\n * @property {boolean} [ccEnableArenas]\r\n * @property {string} [objcClassPrefix]\r\n * @property {string} [csharpNamespace]\r\n */\r\n\r\n/**\r\n * Values of he FileOptions.OptimizeMode enum.\r\n * @typedef IFileOptionsOptimizeMode\r\n * @type {number}\r\n * @property {number} SPEED=1\r\n * @property {number} CODE_SIZE=2\r\n * @property {number} LITE_RUNTIME=3\r\n */\r\n\r\n/**\r\n * Creates a root from a descriptor set.\r\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Root} Root instance\r\n */\r\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.FileDescriptorSet.decode(descriptor);\r\n\r\n    var root = new Root();\r\n\r\n    if (descriptor.file) {\r\n        var fileDescriptor,\r\n            filePackage;\r\n        for (var j = 0, i; j < descriptor.file.length; ++j) {\r\n            filePackage = root;\r\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length)\r\n                filePackage = root.define(fileDescriptor[\"package\"]);\r\n            if (fileDescriptor.name && fileDescriptor.name.length)\r\n                root.files.push(filePackage.filename = fileDescriptor.name);\r\n            if (fileDescriptor.messageType)\r\n                for (i = 0; i < fileDescriptor.messageType.length; ++i)\r\n                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\r\n            if (fileDescriptor.enumType)\r\n                for (i = 0; i < fileDescriptor.enumType.length; ++i)\r\n                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\r\n            if (fileDescriptor.extension)\r\n                for (i = 0; i < fileDescriptor.extension.length; ++i)\r\n                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\r\n            if (fileDescriptor.service)\r\n                for (i = 0; i < fileDescriptor.service.length; ++i)\r\n                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\r\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\r\n            if (opts) {\r\n                var ks = Object.keys(opts);\r\n                for (i = 0; i < ks.length; ++i)\r\n                    filePackage.setOption(ks[i], opts[ks[i]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return root;\r\n};\r\n\r\n/**\r\n * Converts a root to a descriptor set.\r\n * @returns {Message<IFileDescriptorSet>} Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n */\r\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\r\n    var set = exports.FileDescriptorSet.create();\r\n    Root_toDescriptorRecursive(this, set.file, syntax);\r\n    return set;\r\n};\r\n\r\n// Traverses a namespace and assembles the descriptor set\r\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\r\n\r\n    // Create a new file\r\n    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\" });\r\n    if (syntax)\r\n        file.syntax = syntax;\r\n    if (!(ns instanceof Root))\r\n        file[\"package\"] = ns.fullName.substring(1);\r\n\r\n    // Add nested types\r\n    for (var i = 0, nested; i < ns.nestedArray.length; ++i)\r\n        if ((nested = ns._nestedArray[i]) instanceof Type)\r\n            file.messageType.push(nested.toDescriptor(syntax));\r\n        else if (nested instanceof Enum)\r\n            file.enumType.push(nested.toDescriptor());\r\n        else if (nested instanceof Field)\r\n            file.extension.push(nested.toDescriptor(syntax));\r\n        else if (nested instanceof Service)\r\n            file.service.push(nested.toDescriptor());\r\n        else if (nested instanceof /* plain */ Namespace)\r\n            Root_toDescriptorRecursive(nested, files, syntax); // requires new file\r\n\r\n    // Keep package-level options\r\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\r\n\r\n    // And keep the file only if there is at least one nested object\r\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)\r\n        files.push(file);\r\n}\r\n\r\n// --- Type ---\r\n\r\n/**\r\n * Properties of a DescriptorProto message.\r\n * @interface IDescriptorProto\r\n * @property {string} [name] Message type name\r\n * @property {IFieldDescriptorProto[]} [field] Fields\r\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\r\n * @property {IDescriptorProto[]} [nestedType] Nested message types\r\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\r\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\r\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\r\n * @property {IMessageOptions} [options] Not supported\r\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\r\n * @property {string[]} [reservedName] Reserved names\r\n */\r\n\r\n/**\r\n * Properties of a MessageOptions message.\r\n * @interface IMessageOptions\r\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\r\n */\r\n\r\n/**\r\n * Properties of an ExtensionRange message.\r\n * @interface IDescriptorProtoExtensionRange\r\n * @property {number} [start] Start field id\r\n * @property {number} [end] End field id\r\n */\r\n\r\n/**\r\n * Properties of a ReservedRange message.\r\n * @interface IDescriptorProtoReservedRange\r\n * @property {number} [start] Start field id\r\n * @property {number} [end] End field id\r\n */\r\n\r\nvar unnamedMessageIndex = 0;\r\n\r\n/**\r\n * Creates a type from a descriptor.\r\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n * @returns {Type} Type instance\r\n */\r\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.DescriptorProto.decode(descriptor);\r\n\r\n    // Create the message type\r\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\r\n        i;\r\n\r\n    /* Oneofs */ if (descriptor.oneofDecl)\r\n        for (i = 0; i < descriptor.oneofDecl.length; ++i)\r\n            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\r\n    /* Fields */ if (descriptor.field)\r\n        for (i = 0; i < descriptor.field.length; ++i) {\r\n            var field = Field.fromDescriptor(descriptor.field[i], syntax);\r\n            type.add(field);\r\n            if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) // eslint-disable-line no-prototype-builtins\r\n                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\r\n        }\r\n    /* Extension fields */ if (descriptor.extension)\r\n        for (i = 0; i < descriptor.extension.length; ++i)\r\n            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\r\n    /* Nested types */ if (descriptor.nestedType)\r\n        for (i = 0; i < descriptor.nestedType.length; ++i) {\r\n            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\r\n            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)\r\n                type.setOption(\"map_entry\", true);\r\n        }\r\n    /* Nested enums */ if (descriptor.enumType)\r\n        for (i = 0; i < descriptor.enumType.length; ++i)\r\n            type.add(Enum.fromDescriptor(descriptor.enumType[i]));\r\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\r\n        type.extensions = [];\r\n        for (i = 0; i < descriptor.extensionRange.length; ++i)\r\n            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);\r\n    }\r\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\r\n        type.reserved = [];\r\n        /* Ranges */ if (descriptor.reservedRange)\r\n            for (i = 0; i < descriptor.reservedRange.length; ++i)\r\n                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);\r\n        /* Names */ if (descriptor.reservedName)\r\n            for (i = 0; i < descriptor.reservedName.length; ++i)\r\n                type.reserved.push(descriptor.reservedName[i]);\r\n    }\r\n\r\n    return type;\r\n};\r\n\r\n/**\r\n * Converts a type to a descriptor.\r\n * @returns {Message<IDescriptorProto>} Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n */\r\nType.prototype.toDescriptor = function toDescriptor(syntax) {\r\n    var descriptor = exports.DescriptorProto.create({ name: this.name }),\r\n        i;\r\n\r\n    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {\r\n        var fieldDescriptor;\r\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\r\n        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry\r\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\r\n                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\r\n                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14\r\n                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type\r\n                    : undefined;\r\n            descriptor.nestedType.push(exports.DescriptorProto.create({\r\n                name: fieldDescriptor.typeName,\r\n                field: [\r\n                    exports.FieldDescriptorProto.create({ name: \"key\", number: 1, label: 1, type: keyType }), // can't reference a type or enum\r\n                    exports.FieldDescriptorProto.create({ name: \"value\", number: 2, label: 1, type: valueType, typeName: valueTypeName })\r\n                ],\r\n                options: exports.MessageOptions.create({ mapEntry: true })\r\n            }));\r\n        }\r\n    }\r\n    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)\r\n        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\r\n    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {\r\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field)\r\n            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\r\n        /* Types */ else if (this._nestedArray[i] instanceof Type)\r\n            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\r\n        /* Enums */ else if (this._nestedArray[i] instanceof Enum)\r\n            descriptor.enumType.push(this._nestedArray[i].toDescriptor());\r\n        // plain nested namespaces become packages instead in Root#toDescriptor\r\n    }\r\n    /* Extension ranges */ if (this.extensions)\r\n        for (i = 0; i < this.extensions.length; ++i)\r\n            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));\r\n    /* Reserved... */ if (this.reserved)\r\n        for (i = 0; i < this.reserved.length; ++i)\r\n            /* Names */ if (typeof this.reserved[i] === \"string\")\r\n                descriptor.reservedName.push(this.reserved[i]);\r\n            /* Ranges */ else\r\n                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));\r\n\r\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\r\n\r\n    return descriptor;\r\n};\r\n\r\n// --- Field ---\r\n\r\n/**\r\n * Properties of a FieldDescriptorProto message.\r\n * @interface IFieldDescriptorProto\r\n * @property {string} [name] Field name\r\n * @property {number} [number] Field id\r\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\r\n * @property {IFieldDescriptorProtoType} [type] Field basic type\r\n * @property {string} [typeName] Field type name\r\n * @property {string} [extendee] Extended type name\r\n * @property {string} [defaultValue] Literal default value\r\n * @property {number} [oneofIndex] Oneof index if part of a oneof\r\n * @property {*} [jsonName] Not supported\r\n * @property {IFieldOptions} [options] Field options\r\n */\r\n\r\n/**\r\n * Values of the FieldDescriptorProto.Label enum.\r\n * @typedef IFieldDescriptorProtoLabel\r\n * @type {number}\r\n * @property {number} LABEL_OPTIONAL=1\r\n * @property {number} LABEL_REQUIRED=2\r\n * @property {number} LABEL_REPEATED=3\r\n */\r\n\r\n/**\r\n * Values of the FieldDescriptorProto.Type enum.\r\n * @typedef IFieldDescriptorProtoType\r\n * @type {number}\r\n * @property {number} TYPE_DOUBLE=1\r\n * @property {number} TYPE_FLOAT=2\r\n * @property {number} TYPE_INT64=3\r\n * @property {number} TYPE_UINT64=4\r\n * @property {number} TYPE_INT32=5\r\n * @property {number} TYPE_FIXED64=6\r\n * @property {number} TYPE_FIXED32=7\r\n * @property {number} TYPE_BOOL=8\r\n * @property {number} TYPE_STRING=9\r\n * @property {number} TYPE_GROUP=10\r\n * @property {number} TYPE_MESSAGE=11\r\n * @property {number} TYPE_BYTES=12\r\n * @property {number} TYPE_UINT32=13\r\n * @property {number} TYPE_ENUM=14\r\n * @property {number} TYPE_SFIXED32=15\r\n * @property {number} TYPE_SFIXED64=16\r\n * @property {number} TYPE_SINT32=17\r\n * @property {number} TYPE_SINT64=18\r\n */\r\n\r\n/**\r\n * Properties of a FieldOptions message.\r\n * @interface IFieldOptions\r\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\r\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\r\n */\r\n\r\n/**\r\n * Values of the FieldOptions.JSType enum.\r\n * @typedef IFieldOptionsJSType\r\n * @type {number}\r\n * @property {number} JS_NORMAL=0\r\n * @property {number} JS_STRING=1\r\n * @property {number} JS_NUMBER=2\r\n */\r\n\r\n// copied here from parse.js\r\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\r\n\r\n/**\r\n * Creates a field from a descriptor.\r\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n * @returns {Field} Field instance\r\n */\r\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.DescriptorProto.decode(descriptor);\r\n\r\n    if (typeof descriptor.number !== \"number\")\r\n        throw Error(\"missing field id\");\r\n\r\n    // Rewire field type\r\n    var fieldType;\r\n    if (descriptor.typeName && descriptor.typeName.length)\r\n        fieldType = descriptor.typeName;\r\n    else\r\n        fieldType = fromDescriptorType(descriptor.type);\r\n\r\n    // Rewire field rule\r\n    var fieldRule;\r\n    switch (descriptor.label) {\r\n        // 0 is reserved for errors\r\n        case 1: fieldRule = undefined; break;\r\n        case 2: fieldRule = \"required\"; break;\r\n        case 3: fieldRule = \"repeated\"; break;\r\n        default: throw Error(\"illegal label: \" + descriptor.label);\r\n    }\r\n\r\n\tvar extendee = descriptor.extendee;\r\n\tif (descriptor.extendee !== undefined) {\r\n\t\textendee = extendee.length ? extendee : undefined;\r\n\t}\r\n    var field = new Field(\r\n        descriptor.name.length ? descriptor.name : \"field\" + descriptor.number,\r\n        descriptor.number,\r\n        fieldType,\r\n        fieldRule,\r\n        extendee\r\n    );\r\n\r\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\r\n\r\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\r\n        var defaultValue = descriptor.defaultValue;\r\n        switch (defaultValue) {\r\n            case \"true\": case \"TRUE\":\r\n                defaultValue = true;\r\n                break;\r\n            case \"false\": case \"FALSE\":\r\n                defaultValue = false;\r\n                break;\r\n            default:\r\n                var match = numberRe.exec(defaultValue);\r\n                if (match)\r\n                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix\r\n                break;\r\n        }\r\n        field.setOption(\"default\", defaultValue);\r\n    }\r\n\r\n    if (packableDescriptorType(descriptor.type)) {\r\n        if (syntax === \"proto3\") { // defaults to packed=true (internal preset is packed=true)\r\n            if (descriptor.options && !descriptor.options.packed)\r\n                field.setOption(\"packed\", false);\r\n        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false\r\n            field.setOption(\"packed\", false);\r\n    }\r\n\r\n    return field;\r\n};\r\n\r\n/**\r\n * Converts a field to a descriptor.\r\n * @returns {Message<IFieldDescriptorProto>} Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n */\r\nField.prototype.toDescriptor = function toDescriptor(syntax) {\r\n    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });\r\n\r\n    if (this.map) {\r\n\r\n        descriptor.type = 11; // message\r\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\r\n        descriptor.label = 3; // repeated\r\n\r\n    } else {\r\n\r\n        // Rewire field type\r\n        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\r\n            case 10: // group\r\n            case 11: // type\r\n            case 14: // enum\r\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\r\n                break;\r\n        }\r\n\r\n        // Rewire field rule\r\n        switch (this.rule) {\r\n            case \"repeated\": descriptor.label = 3; break;\r\n            case \"required\": descriptor.label = 2; break;\r\n            default: descriptor.label = 1; break;\r\n        }\r\n\r\n    }\r\n\r\n    // Handle extension field\r\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\r\n\r\n    // Handle part of oneof\r\n    if (this.partOf)\r\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)\r\n            throw Error(\"missing oneof\");\r\n\r\n    if (this.options) {\r\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\r\n        if (this.options[\"default\"] != null)\r\n            descriptor.defaultValue = String(this.options[\"default\"]);\r\n    }\r\n\r\n    if (syntax === \"proto3\") { // defaults to packed=true\r\n        if (!this.packed)\r\n            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\r\n    } else if (this.packed) // defaults to packed=false\r\n        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\r\n\r\n    return descriptor;\r\n};\r\n\r\n// --- Enum ---\r\n\r\n/**\r\n * Properties of an EnumDescriptorProto message.\r\n * @interface IEnumDescriptorProto\r\n * @property {string} [name] Enum name\r\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\r\n * @property {IEnumOptions} [options] Enum options\r\n */\r\n\r\n/**\r\n * Properties of an EnumValueDescriptorProto message.\r\n * @interface IEnumValueDescriptorProto\r\n * @property {string} [name] Name\r\n * @property {number} [number] Value\r\n * @property {*} [options] Not supported\r\n */\r\n\r\n/**\r\n * Properties of an EnumOptions message.\r\n * @interface IEnumOptions\r\n * @property {boolean} [allowAlias] Whether aliases are allowed\r\n * @property {boolean} [deprecated]\r\n */\r\n\r\nvar unnamedEnumIndex = 0;\r\n\r\n/**\r\n * Creates an enum from a descriptor.\r\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Enum} Enum instance\r\n */\r\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.EnumDescriptorProto.decode(descriptor);\r\n\r\n    // Construct values object\r\n    var values = {};\r\n    if (descriptor.value)\r\n        for (var i = 0; i < descriptor.value.length; ++i) {\r\n            var name  = descriptor.value[i].name,\r\n                value = descriptor.value[i].number || 0;\r\n            values[name && name.length ? name : \"NAME\" + value] = value;\r\n        }\r\n\r\n    return new Enum(\r\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++,\r\n        values,\r\n        fromDescriptorOptions(descriptor.options, exports.EnumOptions)\r\n    );\r\n};\r\n\r\n/**\r\n * Converts an enum to a descriptor.\r\n * @returns {Message<IEnumDescriptorProto>} Descriptor\r\n */\r\nEnum.prototype.toDescriptor = function toDescriptor() {\r\n\r\n    // Values\r\n    var values = [];\r\n    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)\r\n        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));\r\n\r\n    return exports.EnumDescriptorProto.create({\r\n        name: this.name,\r\n        value: values,\r\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\r\n    });\r\n};\r\n\r\n// --- OneOf ---\r\n\r\n/**\r\n * Properties of a OneofDescriptorProto message.\r\n * @interface IOneofDescriptorProto\r\n * @property {string} [name] Oneof name\r\n * @property {*} [options] Not supported\r\n */\r\n\r\nvar unnamedOneofIndex = 0;\r\n\r\n/**\r\n * Creates a oneof from a descriptor.\r\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {OneOf} OneOf instance\r\n */\r\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.OneofDescriptorProto.decode(descriptor);\r\n\r\n    return new OneOf(\r\n        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\r\n        descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++\r\n        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\r\n    );\r\n};\r\n\r\n/**\r\n * Converts a oneof to a descriptor.\r\n * @returns {Message<IOneofDescriptorProto>} Descriptor\r\n */\r\nOneOf.prototype.toDescriptor = function toDescriptor() {\r\n    return exports.OneofDescriptorProto.create({\r\n        name: this.name\r\n        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\r\n    });\r\n};\r\n\r\n// --- Service ---\r\n\r\n/**\r\n * Properties of a ServiceDescriptorProto message.\r\n * @interface IServiceDescriptorProto\r\n * @property {string} [name] Service name\r\n * @property {IMethodDescriptorProto[]} [method] Methods\r\n * @property {IServiceOptions} [options] Options\r\n */\r\n\r\n/**\r\n * Properties of a ServiceOptions message.\r\n * @interface IServiceOptions\r\n * @property {boolean} [deprecated]\r\n */\r\n\r\nvar unnamedServiceIndex = 0;\r\n\r\n/**\r\n * Creates a service from a descriptor.\r\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Service} Service instance\r\n */\r\nService.fromDescriptor = function fromDescriptor(descriptor) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.ServiceDescriptorProto.decode(descriptor);\r\n\r\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\r\n    if (descriptor.method)\r\n        for (var i = 0; i < descriptor.method.length; ++i)\r\n            service.add(Method.fromDescriptor(descriptor.method[i]));\r\n\r\n    return service;\r\n};\r\n\r\n/**\r\n * Converts a service to a descriptor.\r\n * @returns {Message<IServiceDescriptorProto>} Descriptor\r\n */\r\nService.prototype.toDescriptor = function toDescriptor() {\r\n\r\n    // Methods\r\n    var methods = [];\r\n    for (var i = 0; i < this.methodsArray.length; ++i)\r\n        methods.push(this._methodsArray[i].toDescriptor());\r\n\r\n    return exports.ServiceDescriptorProto.create({\r\n        name: this.name,\r\n        method: methods,\r\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\r\n    });\r\n};\r\n\r\n// --- Method ---\r\n\r\n/**\r\n * Properties of a MethodDescriptorProto message.\r\n * @interface IMethodDescriptorProto\r\n * @property {string} [name] Method name\r\n * @property {string} [inputType] Request type name\r\n * @property {string} [outputType] Response type name\r\n * @property {IMethodOptions} [options] Not supported\r\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\r\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\r\n */\r\n\r\n/**\r\n * Properties of a MethodOptions message.\r\n * @interface IMethodOptions\r\n * @property {boolean} [deprecated]\r\n */\r\n\r\nvar unnamedMethodIndex = 0;\r\n\r\n/**\r\n * Creates a method from a descriptor.\r\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Method} Reflected method instance\r\n */\r\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\r\n\r\n    // Decode the descriptor message if specified as a buffer:\r\n    if (typeof descriptor.length === \"number\")\r\n        descriptor = exports.MethodDescriptorProto.decode(descriptor);\r\n\r\n    return new Method(\r\n        // unnamedMethodIndex is global, not per service, because we have no ref to a service here\r\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++,\r\n        \"rpc\",\r\n        descriptor.inputType,\r\n        descriptor.outputType,\r\n        Boolean(descriptor.clientStreaming),\r\n        Boolean(descriptor.serverStreaming),\r\n        fromDescriptorOptions(descriptor.options, exports.MethodOptions)\r\n    );\r\n};\r\n\r\n/**\r\n * Converts a method to a descriptor.\r\n * @returns {Message<IMethodDescriptorProto>} Descriptor\r\n */\r\nMethod.prototype.toDescriptor = function toDescriptor() {\r\n    return exports.MethodDescriptorProto.create({\r\n        name: this.name,\r\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\r\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\r\n        clientStreaming: this.requestStream,\r\n        serverStreaming: this.responseStream,\r\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\r\n    });\r\n};\r\n\r\n// --- utility ---\r\n\r\n// Converts a descriptor type to a protobuf.js basic type\r\nfunction fromDescriptorType(type) {\r\n    switch (type) {\r\n        // 0 is reserved for errors\r\n        case 1: return \"double\";\r\n        case 2: return \"float\";\r\n        case 3: return \"int64\";\r\n        case 4: return \"uint64\";\r\n        case 5: return \"int32\";\r\n        case 6: return \"fixed64\";\r\n        case 7: return \"fixed32\";\r\n        case 8: return \"bool\";\r\n        case 9: return \"string\";\r\n        case 12: return \"bytes\";\r\n        case 13: return \"uint32\";\r\n        case 15: return \"sfixed32\";\r\n        case 16: return \"sfixed64\";\r\n        case 17: return \"sint32\";\r\n        case 18: return \"sint64\";\r\n    }\r\n    throw Error(\"illegal type: \" + type);\r\n}\r\n\r\n// Tests if a descriptor type is packable\r\nfunction packableDescriptorType(type) {\r\n    switch (type) {\r\n        case 1: // double\r\n        case 2: // float\r\n        case 3: // int64\r\n        case 4: // uint64\r\n        case 5: // int32\r\n        case 6: // fixed64\r\n        case 7: // fixed32\r\n        case 8: // bool\r\n        case 13: // uint32\r\n        case 14: // enum (!)\r\n        case 15: // sfixed32\r\n        case 16: // sfixed64\r\n        case 17: // sint32\r\n        case 18: // sint64\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n// Converts a protobuf.js basic type to a descriptor type\r\nfunction toDescriptorType(type, resolvedType) {\r\n    switch (type) {\r\n        // 0 is reserved for errors\r\n        case \"double\": return 1;\r\n        case \"float\": return 2;\r\n        case \"int64\": return 3;\r\n        case \"uint64\": return 4;\r\n        case \"int32\": return 5;\r\n        case \"fixed64\": return 6;\r\n        case \"fixed32\": return 7;\r\n        case \"bool\": return 8;\r\n        case \"string\": return 9;\r\n        case \"bytes\": return 12;\r\n        case \"uint32\": return 13;\r\n        case \"sfixed32\": return 15;\r\n        case \"sfixed64\": return 16;\r\n        case \"sint32\": return 17;\r\n        case \"sint64\": return 18;\r\n    }\r\n    if (resolvedType instanceof Enum)\r\n        return 14;\r\n    if (resolvedType instanceof Type)\r\n        return resolvedType.group ? 10 : 11;\r\n    throw Error(\"illegal type: \" + type);\r\n}\r\n\r\n// Converts descriptor options to an options object\r\nfunction fromDescriptorOptions(options, type) {\r\n    if (!options)\r\n        return undefined;\r\n    var out = [];\r\n    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)\r\n        if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\")\r\n            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins\r\n                val = options[key];\r\n                if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined)\r\n                    val = field.resolvedType.valuesById[val];\r\n                out.push(underScore(key), val);\r\n            }\r\n    return out.length ? $protobuf.util.toObject(out) : undefined;\r\n}\r\n\r\n// Converts an options object to descriptor options\r\nfunction toDescriptorOptions(options, type) {\r\n    if (!options)\r\n        return undefined;\r\n    var out = [];\r\n    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\r\n        val = options[key = ks[i]];\r\n        if (key === \"default\")\r\n            continue;\r\n        var field = type.fields[key];\r\n        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))\r\n            continue;\r\n        out.push(key, val);\r\n    }\r\n    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\r\n}\r\n\r\n// Calculates the shortest relative path from `from` to `to`.\r\nfunction shortname(from, to) {\r\n    var fromPath = from.fullName.split(\".\"),\r\n        toPath = to.fullName.split(\".\"),\r\n        i = 0,\r\n        j = 0,\r\n        k = toPath.length - 1;\r\n    if (!(from instanceof Root) && to instanceof Namespace)\r\n        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\r\n            var other = to.lookup(fromPath[i++], true);\r\n            if (other !== null && other !== to)\r\n                break;\r\n            ++j;\r\n        }\r\n    else\r\n        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\r\n    return toPath.slice(j).join(\".\");\r\n}\r\n\r\n// copied here from cli/targets/proto.js\r\nfunction underScore(str) {\r\n    return str.substring(0,1)\r\n         + str.substring(1)\r\n               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return \"_\" + $1.toLowerCase(); });\r\n}\r\n\r\n// --- exports ---\r\n\r\n/**\r\n * Reflected file descriptor set.\r\n * @name FileDescriptorSet\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected file descriptor proto.\r\n * @name FileDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected descriptor proto.\r\n * @name DescriptorProto\r\n * @type {Type}\r\n * @property {Type} ExtensionRange\r\n * @property {Type} ReservedRange\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     ExtensionRange: $protobuf.Type,\r\n *     ReservedRange: $protobuf.Type\r\n * }\r\n */\r\n\r\n/**\r\n * Reflected field descriptor proto.\r\n * @name FieldDescriptorProto\r\n * @type {Type}\r\n * @property {Enum} Label\r\n * @property {Enum} Type\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     Label: $protobuf.Enum,\r\n *     Type: $protobuf.Enum\r\n * }\r\n */\r\n\r\n/**\r\n * Reflected oneof descriptor proto.\r\n * @name OneofDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected enum descriptor proto.\r\n * @name EnumDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected service descriptor proto.\r\n * @name ServiceDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected enum value descriptor proto.\r\n * @name EnumValueDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected method descriptor proto.\r\n * @name MethodDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected file options.\r\n * @name FileOptions\r\n * @type {Type}\r\n * @property {Enum} OptimizeMode\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     OptimizeMode: $protobuf.Enum\r\n * }\r\n */\r\n\r\n/**\r\n * Reflected message options.\r\n * @name MessageOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected field options.\r\n * @name FieldOptions\r\n * @type {Type}\r\n * @property {Enum} CType\r\n * @property {Enum} JSType\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     CType: $protobuf.Enum,\r\n *     JSType: $protobuf.Enum\r\n * }\r\n */\r\n\r\n/**\r\n * Reflected oneof options.\r\n * @name OneofOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected enum options.\r\n * @name EnumOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected enum value options.\r\n * @name EnumValueOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected service options.\r\n * @name ServiceOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected method options.\r\n * @name MethodOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\r\n\r\n/**\r\n * Reflected uninterpretet option.\r\n * @name UninterpretedOption\r\n * @type {Type}\r\n * @property {Type} NamePart\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     NamePart: $protobuf.Type\r\n * }\r\n */\r\n\r\n/**\r\n * Reflected source code info.\r\n * @name SourceCodeInfo\r\n * @type {Type}\r\n * @property {Type} Location\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     Location: $protobuf.Type\r\n * }\r\n */\r\n\r\n/**\r\n * Reflected generated code info.\r\n * @name GeneratedCodeInfo\r\n * @type {Type}\r\n * @property {Type} Annotation\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     Annotation: $protobuf.Type\r\n * }\r\n */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9leHQvZGVzY3JpcHRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFPO0FBQy9CLDBFQUEwRSxtQkFBTyxDQUFDLHlJQUF1QztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMsY0FBYztBQUM1QixjQUFjLEdBQUc7QUFDakIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsMEJBQTBCO0FBQ3hDLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBGQUEwRjtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsa0NBQWtDO0FBQ2hELGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaURBQWlEO0FBQzNHLDBEQUEwRCw4RUFBOEU7QUFDeEk7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRCwyRkFBMkYsMERBQTBEO0FBQ3JKO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsc0RBQXNEO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLEdBQUc7QUFDakIsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsMkRBQTJELGtDQUFrQztBQUM3RjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsaUVBQWlFO0FBQ2pFLDhCQUE4QjtBQUM5QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsbURBQW1EO0FBQ25ELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLDZCQUE2QjtBQUMzQyxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRSw4REFBOEQseUNBQXlDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BELGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYywwQkFBMEI7QUFDeEMsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUEyQztBQUN0RCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUEwQztBQUNyRCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEU7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBMkQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZ0NBQWdDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3IvaW5kZXguanM/MzdlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCIuLi8uLlwiKTtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gJHByb3RvYnVmLmRlc2NyaXB0b3IgPSAkcHJvdG9idWYuUm9vdC5mcm9tSlNPTihyZXF1aXJlKFwiLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvblwiKSkubG9va3VwKFwiLmdvb2dsZS5wcm90b2J1ZlwiKTtcclxuXHJcbnZhciBOYW1lc3BhY2UgPSAkcHJvdG9idWYuTmFtZXNwYWNlLFxyXG4gICAgUm9vdCAgICAgID0gJHByb3RvYnVmLlJvb3QsXHJcbiAgICBFbnVtICAgICAgPSAkcHJvdG9idWYuRW51bSxcclxuICAgIFR5cGUgICAgICA9ICRwcm90b2J1Zi5UeXBlLFxyXG4gICAgRmllbGQgICAgID0gJHByb3RvYnVmLkZpZWxkLFxyXG4gICAgTWFwRmllbGQgID0gJHByb3RvYnVmLk1hcEZpZWxkLFxyXG4gICAgT25lT2YgICAgID0gJHByb3RvYnVmLk9uZU9mLFxyXG4gICAgU2VydmljZSAgID0gJHByb3RvYnVmLlNlcnZpY2UsXHJcbiAgICBNZXRob2QgICAgPSAkcHJvdG9idWYuTWV0aG9kO1xyXG5cclxuLy8gLS0tIFJvb3QgLS0tXHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBvZiBhIEZpbGVEZXNjcmlwdG9yU2V0IG1lc3NhZ2UuXHJcbiAqIEBpbnRlcmZhY2UgSUZpbGVEZXNjcmlwdG9yU2V0XHJcbiAqIEBwcm9wZXJ0eSB7SUZpbGVEZXNjcmlwdG9yUHJvdG9bXX0gZmlsZSBGaWxlc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmlsZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElGaWxlRGVzY3JpcHRvclByb3RvXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gRmlsZSBuYW1lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGFja2FnZV0gUGFja2FnZVxyXG4gKiBAcHJvcGVydHkgeyp9IFtkZXBlbmRlbmN5XSBOb3Qgc3VwcG9ydGVkXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gW3B1YmxpY0RlcGVuZGVuY3ldIE5vdCBzdXBwb3J0ZWRcclxuICogQHByb3BlcnR5IHsqfSBbd2Vha0RlcGVuZGVuY3ldIE5vdCBzdXBwb3J0ZWRcclxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvW119IFttZXNzYWdlVHlwZV0gTmVzdGVkIG1lc3NhZ2UgdHlwZXNcclxuICogQHByb3BlcnR5IHtJRW51bURlc2NyaXB0b3JQcm90b1tdfSBbZW51bVR5cGVdIE5lc3RlZCBlbnVtc1xyXG4gKiBAcHJvcGVydHkge0lTZXJ2aWNlRGVzY3JpcHRvclByb3RvW119IFtzZXJ2aWNlXSBOZXN0ZWQgc2VydmljZXNcclxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2V4dGVuc2lvbl0gTmVzdGVkIGV4dGVuc2lvbiBmaWVsZHNcclxuICogQHByb3BlcnR5IHtJRmlsZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gW3NvdXJjZUNvZGVJbmZvXSBOb3Qgc3VwcG9ydGVkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmlsZU9wdGlvbnMgbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJRmlsZU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtqYXZhUGFja2FnZV1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtqYXZhT3V0ZXJDbGFzc25hbWVdXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2phdmFNdWx0aXBsZUZpbGVzXVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoXVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhU3RyaW5nQ2hlY2tVdGY4XVxyXG4gKiBAcHJvcGVydHkge0lGaWxlT3B0aW9uc09wdGltaXplTW9kZX0gW29wdGltaXplRm9yPTFdXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ29QYWNrYWdlXVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjY0dlbmVyaWNTZXJ2aWNlc11cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YUdlbmVyaWNTZXJ2aWNlc11cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHlHZW5lcmljU2VydmljZXNdXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NjRW5hYmxlQXJlbmFzXVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29iamNDbGFzc1ByZWZpeF1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjc2hhcnBOYW1lc3BhY2VdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFZhbHVlcyBvZiBoZSBGaWxlT3B0aW9ucy5PcHRpbWl6ZU1vZGUgZW51bS5cclxuICogQHR5cGVkZWYgSUZpbGVPcHRpb25zT3B0aW1pemVNb2RlXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUEVFRD0xXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0RFX1NJWkU9MlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTElURV9SVU5USU1FPTNcclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJvb3QgZnJvbSBhIGRlc2NyaXB0b3Igc2V0LlxyXG4gKiBAcGFyYW0ge0lGaWxlRGVzY3JpcHRvclNldHxSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtSb290fSBSb290IGluc3RhbmNlXHJcbiAqL1xyXG5Sb290LmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xyXG5cclxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcclxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRmlsZURlc2NyaXB0b3JTZXQuZGVjb2RlKGRlc2NyaXB0b3IpO1xyXG5cclxuICAgIHZhciByb290ID0gbmV3IFJvb3QoKTtcclxuXHJcbiAgICBpZiAoZGVzY3JpcHRvci5maWxlKSB7XHJcbiAgICAgICAgdmFyIGZpbGVEZXNjcmlwdG9yLFxyXG4gICAgICAgICAgICBmaWxlUGFja2FnZTtcclxuICAgICAgICBmb3IgKHZhciBqID0gMCwgaTsgaiA8IGRlc2NyaXB0b3IuZmlsZS5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICBmaWxlUGFja2FnZSA9IHJvb3Q7XHJcbiAgICAgICAgICAgIGlmICgoZmlsZURlc2NyaXB0b3IgPSBkZXNjcmlwdG9yLmZpbGVbal0pW1wicGFja2FnZVwiXSAmJiBmaWxlRGVzY3JpcHRvcltcInBhY2thZ2VcIl0ubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UgPSByb290LmRlZmluZShmaWxlRGVzY3JpcHRvcltcInBhY2thZ2VcIl0pO1xyXG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IubmFtZSAmJiBmaWxlRGVzY3JpcHRvci5uYW1lLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJvb3QuZmlsZXMucHVzaChmaWxlUGFja2FnZS5maWxlbmFtZSA9IGZpbGVEZXNjcmlwdG9yLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGUpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGUubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UuYWRkKFR5cGUuZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGVbaV0sIGZpbGVEZXNjcmlwdG9yLnN5bnRheCkpO1xyXG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IuZW51bVR5cGUpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IuZW51bVR5cGUubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UuYWRkKEVudW0uZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IuZW51bVR5cGVbaV0pKTtcclxuICAgICAgICAgICAgaWYgKGZpbGVEZXNjcmlwdG9yLmV4dGVuc2lvbilcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5leHRlbnNpb24ubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UuYWRkKEZpZWxkLmZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yLmV4dGVuc2lvbltpXSkpO1xyXG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3Iuc2VydmljZSlcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5zZXJ2aWNlLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChTZXJ2aWNlLmZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yLnNlcnZpY2VbaV0pKTtcclxuICAgICAgICAgICAgdmFyIG9wdHMgPSBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZmlsZURlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5GaWxlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChvcHRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga3MgPSBPYmplY3Qua2V5cyhvcHRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5zZXRPcHRpb24oa3NbaV0sIG9wdHNba3NbaV1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHJvb3QgdG8gYSBkZXNjcmlwdG9yIHNldC5cclxuICogQHJldHVybnMge01lc3NhZ2U8SUZpbGVEZXNjcmlwdG9yU2V0Pn0gRGVzY3JpcHRvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcclxuICovXHJcblJvb3QucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcihzeW50YXgpIHtcclxuICAgIHZhciBzZXQgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yU2V0LmNyZWF0ZSgpO1xyXG4gICAgUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUodGhpcywgc2V0LmZpbGUsIHN5bnRheCk7XHJcbiAgICByZXR1cm4gc2V0O1xyXG59O1xyXG5cclxuLy8gVHJhdmVyc2VzIGEgbmFtZXNwYWNlIGFuZCBhc3NlbWJsZXMgdGhlIGRlc2NyaXB0b3Igc2V0XHJcbmZ1bmN0aW9uIFJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlKG5zLCBmaWxlcywgc3ludGF4KSB7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGZpbGVcclxuICAgIHZhciBmaWxlID0gZXhwb3J0cy5GaWxlRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IG5zLmZpbGVuYW1lIHx8IChucy5mdWxsTmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvXFwuL2csIFwiX1wiKSB8fCBcInJvb3RcIikgKyBcIi5wcm90b1wiIH0pO1xyXG4gICAgaWYgKHN5bnRheClcclxuICAgICAgICBmaWxlLnN5bnRheCA9IHN5bnRheDtcclxuICAgIGlmICghKG5zIGluc3RhbmNlb2YgUm9vdCkpXHJcbiAgICAgICAgZmlsZVtcInBhY2thZ2VcIl0gPSBucy5mdWxsTmFtZS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gICAgLy8gQWRkIG5lc3RlZCB0eXBlc1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIG5lc3RlZDsgaSA8IG5zLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgIGlmICgobmVzdGVkID0gbnMuX25lc3RlZEFycmF5W2ldKSBpbnN0YW5jZW9mIFR5cGUpXHJcbiAgICAgICAgICAgIGZpbGUubWVzc2FnZVR5cGUucHVzaChuZXN0ZWQudG9EZXNjcmlwdG9yKHN5bnRheCkpO1xyXG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIEVudW0pXHJcbiAgICAgICAgICAgIGZpbGUuZW51bVR5cGUucHVzaChuZXN0ZWQudG9EZXNjcmlwdG9yKCkpO1xyXG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIEZpZWxkKVxyXG4gICAgICAgICAgICBmaWxlLmV4dGVuc2lvbi5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XHJcbiAgICAgICAgZWxzZSBpZiAobmVzdGVkIGluc3RhbmNlb2YgU2VydmljZSlcclxuICAgICAgICAgICAgZmlsZS5zZXJ2aWNlLnB1c2gobmVzdGVkLnRvRGVzY3JpcHRvcigpKTtcclxuICAgICAgICBlbHNlIGlmIChuZXN0ZWQgaW5zdGFuY2VvZiAvKiBwbGFpbiAqLyBOYW1lc3BhY2UpXHJcbiAgICAgICAgICAgIFJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlKG5lc3RlZCwgZmlsZXMsIHN5bnRheCk7IC8vIHJlcXVpcmVzIG5ldyBmaWxlXHJcblxyXG4gICAgLy8gS2VlcCBwYWNrYWdlLWxldmVsIG9wdGlvbnNcclxuICAgIGZpbGUub3B0aW9ucyA9IHRvRGVzY3JpcHRvck9wdGlvbnMobnMub3B0aW9ucywgZXhwb3J0cy5GaWxlT3B0aW9ucyk7XHJcblxyXG4gICAgLy8gQW5kIGtlZXAgdGhlIGZpbGUgb25seSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbmVzdGVkIG9iamVjdFxyXG4gICAgaWYgKGZpbGUubWVzc2FnZVR5cGUubGVuZ3RoICsgZmlsZS5lbnVtVHlwZS5sZW5ndGggKyBmaWxlLmV4dGVuc2lvbi5sZW5ndGggKyBmaWxlLnNlcnZpY2UubGVuZ3RoKVxyXG4gICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XHJcbn1cclxuXHJcbi8vIC0tLSBUeXBlIC0tLVxyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgb2YgYSBEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJRGVzY3JpcHRvclByb3RvXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gTWVzc2FnZSB0eXBlIG5hbWVcclxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2ZpZWxkXSBGaWVsZHNcclxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2V4dGVuc2lvbl0gRXh0ZW5zaW9uIGZpZWxkc1xyXG4gKiBAcHJvcGVydHkge0lEZXNjcmlwdG9yUHJvdG9bXX0gW25lc3RlZFR5cGVdIE5lc3RlZCBtZXNzYWdlIHR5cGVzXHJcbiAqIEBwcm9wZXJ0eSB7SUVudW1EZXNjcmlwdG9yUHJvdG9bXX0gW2VudW1UeXBlXSBOZXN0ZWQgZW51bXNcclxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvRXh0ZW5zaW9uUmFuZ2VbXX0gW2V4dGVuc2lvblJhbmdlXSBFeHRlbnNpb24gcmFuZ2VzXHJcbiAqIEBwcm9wZXJ0eSB7SU9uZW9mRGVzY3JpcHRvclByb3RvW119IFtvbmVvZkRlY2xdIE9uZW9mc1xyXG4gKiBAcHJvcGVydHkge0lNZXNzYWdlT3B0aW9uc30gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcclxuICogQHByb3BlcnR5IHtJRGVzY3JpcHRvclByb3RvUmVzZXJ2ZWRSYW5nZVtdfSBbcmVzZXJ2ZWRSYW5nZV0gUmVzZXJ2ZWQgcmFuZ2VzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtyZXNlcnZlZE5hbWVdIFJlc2VydmVkIG5hbWVzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgb2YgYSBNZXNzYWdlT3B0aW9ucyBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElNZXNzYWdlT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXBFbnRyeT1mYWxzZV0gV2hldGhlciB0aGlzIG1lc3NhZ2UgaXMgYSBtYXAgZW50cnlcclxuICovXHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBvZiBhbiBFeHRlbnNpb25SYW5nZSBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElEZXNjcmlwdG9yUHJvdG9FeHRlbnNpb25SYW5nZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0YXJ0XSBTdGFydCBmaWVsZCBpZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2VuZF0gRW5kIGZpZWxkIGlkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgb2YgYSBSZXNlcnZlZFJhbmdlIG1lc3NhZ2UuXHJcbiAqIEBpbnRlcmZhY2UgSURlc2NyaXB0b3JQcm90b1Jlc2VydmVkUmFuZ2VcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdGFydF0gU3RhcnQgZmllbGQgaWRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlbmRdIEVuZCBmaWVsZCBpZFxyXG4gKi9cclxuXHJcbnZhciB1bm5hbWVkTWVzc2FnZUluZGV4ID0gMDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgdHlwZSBmcm9tIGEgZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtJRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IFtzeW50YXg9XCJwcm90bzJcIl0gU3ludGF4XHJcbiAqIEByZXR1cm5zIHtUeXBlfSBUeXBlIGluc3RhbmNlXHJcbiAqL1xyXG5UeXBlLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvciwgc3ludGF4KSB7XHJcblxyXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxyXG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgbWVzc2FnZSB0eXBlXHJcbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIlR5cGVcIiArIHVubmFtZWRNZXNzYWdlSW5kZXgrKywgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5NZXNzYWdlT3B0aW9ucykpLFxyXG4gICAgICAgIGk7XHJcblxyXG4gICAgLyogT25lb2ZzICovIGlmIChkZXNjcmlwdG9yLm9uZW9mRGVjbClcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5vbmVvZkRlY2wubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3Iub25lb2ZEZWNsW2ldKSk7XHJcbiAgICAvKiBGaWVsZHMgKi8gaWYgKGRlc2NyaXB0b3IuZmllbGQpXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IuZmllbGQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkID0gRmllbGQuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5maWVsZFtpXSwgc3ludGF4KTtcclxuICAgICAgICAgICAgdHlwZS5hZGQoZmllbGQpO1xyXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5maWVsZFtpXS5oYXNPd25Qcm9wZXJ0eShcIm9uZW9mSW5kZXhcIikpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgICAgICAgICB0eXBlLm9uZW9mc0FycmF5W2Rlc2NyaXB0b3IuZmllbGRbaV0ub25lb2ZJbmRleF0uYWRkKGZpZWxkKTtcclxuICAgICAgICB9XHJcbiAgICAvKiBFeHRlbnNpb24gZmllbGRzICovIGlmIChkZXNjcmlwdG9yLmV4dGVuc2lvbilcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5leHRlbnNpb24ubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHR5cGUuYWRkKEZpZWxkLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IuZXh0ZW5zaW9uW2ldLCBzeW50YXgpKTtcclxuICAgIC8qIE5lc3RlZCB0eXBlcyAqLyBpZiAoZGVzY3JpcHRvci5uZXN0ZWRUeXBlKVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLm5lc3RlZFR5cGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdHlwZS5hZGQoVHlwZS5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLm5lc3RlZFR5cGVbaV0sIHN5bnRheCkpO1xyXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5uZXN0ZWRUeXBlW2ldLm9wdGlvbnMgJiYgZGVzY3JpcHRvci5uZXN0ZWRUeXBlW2ldLm9wdGlvbnMubWFwRW50cnkpXHJcbiAgICAgICAgICAgICAgICB0eXBlLnNldE9wdGlvbihcIm1hcF9lbnRyeVwiLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAvKiBOZXN0ZWQgZW51bXMgKi8gaWYgKGRlc2NyaXB0b3IuZW51bVR5cGUpXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IuZW51bVR5cGUubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHR5cGUuYWRkKEVudW0uZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5lbnVtVHlwZVtpXSkpO1xyXG4gICAgLyogRXh0ZW5zaW9uIHJhbmdlcyAqLyBpZiAoZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZSAmJiBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlLmxlbmd0aCkge1xyXG4gICAgICAgIHR5cGUuZXh0ZW5zaW9ucyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB0eXBlLmV4dGVuc2lvbnMucHVzaChbIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2VbaV0uc3RhcnQsIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2VbaV0uZW5kIF0pO1xyXG4gICAgfVxyXG4gICAgLyogUmVzZXJ2ZWQuLi4gKi8gaWYgKGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZSAmJiBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UubGVuZ3RoIHx8IGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lICYmIGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lLmxlbmd0aCkge1xyXG4gICAgICAgIHR5cGUucmVzZXJ2ZWQgPSBbXTtcclxuICAgICAgICAvKiBSYW5nZXMgKi8gaWYgKGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZSlcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZS5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIHR5cGUucmVzZXJ2ZWQucHVzaChbIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZVtpXS5zdGFydCwgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlW2ldLmVuZCBdKTtcclxuICAgICAgICAvKiBOYW1lcyAqLyBpZiAoZGVzY3JpcHRvci5yZXNlcnZlZE5hbWUpXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZS5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIHR5cGUucmVzZXJ2ZWQucHVzaChkZXNjcmlwdG9yLnJlc2VydmVkTmFtZVtpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR5cGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSB0eXBlIHRvIGEgZGVzY3JpcHRvci5cclxuICogQHJldHVybnMge01lc3NhZ2U8SURlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IFtzeW50YXg9XCJwcm90bzJcIl0gU3ludGF4XHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3Ioc3ludGF4KSB7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IHRoaXMubmFtZSB9KSxcclxuICAgICAgICBpO1xyXG5cclxuICAgIC8qIEZpZWxkcyAqLyBmb3IgKGkgPSAwOyBpIDwgdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBmaWVsZERlc2NyaXB0b3I7XHJcbiAgICAgICAgZGVzY3JpcHRvci5maWVsZC5wdXNoKGZpZWxkRGVzY3JpcHRvciA9IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnRvRGVzY3JpcHRvcihzeW50YXgpKTtcclxuICAgICAgICBpZiAodGhpcy5fZmllbGRzQXJyYXlbaV0gaW5zdGFuY2VvZiBNYXBGaWVsZCkgeyAvLyBtYXAgZmllbGRzIGFyZSByZXBlYXRlZCBGaWVsZE5hbWVFbnRyeVxyXG4gICAgICAgICAgICB2YXIga2V5VHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy5fZmllbGRzQXJyYXlbaV0ua2V5VHlwZSwgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRLZXlUeXBlKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy5fZmllbGRzQXJyYXlbaV0udHlwZSwgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRUeXBlKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGUgPT09IC8qIHR5cGUgKi8gMTEgfHwgdmFsdWVUeXBlID09PSAvKiBlbnVtICovIDE0XHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZFR5cGUgJiYgc2hvcnRuYW1lKHRoaXMucGFyZW50LCB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZFR5cGUpIHx8IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnR5cGVcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgZGVzY3JpcHRvci5uZXN0ZWRUeXBlLnB1c2goZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkRGVzY3JpcHRvci50eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgIGZpZWxkOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5GaWVsZERlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiBcImtleVwiLCBudW1iZXI6IDEsIGxhYmVsOiAxLCB0eXBlOiBrZXlUeXBlIH0pLCAvLyBjYW4ndCByZWZlcmVuY2UgYSB0eXBlIG9yIGVudW1cclxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkZpZWxkRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IFwidmFsdWVcIiwgbnVtYmVyOiAyLCBsYWJlbDogMSwgdHlwZTogdmFsdWVUeXBlLCB0eXBlTmFtZTogdmFsdWVUeXBlTmFtZSB9KVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cG9ydHMuTWVzc2FnZU9wdGlvbnMuY3JlYXRlKHsgbWFwRW50cnk6IHRydWUgfSlcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIE9uZW9mcyAqLyBmb3IgKGkgPSAwOyBpIDwgdGhpcy5vbmVvZnNBcnJheS5sZW5ndGg7ICsraSlcclxuICAgICAgICBkZXNjcmlwdG9yLm9uZW9mRGVjbC5wdXNoKHRoaXMuX29uZW9mc0FycmF5W2ldLnRvRGVzY3JpcHRvcigpKTtcclxuICAgIC8qIE5lc3RlZC4uLiAqLyBmb3IgKGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIC8qIEV4dGVuc2lvbiBmaWVsZHMgKi8gaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgRmllbGQpXHJcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZmllbGQucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XHJcbiAgICAgICAgLyogVHlwZXMgKi8gZWxzZSBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBUeXBlKVxyXG4gICAgICAgICAgICBkZXNjcmlwdG9yLm5lc3RlZFR5cGUucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XHJcbiAgICAgICAgLyogRW51bXMgKi8gZWxzZSBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBFbnVtKVxyXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1UeXBlLnB1c2godGhpcy5fbmVzdGVkQXJyYXlbaV0udG9EZXNjcmlwdG9yKCkpO1xyXG4gICAgICAgIC8vIHBsYWluIG5lc3RlZCBuYW1lc3BhY2VzIGJlY29tZSBwYWNrYWdlcyBpbnN0ZWFkIGluIFJvb3QjdG9EZXNjcmlwdG9yXHJcbiAgICB9XHJcbiAgICAvKiBFeHRlbnNpb24gcmFuZ2VzICovIGlmICh0aGlzLmV4dGVuc2lvbnMpXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZS5wdXNoKGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLkV4dGVuc2lvblJhbmdlLmNyZWF0ZSh7IHN0YXJ0OiB0aGlzLmV4dGVuc2lvbnNbaV1bMF0sIGVuZDogdGhpcy5leHRlbnNpb25zW2ldWzFdIH0pKTtcclxuICAgIC8qIFJlc2VydmVkLi4uICovIGlmICh0aGlzLnJlc2VydmVkKVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlc2VydmVkLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAvKiBOYW1lcyAqLyBpZiAodHlwZW9mIHRoaXMucmVzZXJ2ZWRbaV0gPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZS5wdXNoKHRoaXMucmVzZXJ2ZWRbaV0pO1xyXG4gICAgICAgICAgICAvKiBSYW5nZXMgKi8gZWxzZVxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlLnB1c2goZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uUmVzZXJ2ZWRSYW5nZS5jcmVhdGUoeyBzdGFydDogdGhpcy5yZXNlcnZlZFtpXVswXSwgZW5kOiB0aGlzLnJlc2VydmVkW2ldWzFdIH0pKTtcclxuXHJcbiAgICBkZXNjcmlwdG9yLm9wdGlvbnMgPSB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5NZXNzYWdlT3B0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XHJcbn07XHJcblxyXG4vLyAtLS0gRmllbGQgLS0tXHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBvZiBhIEZpZWxkRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXHJcbiAqIEBpbnRlcmZhY2UgSUZpZWxkRGVzY3JpcHRvclByb3RvXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gRmllbGQgbmFtZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlcl0gRmllbGQgaWRcclxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9MYWJlbH0gW2xhYmVsXSBGaWVsZCBydWxlXHJcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkRGVzY3JpcHRvclByb3RvVHlwZX0gW3R5cGVdIEZpZWxkIGJhc2ljIHR5cGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlTmFtZV0gRmllbGQgdHlwZSBuYW1lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXh0ZW5kZWVdIEV4dGVuZGVkIHR5cGUgbmFtZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RlZmF1bHRWYWx1ZV0gTGl0ZXJhbCBkZWZhdWx0IHZhbHVlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb25lb2ZJbmRleF0gT25lb2YgaW5kZXggaWYgcGFydCBvZiBhIG9uZW9mXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gW2pzb25OYW1lXSBOb3Qgc3VwcG9ydGVkXHJcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkT3B0aW9uc30gW29wdGlvbnNdIEZpZWxkIG9wdGlvbnNcclxuICovXHJcblxyXG4vKipcclxuICogVmFsdWVzIG9mIHRoZSBGaWVsZERlc2NyaXB0b3JQcm90by5MYWJlbCBlbnVtLlxyXG4gKiBAdHlwZWRlZiBJRmllbGREZXNjcmlwdG9yUHJvdG9MYWJlbFxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfT1BUSU9OQUw9MVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfUkVRVUlSRUQ9MlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfUkVQRUFURUQ9M1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBWYWx1ZXMgb2YgdGhlIEZpZWxkRGVzY3JpcHRvclByb3RvLlR5cGUgZW51bS5cclxuICogQHR5cGVkZWYgSUZpZWxkRGVzY3JpcHRvclByb3RvVHlwZVxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9ET1VCTEU9MVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GTE9BVD0yXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0lOVDY0PTNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfVUlOVDY0PTRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfSU5UMzI9NVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GSVhFRDY0PTZcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRklYRUQzMj03XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0JPT0w9OFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TVFJJTkc9OVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9HUk9VUD0xMFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9NRVNTQUdFPTExXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0JZVEVTPTEyXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1VJTlQzMj0xM1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9FTlVNPTE0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NGSVhFRDMyPTE1XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NGSVhFRDY0PTE2XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NJTlQzMj0xN1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TSU5UNjQ9MThcclxuICovXHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBvZiBhIEZpZWxkT3B0aW9ucyBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElGaWVsZE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGFja2VkXSBXaGV0aGVyIHBhY2tlZCBvciBub3QgKGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHByb3RvMiBhbmQgYHRydWVgIGZvciBwcm90bzMpXHJcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkT3B0aW9uc0pTVHlwZX0gW2pzdHlwZV0gSmF2YVNjcmlwdCB2YWx1ZSB0eXBlIChub3QgdXNlZCBieSBwcm90b2J1Zi5qcylcclxuICovXHJcblxyXG4vKipcclxuICogVmFsdWVzIG9mIHRoZSBGaWVsZE9wdGlvbnMuSlNUeXBlIGVudW0uXHJcbiAqIEB0eXBlZGVmIElGaWVsZE9wdGlvbnNKU1R5cGVcclxuICogQHR5cGUge251bWJlcn1cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IEpTX05PUk1BTD0wXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBKU19TVFJJTkc9MVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gSlNfTlVNQkVSPTJcclxuICovXHJcblxyXG4vLyBjb3BpZWQgaGVyZSBmcm9tIHBhcnNlLmpzXHJcbnZhciBudW1iZXJSZSA9IC9eKD8hW2VFXSlbMC05XSooPzpcXC5bMC05XSopPyg/OltlRV1bKy1dP1swLTldKyk/JC87XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGZpZWxkIGZyb20gYSBkZXNjcmlwdG9yLlxyXG4gKiBAcGFyYW0ge0lGaWVsZERlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3ludGF4PVwicHJvdG8yXCJdIFN5bnRheFxyXG4gKiBAcmV0dXJucyB7RmllbGR9IEZpZWxkIGluc3RhbmNlXHJcbiAqL1xyXG5GaWVsZC5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IsIHN5bnRheCkge1xyXG5cclxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcclxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubnVtYmVyICE9PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwibWlzc2luZyBmaWVsZCBpZFwiKTtcclxuXHJcbiAgICAvLyBSZXdpcmUgZmllbGQgdHlwZVxyXG4gICAgdmFyIGZpZWxkVHlwZTtcclxuICAgIGlmIChkZXNjcmlwdG9yLnR5cGVOYW1lICYmIGRlc2NyaXB0b3IudHlwZU5hbWUubGVuZ3RoKVxyXG4gICAgICAgIGZpZWxkVHlwZSA9IGRlc2NyaXB0b3IudHlwZU5hbWU7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgZmllbGRUeXBlID0gZnJvbURlc2NyaXB0b3JUeXBlKGRlc2NyaXB0b3IudHlwZSk7XHJcblxyXG4gICAgLy8gUmV3aXJlIGZpZWxkIHJ1bGVcclxuICAgIHZhciBmaWVsZFJ1bGU7XHJcbiAgICBzd2l0Y2ggKGRlc2NyaXB0b3IubGFiZWwpIHtcclxuICAgICAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnNcclxuICAgICAgICBjYXNlIDE6IGZpZWxkUnVsZSA9IHVuZGVmaW5lZDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOiBmaWVsZFJ1bGUgPSBcInJlcXVpcmVkXCI7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzogZmllbGRSdWxlID0gXCJyZXBlYXRlZFwiOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBFcnJvcihcImlsbGVnYWwgbGFiZWw6IFwiICsgZGVzY3JpcHRvci5sYWJlbCk7XHJcbiAgICB9XHJcblxyXG5cdHZhciBleHRlbmRlZSA9IGRlc2NyaXB0b3IuZXh0ZW5kZWU7XHJcblx0aWYgKGRlc2NyaXB0b3IuZXh0ZW5kZWUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZXh0ZW5kZWUgPSBleHRlbmRlZS5sZW5ndGggPyBleHRlbmRlZSA6IHVuZGVmaW5lZDtcclxuXHR9XHJcbiAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQoXHJcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiZmllbGRcIiArIGRlc2NyaXB0b3IubnVtYmVyLFxyXG4gICAgICAgIGRlc2NyaXB0b3IubnVtYmVyLFxyXG4gICAgICAgIGZpZWxkVHlwZSxcclxuICAgICAgICBmaWVsZFJ1bGUsXHJcbiAgICAgICAgZXh0ZW5kZWVcclxuICAgICk7XHJcblxyXG4gICAgZmllbGQub3B0aW9ucyA9IGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuRmllbGRPcHRpb25zKTtcclxuXHJcbiAgICBpZiAoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUgJiYgZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IGNhc2UgXCJUUlVFXCI6XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiBjYXNlIFwiRkFMU0VcIjpcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBudW1iZXJSZS5leGVjKGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdFZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByYWRpeFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkLnNldE9wdGlvbihcImRlZmF1bHRcIiwgZGVmYXVsdFZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGFja2FibGVEZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yLnR5cGUpKSB7XHJcbiAgICAgICAgaWYgKHN5bnRheCA9PT0gXCJwcm90bzNcIikgeyAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSAoaW50ZXJuYWwgcHJlc2V0IGlzIHBhY2tlZD10cnVlKVxyXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5vcHRpb25zICYmICFkZXNjcmlwdG9yLm9wdGlvbnMucGFja2VkKVxyXG4gICAgICAgICAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwicGFja2VkXCIsIGZhbHNlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEoZGVzY3JpcHRvci5vcHRpb25zICYmIGRlc2NyaXB0b3Iub3B0aW9ucy5wYWNrZWQpKSAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9ZmFsc2VcclxuICAgICAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwicGFja2VkXCIsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmllbGQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBmaWVsZCB0byBhIGRlc2NyaXB0b3IuXHJcbiAqIEByZXR1cm5zIHtNZXNzYWdlPElGaWVsZERlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IFtzeW50YXg9XCJwcm90bzJcIl0gU3ludGF4XHJcbiAqL1xyXG5GaWVsZC5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKHN5bnRheCkge1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBleHBvcnRzLkZpZWxkRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IHRoaXMubmFtZSwgbnVtYmVyOiB0aGlzLmlkIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLm1hcCkge1xyXG5cclxuICAgICAgICBkZXNjcmlwdG9yLnR5cGUgPSAxMTsgLy8gbWVzc2FnZVxyXG4gICAgICAgIGRlc2NyaXB0b3IudHlwZU5hbWUgPSAkcHJvdG9idWYudXRpbC51Y0ZpcnN0KHRoaXMubmFtZSk7IC8vIGZpZWxkTmFtZSAtPiBGaWVsZE5hbWVFbnRyeSAoYnVpbHQgaW4gVHlwZSN0b0Rlc2NyaXB0b3IpXHJcbiAgICAgICAgZGVzY3JpcHRvci5sYWJlbCA9IDM7IC8vIHJlcGVhdGVkXHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gUmV3aXJlIGZpZWxkIHR5cGVcclxuICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3IudHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy50eXBlLCB0aGlzLnJlc29sdmUoKS5yZXNvbHZlZFR5cGUpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6IC8vIGdyb3VwXHJcbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIHR5cGVcclxuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW51bVxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci50eXBlTmFtZSA9IHRoaXMucmVzb2x2ZWRUeXBlID8gc2hvcnRuYW1lKHRoaXMucGFyZW50LCB0aGlzLnJlc29sdmVkVHlwZSkgOiB0aGlzLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJld2lyZSBmaWVsZCBydWxlXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnJ1bGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6IGRlc2NyaXB0b3IubGFiZWwgPSAzOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6IGRlc2NyaXB0b3IubGFiZWwgPSAyOyBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogZGVzY3JpcHRvci5sYWJlbCA9IDE7IGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIGV4dGVuc2lvbiBmaWVsZFxyXG4gICAgZGVzY3JpcHRvci5leHRlbmRlZSA9IHRoaXMuZXh0ZW5zaW9uRmllbGQgPyB0aGlzLmV4dGVuc2lvbkZpZWxkLnBhcmVudC5mdWxsTmFtZSA6IHRoaXMuZXh0ZW5kO1xyXG5cclxuICAgIC8vIEhhbmRsZSBwYXJ0IG9mIG9uZW9mXHJcbiAgICBpZiAodGhpcy5wYXJ0T2YpXHJcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yLm9uZW9mSW5kZXggPSB0aGlzLnBhcmVudC5vbmVvZnNBcnJheS5pbmRleE9mKHRoaXMucGFydE9mKSkgPCAwKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm1pc3Npbmcgb25lb2ZcIik7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucykge1xyXG4gICAgICAgIGRlc2NyaXB0b3Iub3B0aW9ucyA9IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLkZpZWxkT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbClcclxuICAgICAgICAgICAgZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUgPSBTdHJpbmcodGhpcy5vcHRpb25zW1wiZGVmYXVsdFwiXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN5bnRheCA9PT0gXCJwcm90bzNcIikgeyAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZVxyXG4gICAgICAgIGlmICghdGhpcy5wYWNrZWQpXHJcbiAgICAgICAgICAgIChkZXNjcmlwdG9yLm9wdGlvbnMgfHwgKGRlc2NyaXB0b3Iub3B0aW9ucyA9IGV4cG9ydHMuRmllbGRPcHRpb25zLmNyZWF0ZSgpKSkucGFja2VkID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFja2VkKSAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9ZmFsc2VcclxuICAgICAgICAoZGVzY3JpcHRvci5vcHRpb25zIHx8IChkZXNjcmlwdG9yLm9wdGlvbnMgPSBleHBvcnRzLkZpZWxkT3B0aW9ucy5jcmVhdGUoKSkpLnBhY2tlZCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XHJcbn07XHJcblxyXG4vLyAtLS0gRW51bSAtLS1cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGFuIEVudW1EZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJRW51bURlc2NyaXB0b3JQcm90b1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEVudW0gbmFtZVxyXG4gKiBAcHJvcGVydHkge0lFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9bXX0gW3ZhbHVlXSBFbnVtIHZhbHVlc1xyXG4gKiBAcHJvcGVydHkge0lFbnVtT3B0aW9uc30gW29wdGlvbnNdIEVudW0gb3B0aW9uc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGFuIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBOYW1lXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyXSBWYWx1ZVxyXG4gKiBAcHJvcGVydHkgeyp9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgb2YgYW4gRW51bU9wdGlvbnMgbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJRW51bU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWxsb3dBbGlhc10gV2hldGhlciBhbGlhc2VzIGFyZSBhbGxvd2VkXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXHJcbiAqL1xyXG5cclxudmFyIHVubmFtZWRFbnVtSW5kZXggPSAwO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gZW51bSBmcm9tIGEgZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtJRW51bURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtFbnVtfSBFbnVtIGluc3RhbmNlXHJcbiAqL1xyXG5FbnVtLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xyXG5cclxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcclxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRW51bURlc2NyaXB0b3JQcm90by5kZWNvZGUoZGVzY3JpcHRvcik7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHZhbHVlcyBvYmplY3RcclxuICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzY3JpcHRvci52YWx1ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSAgPSBkZXNjcmlwdG9yLnZhbHVlW2ldLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWVbaV0ubnVtYmVyIHx8IDA7XHJcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lICYmIG5hbWUubGVuZ3RoID8gbmFtZSA6IFwiTkFNRVwiICsgdmFsdWVdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgRW51bShcclxuICAgICAgICBkZXNjcmlwdG9yLm5hbWUgJiYgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiRW51bVwiICsgdW5uYW1lZEVudW1JbmRleCsrLFxyXG4gICAgICAgIHZhbHVlcyxcclxuICAgICAgICBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkVudW1PcHRpb25zKVxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiBlbnVtIHRvIGEgZGVzY3JpcHRvci5cclxuICogQHJldHVybnMge01lc3NhZ2U8SUVudW1EZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXHJcbiAqL1xyXG5FbnVtLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XHJcblxyXG4gICAgLy8gVmFsdWVzXHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwga3MgPSBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcyk7IGkgPCBrcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB2YWx1ZXMucHVzaChleHBvcnRzLkVudW1WYWx1ZURlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiBrc1tpXSwgbnVtYmVyOiB0aGlzLnZhbHVlc1trc1tpXV0gfSkpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzLkVudW1EZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlcyxcclxuICAgICAgICBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5FbnVtT3B0aW9ucylcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLy8gLS0tIE9uZU9mIC0tLVxyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgb2YgYSBPbmVvZkRlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElPbmVvZkRlc2NyaXB0b3JQcm90b1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE9uZW9mIG5hbWVcclxuICogQHByb3BlcnR5IHsqfSBbb3B0aW9uc10gTm90IHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciB1bm5hbWVkT25lb2ZJbmRleCA9IDA7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG9uZW9mIGZyb20gYSBkZXNjcmlwdG9yLlxyXG4gKiBAcGFyYW0ge0lPbmVvZkRlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtPbmVPZn0gT25lT2YgaW5zdGFuY2VcclxuICovXHJcbk9uZU9mLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xyXG5cclxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcclxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuT25lb2ZEZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xyXG5cclxuICAgIHJldHVybiBuZXcgT25lT2YoXHJcbiAgICAgICAgLy8gdW5uYW1lZE9uZU9mSW5kZXggaXMgZ2xvYmFsLCBub3QgcGVyIHR5cGUsIGJlY2F1c2Ugd2UgaGF2ZSBubyByZWYgdG8gYSB0eXBlIGhlcmVcclxuICAgICAgICBkZXNjcmlwdG9yLm5hbWUgJiYgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwib25lb2ZcIiArIHVubmFtZWRPbmVvZkluZGV4KytcclxuICAgICAgICAvLyBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLk9uZW9mT3B0aW9ucykgLSBvbmx5IHVuaW50ZXJwcmV0ZWRfb3B0aW9uXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgb25lb2YgdG8gYSBkZXNjcmlwdG9yLlxyXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJT25lb2ZEZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXHJcbiAqL1xyXG5PbmVPZi5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKCkge1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuT25lb2ZEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcclxuICAgICAgICAvLyBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5PbmVvZk9wdGlvbnMpIC0gb25seSB1bmludGVycHJldGVkX29wdGlvblxyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vLyAtLS0gU2VydmljZSAtLS1cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGEgU2VydmljZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxyXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlRGVzY3JpcHRvclByb3RvXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gU2VydmljZSBuYW1lXHJcbiAqIEBwcm9wZXJ0eSB7SU1ldGhvZERlc2NyaXB0b3JQcm90b1tdfSBbbWV0aG9kXSBNZXRob2RzXHJcbiAqIEBwcm9wZXJ0eSB7SVNlcnZpY2VPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGEgU2VydmljZU9wdGlvbnMgbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJU2VydmljZU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cclxuICovXHJcblxyXG52YXIgdW5uYW1lZFNlcnZpY2VJbmRleCA9IDA7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNlcnZpY2UgZnJvbSBhIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7SVNlcnZpY2VEZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxyXG4gKiBAcmV0dXJucyB7U2VydmljZX0gU2VydmljZSBpbnN0YW5jZVxyXG4gKi9cclxuU2VydmljZS5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcclxuXHJcbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XHJcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xyXG5cclxuICAgIHZhciBzZXJ2aWNlID0gbmV3IFNlcnZpY2UoZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIlNlcnZpY2VcIiArIHVubmFtZWRTZXJ2aWNlSW5kZXgrKywgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5TZXJ2aWNlT3B0aW9ucykpO1xyXG4gICAgaWYgKGRlc2NyaXB0b3IubWV0aG9kKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzY3JpcHRvci5tZXRob2QubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHNlcnZpY2UuYWRkKE1ldGhvZC5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLm1ldGhvZFtpXSkpO1xyXG5cclxuICAgIHJldHVybiBzZXJ2aWNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc2VydmljZSB0byBhIGRlc2NyaXB0b3IuXHJcbiAqIEByZXR1cm5zIHtNZXNzYWdlPElTZXJ2aWNlRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxyXG4gKi9cclxuU2VydmljZS5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKCkge1xyXG5cclxuICAgIC8vIE1ldGhvZHNcclxuICAgIHZhciBtZXRob2RzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgIG1ldGhvZHMucHVzaCh0aGlzLl9tZXRob2RzQXJyYXlbaV0udG9EZXNjcmlwdG9yKCkpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgbWV0aG9kOiBtZXRob2RzLFxyXG4gICAgICAgIG9wdGlvbnM6IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLlNlcnZpY2VPcHRpb25zKVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG4vLyAtLS0gTWV0aG9kIC0tLVxyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgb2YgYSBNZXRob2REZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJTWV0aG9kRGVzY3JpcHRvclByb3RvXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gTWV0aG9kIG5hbWVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpbnB1dFR5cGVdIFJlcXVlc3QgdHlwZSBuYW1lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3V0cHV0VHlwZV0gUmVzcG9uc2UgdHlwZSBuYW1lXHJcbiAqIEBwcm9wZXJ0eSB7SU1ldGhvZE9wdGlvbnN9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NsaWVudFN0cmVhbWluZz1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2VydmVyU3RyZWFtaW5nPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcclxuICovXHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBvZiBhIE1ldGhvZE9wdGlvbnMgbWVzc2FnZS5cclxuICogQGludGVyZmFjZSBJTWV0aG9kT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZXByZWNhdGVkXVxyXG4gKi9cclxuXHJcbnZhciB1bm5hbWVkTWV0aG9kSW5kZXggPSAwO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtZXRob2QgZnJvbSBhIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7SU1ldGhvZERlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtNZXRob2R9IFJlZmxlY3RlZCBtZXRob2QgaW5zdGFuY2VcclxuICovXHJcbk1ldGhvZC5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcclxuXHJcbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XHJcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLk1ldGhvZERlc2NyaXB0b3JQcm90by5kZWNvZGUoZGVzY3JpcHRvcik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBNZXRob2QoXHJcbiAgICAgICAgLy8gdW5uYW1lZE1ldGhvZEluZGV4IGlzIGdsb2JhbCwgbm90IHBlciBzZXJ2aWNlLCBiZWNhdXNlIHdlIGhhdmUgbm8gcmVmIHRvIGEgc2VydmljZSBoZXJlXHJcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIk1ldGhvZFwiICsgdW5uYW1lZE1ldGhvZEluZGV4KyssXHJcbiAgICAgICAgXCJycGNcIixcclxuICAgICAgICBkZXNjcmlwdG9yLmlucHV0VHlwZSxcclxuICAgICAgICBkZXNjcmlwdG9yLm91dHB1dFR5cGUsXHJcbiAgICAgICAgQm9vbGVhbihkZXNjcmlwdG9yLmNsaWVudFN0cmVhbWluZyksXHJcbiAgICAgICAgQm9vbGVhbihkZXNjcmlwdG9yLnNlcnZlclN0cmVhbWluZyksXHJcbiAgICAgICAgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5NZXRob2RPcHRpb25zKVxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIG1ldGhvZCB0byBhIGRlc2NyaXB0b3IuXHJcbiAqIEByZXR1cm5zIHtNZXNzYWdlPElNZXRob2REZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXHJcbiAqL1xyXG5NZXRob2QucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcclxuICAgIHJldHVybiBleHBvcnRzLk1ldGhvZERlc2NyaXB0b3JQcm90by5jcmVhdGUoe1xyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBpbnB1dFR5cGU6IHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA/IHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZS5mdWxsTmFtZSA6IHRoaXMucmVxdWVzdFR5cGUsXHJcbiAgICAgICAgb3V0cHV0VHlwZTogdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA/IHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUuZnVsbE5hbWUgOiB0aGlzLnJlc3BvbnNlVHlwZSxcclxuICAgICAgICBjbGllbnRTdHJlYW1pbmc6IHRoaXMucmVxdWVzdFN0cmVhbSxcclxuICAgICAgICBzZXJ2ZXJTdHJlYW1pbmc6IHRoaXMucmVzcG9uc2VTdHJlYW0sXHJcbiAgICAgICAgb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuTWV0aG9kT3B0aW9ucylcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLy8gLS0tIHV0aWxpdHkgLS0tXHJcblxyXG4vLyBDb252ZXJ0cyBhIGRlc2NyaXB0b3IgdHlwZSB0byBhIHByb3RvYnVmLmpzIGJhc2ljIHR5cGVcclxuZnVuY3Rpb24gZnJvbURlc2NyaXB0b3JUeXBlKHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yc1xyXG4gICAgICAgIGNhc2UgMTogcmV0dXJuIFwiZG91YmxlXCI7XHJcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJmbG9hdFwiO1xyXG4gICAgICAgIGNhc2UgMzogcmV0dXJuIFwiaW50NjRcIjtcclxuICAgICAgICBjYXNlIDQ6IHJldHVybiBcInVpbnQ2NFwiO1xyXG4gICAgICAgIGNhc2UgNTogcmV0dXJuIFwiaW50MzJcIjtcclxuICAgICAgICBjYXNlIDY6IHJldHVybiBcImZpeGVkNjRcIjtcclxuICAgICAgICBjYXNlIDc6IHJldHVybiBcImZpeGVkMzJcIjtcclxuICAgICAgICBjYXNlIDg6IHJldHVybiBcImJvb2xcIjtcclxuICAgICAgICBjYXNlIDk6IHJldHVybiBcInN0cmluZ1wiO1xyXG4gICAgICAgIGNhc2UgMTI6IHJldHVybiBcImJ5dGVzXCI7XHJcbiAgICAgICAgY2FzZSAxMzogcmV0dXJuIFwidWludDMyXCI7XHJcbiAgICAgICAgY2FzZSAxNTogcmV0dXJuIFwic2ZpeGVkMzJcIjtcclxuICAgICAgICBjYXNlIDE2OiByZXR1cm4gXCJzZml4ZWQ2NFwiO1xyXG4gICAgICAgIGNhc2UgMTc6IHJldHVybiBcInNpbnQzMlwiO1xyXG4gICAgICAgIGNhc2UgMTg6IHJldHVybiBcInNpbnQ2NFwiO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdHlwZSk7XHJcbn1cclxuXHJcbi8vIFRlc3RzIGlmIGEgZGVzY3JpcHRvciB0eXBlIGlzIHBhY2thYmxlXHJcbmZ1bmN0aW9uIHBhY2thYmxlRGVzY3JpcHRvclR5cGUodHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAxOiAvLyBkb3VibGVcclxuICAgICAgICBjYXNlIDI6IC8vIGZsb2F0XHJcbiAgICAgICAgY2FzZSAzOiAvLyBpbnQ2NFxyXG4gICAgICAgIGNhc2UgNDogLy8gdWludDY0XHJcbiAgICAgICAgY2FzZSA1OiAvLyBpbnQzMlxyXG4gICAgICAgIGNhc2UgNjogLy8gZml4ZWQ2NFxyXG4gICAgICAgIGNhc2UgNzogLy8gZml4ZWQzMlxyXG4gICAgICAgIGNhc2UgODogLy8gYm9vbFxyXG4gICAgICAgIGNhc2UgMTM6IC8vIHVpbnQzMlxyXG4gICAgICAgIGNhc2UgMTQ6IC8vIGVudW0gKCEpXHJcbiAgICAgICAgY2FzZSAxNTogLy8gc2ZpeGVkMzJcclxuICAgICAgICBjYXNlIDE2OiAvLyBzZml4ZWQ2NFxyXG4gICAgICAgIGNhc2UgMTc6IC8vIHNpbnQzMlxyXG4gICAgICAgIGNhc2UgMTg6IC8vIHNpbnQ2NFxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQ29udmVydHMgYSBwcm90b2J1Zi5qcyBiYXNpYyB0eXBlIHRvIGEgZGVzY3JpcHRvciB0eXBlXHJcbmZ1bmN0aW9uIHRvRGVzY3JpcHRvclR5cGUodHlwZSwgcmVzb2x2ZWRUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnNcclxuICAgICAgICBjYXNlIFwiZG91YmxlXCI6IHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOiByZXR1cm4gMjtcclxuICAgICAgICBjYXNlIFwiaW50NjRcIjogcmV0dXJuIDM7XHJcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOiByZXR1cm4gNDtcclxuICAgICAgICBjYXNlIFwiaW50MzJcIjogcmV0dXJuIDU7XHJcbiAgICAgICAgY2FzZSBcImZpeGVkNjRcIjogcmV0dXJuIDY7XHJcbiAgICAgICAgY2FzZSBcImZpeGVkMzJcIjogcmV0dXJuIDc7XHJcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIDg7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gOTtcclxuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIDEyO1xyXG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjogcmV0dXJuIDEzO1xyXG4gICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiByZXR1cm4gMTU7XHJcbiAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IHJldHVybiAxNjtcclxuICAgICAgICBjYXNlIFwic2ludDMyXCI6IHJldHVybiAxNztcclxuICAgICAgICBjYXNlIFwic2ludDY0XCI6IHJldHVybiAxODtcclxuICAgIH1cclxuICAgIGlmIChyZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKVxyXG4gICAgICAgIHJldHVybiAxNDtcclxuICAgIGlmIChyZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKVxyXG4gICAgICAgIHJldHVybiByZXNvbHZlZFR5cGUuZ3JvdXAgPyAxMCA6IDExO1xyXG4gICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdHlwZSk7XHJcbn1cclxuXHJcbi8vIENvbnZlcnRzIGRlc2NyaXB0b3Igb3B0aW9ucyB0byBhbiBvcHRpb25zIG9iamVjdFxyXG5mdW5jdGlvbiBmcm9tRGVzY3JpcHRvck9wdGlvbnMob3B0aW9ucywgdHlwZSkge1xyXG4gICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQsIGtleSwgdmFsOyBpIDwgdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcclxuICAgICAgICBpZiAoKGtleSA9IChmaWVsZCA9IHR5cGUuX2ZpZWxkc0FycmF5W2ldKS5uYW1lKSAhPT0gXCJ1bmludGVycHJldGVkT3B0aW9uXCIpXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcclxuICAgICAgICAgICAgICAgIHZhbCA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtICYmIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc0J5SWRbdmFsXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW3ZhbF07XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh1bmRlclNjb3JlKGtleSksIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIHJldHVybiBvdXQubGVuZ3RoID8gJHByb3RvYnVmLnV0aWwudG9PYmplY3Qob3V0KSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLy8gQ29udmVydHMgYW4gb3B0aW9ucyBvYmplY3QgdG8gZGVzY3JpcHRvciBvcHRpb25zXHJcbmZ1bmN0aW9uIHRvRGVzY3JpcHRvck9wdGlvbnMob3B0aW9ucywgdHlwZSkge1xyXG4gICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwga3MgPSBPYmplY3Qua2V5cyhvcHRpb25zKSwga2V5LCB2YWw7IGkgPCBrcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhbCA9IG9wdGlvbnNba2V5ID0ga3NbaV1dO1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB2YXIgZmllbGQgPSB0eXBlLmZpZWxkc1trZXldO1xyXG4gICAgICAgIGlmICghZmllbGQgJiYgIShmaWVsZCA9IHR5cGUuZmllbGRzW2tleSA9ICRwcm90b2J1Zi51dGlsLmNhbWVsQ2FzZShrZXkpXSkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIG91dC5wdXNoKGtleSwgdmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQubGVuZ3RoID8gdHlwZS5mcm9tT2JqZWN0KCRwcm90b2J1Zi51dGlsLnRvT2JqZWN0KG91dCkpIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBDYWxjdWxhdGVzIHRoZSBzaG9ydGVzdCByZWxhdGl2ZSBwYXRoIGZyb20gYGZyb21gIHRvIGB0b2AuXHJcbmZ1bmN0aW9uIHNob3J0bmFtZShmcm9tLCB0bykge1xyXG4gICAgdmFyIGZyb21QYXRoID0gZnJvbS5mdWxsTmFtZS5zcGxpdChcIi5cIiksXHJcbiAgICAgICAgdG9QYXRoID0gdG8uZnVsbE5hbWUuc3BsaXQoXCIuXCIpLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGogPSAwLFxyXG4gICAgICAgIGsgPSB0b1BhdGgubGVuZ3RoIC0gMTtcclxuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBSb290KSAmJiB0byBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcclxuICAgICAgICB3aGlsZSAoaSA8IGZyb21QYXRoLmxlbmd0aCAmJiBqIDwgayAmJiBmcm9tUGF0aFtpXSA9PT0gdG9QYXRoW2pdKSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlciA9IHRvLmxvb2t1cChmcm9tUGF0aFtpKytdLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB0bylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICArK2o7XHJcbiAgICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIGZvciAoOyBpIDwgZnJvbVBhdGgubGVuZ3RoICYmIGogPCBrICYmIGZyb21QYXRoW2ldID09PSB0b1BhdGhbal07ICsraSwgKytqKTtcclxuICAgIHJldHVybiB0b1BhdGguc2xpY2Uoaikuam9pbihcIi5cIik7XHJcbn1cclxuXHJcbi8vIGNvcGllZCBoZXJlIGZyb20gY2xpL3RhcmdldHMvcHJvdG8uanNcclxuZnVuY3Rpb24gdW5kZXJTY29yZShzdHIpIHtcclxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsMSlcclxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXHJcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oW0EtWl0pKD89W2Etel18JCkvZywgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiBcIl9cIiArICQxLnRvTG93ZXJDYXNlKCk7IH0pO1xyXG59XHJcblxyXG4vLyAtLS0gZXhwb3J0cyAtLS1cclxuXHJcbi8qKlxyXG4gKiBSZWZsZWN0ZWQgZmlsZSBkZXNjcmlwdG9yIHNldC5cclxuICogQG5hbWUgRmlsZURlc2NyaXB0b3JTZXRcclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBmaWxlIGRlc2NyaXB0b3IgcHJvdG8uXHJcbiAqIEBuYW1lIEZpbGVEZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBkZXNjcmlwdG9yIHByb3RvLlxyXG4gKiBAbmFtZSBEZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBwcm9wZXJ0eSB7VHlwZX0gRXh0ZW5zaW9uUmFuZ2VcclxuICogQHByb3BlcnR5IHtUeXBlfSBSZXNlcnZlZFJhbmdlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xyXG4gKiAgICAgRXh0ZW5zaW9uUmFuZ2U6ICRwcm90b2J1Zi5UeXBlLFxyXG4gKiAgICAgUmVzZXJ2ZWRSYW5nZTogJHByb3RvYnVmLlR5cGVcclxuICogfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWZsZWN0ZWQgZmllbGQgZGVzY3JpcHRvciBwcm90by5cclxuICogQG5hbWUgRmllbGREZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBwcm9wZXJ0eSB7RW51bX0gTGFiZWxcclxuICogQHByb3BlcnR5IHtFbnVtfSBUeXBlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xyXG4gKiAgICAgTGFiZWw6ICRwcm90b2J1Zi5FbnVtLFxyXG4gKiAgICAgVHlwZTogJHByb3RvYnVmLkVudW1cclxuICogfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWZsZWN0ZWQgb25lb2YgZGVzY3JpcHRvciBwcm90by5cclxuICogQG5hbWUgT25lb2ZEZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBlbnVtIGRlc2NyaXB0b3IgcHJvdG8uXHJcbiAqIEBuYW1lIEVudW1EZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBzZXJ2aWNlIGRlc2NyaXB0b3IgcHJvdG8uXHJcbiAqIEBuYW1lIFNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBlbnVtIHZhbHVlIGRlc2NyaXB0b3IgcHJvdG8uXHJcbiAqIEBuYW1lIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1xyXG4gKiBAdHlwZSB7VHlwZX1cclxuICogQGNvbnN0XHJcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIG1ldGhvZCBkZXNjcmlwdG9yIHByb3RvLlxyXG4gKiBAbmFtZSBNZXRob2REZXNjcmlwdG9yUHJvdG9cclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBmaWxlIG9wdGlvbnMuXHJcbiAqIEBuYW1lIEZpbGVPcHRpb25zXHJcbiAqIEB0eXBlIHtUeXBlfVxyXG4gKiBAcHJvcGVydHkge0VudW19IE9wdGltaXplTW9kZVxyXG4gKiBAY29uc3RcclxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcclxuICogICAgIE9wdGltaXplTW9kZTogJHByb3RvYnVmLkVudW1cclxuICogfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWZsZWN0ZWQgbWVzc2FnZSBvcHRpb25zLlxyXG4gKiBAbmFtZSBNZXNzYWdlT3B0aW9uc1xyXG4gKiBAdHlwZSB7VHlwZX1cclxuICogQGNvbnN0XHJcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIGZpZWxkIG9wdGlvbnMuXHJcbiAqIEBuYW1lIEZpZWxkT3B0aW9uc1xyXG4gKiBAdHlwZSB7VHlwZX1cclxuICogQHByb3BlcnR5IHtFbnVtfSBDVHlwZVxyXG4gKiBAcHJvcGVydHkge0VudW19IEpTVHlwZVxyXG4gKiBAY29uc3RcclxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcclxuICogICAgIENUeXBlOiAkcHJvdG9idWYuRW51bSxcclxuICogICAgIEpTVHlwZTogJHByb3RvYnVmLkVudW1cclxuICogfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWZsZWN0ZWQgb25lb2Ygb3B0aW9ucy5cclxuICogQG5hbWUgT25lb2ZPcHRpb25zXHJcbiAqIEB0eXBlIHtUeXBlfVxyXG4gKiBAY29uc3RcclxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWZsZWN0ZWQgZW51bSBvcHRpb25zLlxyXG4gKiBAbmFtZSBFbnVtT3B0aW9uc1xyXG4gKiBAdHlwZSB7VHlwZX1cclxuICogQGNvbnN0XHJcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIGVudW0gdmFsdWUgb3B0aW9ucy5cclxuICogQG5hbWUgRW51bVZhbHVlT3B0aW9uc1xyXG4gKiBAdHlwZSB7VHlwZX1cclxuICogQGNvbnN0XHJcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIHNlcnZpY2Ugb3B0aW9ucy5cclxuICogQG5hbWUgU2VydmljZU9wdGlvbnNcclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlZmxlY3RlZCBtZXRob2Qgb3B0aW9ucy5cclxuICogQG5hbWUgTWV0aG9kT3B0aW9uc1xyXG4gKiBAdHlwZSB7VHlwZX1cclxuICogQGNvbnN0XHJcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIHVuaW50ZXJwcmV0ZXQgb3B0aW9uLlxyXG4gKiBAbmFtZSBVbmludGVycHJldGVkT3B0aW9uXHJcbiAqIEB0eXBlIHtUeXBlfVxyXG4gKiBAcHJvcGVydHkge1R5cGV9IE5hbWVQYXJ0XHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xyXG4gKiAgICAgTmFtZVBhcnQ6ICRwcm90b2J1Zi5UeXBlXHJcbiAqIH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIHNvdXJjZSBjb2RlIGluZm8uXHJcbiAqIEBuYW1lIFNvdXJjZUNvZGVJbmZvXHJcbiAqIEB0eXBlIHtUeXBlfVxyXG4gKiBAcHJvcGVydHkge1R5cGV9IExvY2F0aW9uXHJcbiAqIEBjb25zdFxyXG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xyXG4gKiAgICAgTG9jYXRpb246ICRwcm90b2J1Zi5UeXBlXHJcbiAqIH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVmbGVjdGVkIGdlbmVyYXRlZCBjb2RlIGluZm8uXHJcbiAqIEBuYW1lIEdlbmVyYXRlZENvZGVJbmZvXHJcbiAqIEB0eXBlIHtUeXBlfVxyXG4gKiBAcHJvcGVydHkge1R5cGV9IEFubm90YXRpb25cclxuICogQGNvbnN0XHJcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XHJcbiAqICAgICBBbm5vdGF0aW9uOiAkcHJvdG9idWYuVHlwZVxyXG4gKiB9XHJcbiAqL1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// full library entry point.\r\n\r\n\r\nmodule.exports = __webpack_require__(/*! ./src/index */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ2E7QUFDYixrSUFBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9pbmRleC5qcz9jMDVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bGwgbGlicmFyeSBlbnRyeSBwb2ludC5cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleFwiKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = common;\r\n\r\nvar commonRe = /\\/|\\./;\r\n\r\n/**\r\n * Provides common type definitions.\r\n * Can also be used to provide additional google types or your own custom types.\r\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\r\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\r\n * @returns {undefined}\r\n * @property {INamespace} google/protobuf/any.proto Any\r\n * @property {INamespace} google/protobuf/duration.proto Duration\r\n * @property {INamespace} google/protobuf/empty.proto Empty\r\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\r\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\r\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\r\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\r\n * @example\r\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\r\n * protobuf.common(\"descriptor\", descriptorJson);\r\n *\r\n * // manually provides a custom definition (uses my.foo namespace)\r\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\r\n */\r\nfunction common(name, json) {\r\n    if (!commonRe.test(name)) {\r\n        name = \"google/protobuf/\" + name + \".proto\";\r\n        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };\r\n    }\r\n    common[name] = json;\r\n}\r\n\r\n// Not provided because of limited use (feel free to discuss or to provide yourself):\r\n//\r\n// google/protobuf/descriptor.proto\r\n// google/protobuf/source_context.proto\r\n// google/protobuf/type.proto\r\n//\r\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\r\n// the repository or package within the google/protobuf directory.\r\n\r\ncommon(\"any\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Any message.\r\n     * @interface IAny\r\n     * @type {Object}\r\n     * @property {string} [typeUrl]\r\n     * @property {Uint8Array} [bytes]\r\n     * @memberof common\r\n     */\r\n    Any: {\r\n        fields: {\r\n            type_url: {\r\n                type: \"string\",\r\n                id: 1\r\n            },\r\n            value: {\r\n                type: \"bytes\",\r\n                id: 2\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar timeType;\r\n\r\ncommon(\"duration\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Duration message.\r\n     * @interface IDuration\r\n     * @type {Object}\r\n     * @property {number|Long} [seconds]\r\n     * @property {number} [nanos]\r\n     * @memberof common\r\n     */\r\n    Duration: timeType = {\r\n        fields: {\r\n            seconds: {\r\n                type: \"int64\",\r\n                id: 1\r\n            },\r\n            nanos: {\r\n                type: \"int32\",\r\n                id: 2\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\ncommon(\"timestamp\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Timestamp message.\r\n     * @interface ITimestamp\r\n     * @type {Object}\r\n     * @property {number|Long} [seconds]\r\n     * @property {number} [nanos]\r\n     * @memberof common\r\n     */\r\n    Timestamp: timeType\r\n});\r\n\r\ncommon(\"empty\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Empty message.\r\n     * @interface IEmpty\r\n     * @memberof common\r\n     */\r\n    Empty: {\r\n        fields: {}\r\n    }\r\n});\r\n\r\ncommon(\"struct\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Struct message.\r\n     * @interface IStruct\r\n     * @type {Object}\r\n     * @property {Object.<string,IValue>} [fields]\r\n     * @memberof common\r\n     */\r\n    Struct: {\r\n        fields: {\r\n            fields: {\r\n                keyType: \"string\",\r\n                type: \"Value\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Value message.\r\n     * @interface IValue\r\n     * @type {Object}\r\n     * @property {string} [kind]\r\n     * @property {0} [nullValue]\r\n     * @property {number} [numberValue]\r\n     * @property {string} [stringValue]\r\n     * @property {boolean} [boolValue]\r\n     * @property {IStruct} [structValue]\r\n     * @property {IListValue} [listValue]\r\n     * @memberof common\r\n     */\r\n    Value: {\r\n        oneofs: {\r\n            kind: {\r\n                oneof: [\r\n                    \"nullValue\",\r\n                    \"numberValue\",\r\n                    \"stringValue\",\r\n                    \"boolValue\",\r\n                    \"structValue\",\r\n                    \"listValue\"\r\n                ]\r\n            }\r\n        },\r\n        fields: {\r\n            nullValue: {\r\n                type: \"NullValue\",\r\n                id: 1\r\n            },\r\n            numberValue: {\r\n                type: \"double\",\r\n                id: 2\r\n            },\r\n            stringValue: {\r\n                type: \"string\",\r\n                id: 3\r\n            },\r\n            boolValue: {\r\n                type: \"bool\",\r\n                id: 4\r\n            },\r\n            structValue: {\r\n                type: \"Struct\",\r\n                id: 5\r\n            },\r\n            listValue: {\r\n                type: \"ListValue\",\r\n                id: 6\r\n            }\r\n        }\r\n    },\r\n\r\n    NullValue: {\r\n        values: {\r\n            NULL_VALUE: 0\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.ListValue message.\r\n     * @interface IListValue\r\n     * @type {Object}\r\n     * @property {Array.<IValue>} [values]\r\n     * @memberof common\r\n     */\r\n    ListValue: {\r\n        fields: {\r\n            values: {\r\n                rule: \"repeated\",\r\n                type: \"Value\",\r\n                id: 1\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\ncommon(\"wrappers\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.DoubleValue message.\r\n     * @interface IDoubleValue\r\n     * @type {Object}\r\n     * @property {number} [value]\r\n     * @memberof common\r\n     */\r\n    DoubleValue: {\r\n        fields: {\r\n            value: {\r\n                type: \"double\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.FloatValue message.\r\n     * @interface IFloatValue\r\n     * @type {Object}\r\n     * @property {number} [value]\r\n     * @memberof common\r\n     */\r\n    FloatValue: {\r\n        fields: {\r\n            value: {\r\n                type: \"float\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Int64Value message.\r\n     * @interface IInt64Value\r\n     * @type {Object}\r\n     * @property {number|Long} [value]\r\n     * @memberof common\r\n     */\r\n    Int64Value: {\r\n        fields: {\r\n            value: {\r\n                type: \"int64\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.UInt64Value message.\r\n     * @interface IUInt64Value\r\n     * @type {Object}\r\n     * @property {number|Long} [value]\r\n     * @memberof common\r\n     */\r\n    UInt64Value: {\r\n        fields: {\r\n            value: {\r\n                type: \"uint64\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.Int32Value message.\r\n     * @interface IInt32Value\r\n     * @type {Object}\r\n     * @property {number} [value]\r\n     * @memberof common\r\n     */\r\n    Int32Value: {\r\n        fields: {\r\n            value: {\r\n                type: \"int32\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.UInt32Value message.\r\n     * @interface IUInt32Value\r\n     * @type {Object}\r\n     * @property {number} [value]\r\n     * @memberof common\r\n     */\r\n    UInt32Value: {\r\n        fields: {\r\n            value: {\r\n                type: \"uint32\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.BoolValue message.\r\n     * @interface IBoolValue\r\n     * @type {Object}\r\n     * @property {boolean} [value]\r\n     * @memberof common\r\n     */\r\n    BoolValue: {\r\n        fields: {\r\n            value: {\r\n                type: \"bool\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.StringValue message.\r\n     * @interface IStringValue\r\n     * @type {Object}\r\n     * @property {string} [value]\r\n     * @memberof common\r\n     */\r\n    StringValue: {\r\n        fields: {\r\n            value: {\r\n                type: \"string\",\r\n                id: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Properties of a google.protobuf.BytesValue message.\r\n     * @interface IBytesValue\r\n     * @type {Object}\r\n     * @property {Uint8Array} [value]\r\n     * @memberof common\r\n     */\r\n    BytesValue: {\r\n        fields: {\r\n            value: {\r\n                type: \"bytes\",\r\n                id: 1\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\ncommon(\"field_mask\", {\r\n\r\n    /**\r\n     * Properties of a google.protobuf.FieldMask message.\r\n     * @interface IDoubleValue\r\n     * @type {Object}\r\n     * @property {number} [value]\r\n     * @memberof common\r\n     */\r\n    FieldMask: {\r\n        fields: {\r\n            paths: {\r\n                rule: \"repeated\",\r\n                type: \"string\",\r\n                id: 1\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Gets the root definition of the specified common proto file.\r\n *\r\n * Bundled definitions are:\r\n * - google/protobuf/any.proto\r\n * - google/protobuf/duration.proto\r\n * - google/protobuf/empty.proto\r\n * - google/protobuf/field_mask.proto\r\n * - google/protobuf/struct.proto\r\n * - google/protobuf/timestamp.proto\r\n * - google/protobuf/wrappers.proto\r\n *\r\n * @param {string} file Proto file name\r\n * @returns {INamespace|null} Root definition or `null` if not defined\r\n */\r\ncommon.get = function get(file) {\r\n    return common[file] || null;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVLFVBQVUsVUFBVSxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsYUFBYTtBQUMvQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixhQUFhO0FBQy9CLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixHQUFHO0FBQ3JCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29tbW9uLmpzP2I1YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gY29tbW9uO1xyXG5cclxudmFyIGNvbW1vblJlID0gL1xcL3xcXC4vO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGNvbW1vbiB0eXBlIGRlZmluaXRpb25zLlxyXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBnb29nbGUgdHlwZXMgb3IgeW91ciBvd24gY3VzdG9tIHR5cGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTaG9ydCBuYW1lIGFzIGluIGBnb29nbGUvcHJvdG9idWYvW25hbWVdLnByb3RvYCBvciBmdWxsIGZpbGUgbmFtZVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gZGVmaW5pdGlvbiB3aXRoaW4gYGdvb2dsZS5wcm90b2J1ZmAgaWYgYSBzaG9ydCBuYW1lLCBvdGhlcndpc2UgdGhlIGZpbGUncyByb290IGRlZmluaXRpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvYW55LnByb3RvIEFueVxyXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90byBEdXJhdGlvblxyXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90byBFbXB0eVxyXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9maWVsZF9tYXNrLnByb3RvIEZpZWxkTWFza1xyXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG8gU3RydWN0LCBWYWx1ZSwgTnVsbFZhbHVlIGFuZCBMaXN0VmFsdWVcclxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvIFRpbWVzdGFtcFxyXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90byBXcmFwcGVyc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBtYW51YWxseSBwcm92aWRlcyBkZXNjcmlwdG9yLnByb3RvIChhc3N1bWVzIGdvb2dsZS9wcm90b2J1Zi8gbmFtZXNwYWNlIGFuZCAucHJvdG8gZXh0ZW5zaW9uKVxyXG4gKiBwcm90b2J1Zi5jb21tb24oXCJkZXNjcmlwdG9yXCIsIGRlc2NyaXB0b3JKc29uKTtcclxuICpcclxuICogLy8gbWFudWFsbHkgcHJvdmlkZXMgYSBjdXN0b20gZGVmaW5pdGlvbiAodXNlcyBteS5mb28gbmFtZXNwYWNlKVxyXG4gKiBwcm90b2J1Zi5jb21tb24oXCJteS9mb28vYmFyLnByb3RvXCIsIG15Rm9vQmFySnNvbik7XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21tb24obmFtZSwganNvbikge1xyXG4gICAgaWYgKCFjb21tb25SZS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgbmFtZSA9IFwiZ29vZ2xlL3Byb3RvYnVmL1wiICsgbmFtZSArIFwiLnByb3RvXCI7XHJcbiAgICAgICAganNvbiA9IHsgbmVzdGVkOiB7IGdvb2dsZTogeyBuZXN0ZWQ6IHsgcHJvdG9idWY6IHsgbmVzdGVkOiBqc29uIH0gfSB9IH0gfTtcclxuICAgIH1cclxuICAgIGNvbW1vbltuYW1lXSA9IGpzb247XHJcbn1cclxuXHJcbi8vIE5vdCBwcm92aWRlZCBiZWNhdXNlIG9mIGxpbWl0ZWQgdXNlIChmZWVsIGZyZWUgdG8gZGlzY3VzcyBvciB0byBwcm92aWRlIHlvdXJzZWxmKTpcclxuLy9cclxuLy8gZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG9cclxuLy8gZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0LnByb3RvXHJcbi8vIGdvb2dsZS9wcm90b2J1Zi90eXBlLnByb3RvXHJcbi8vXHJcbi8vIFN0cmlwcGVkIGFuZCBwcmUtcGFyc2VkIHZlcnNpb25zIG9mIHRoZXNlIG5vbi1idW5kbGVkIGZpbGVzIGFyZSBpbnN0ZWFkIGF2YWlsYWJsZSBhcyBwYXJ0IG9mXHJcbi8vIHRoZSByZXBvc2l0b3J5IG9yIHBhY2thZ2Ugd2l0aGluIHRoZSBnb29nbGUvcHJvdG9idWYgZGlyZWN0b3J5LlxyXG5cclxuY29tbW9uKFwiYW55XCIsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQW55IG1lc3NhZ2UuXHJcbiAgICAgKiBAaW50ZXJmYWNlIElBbnlcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVVcmxdXHJcbiAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtieXRlc11cclxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cclxuICAgICAqL1xyXG4gICAgQW55OiB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgIHR5cGVfdXJsOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgICAgIGlkOiAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIHRpbWVUeXBlO1xyXG5cclxuY29tbW9uKFwiZHVyYXRpb25cIiwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiBtZXNzYWdlLlxyXG4gICAgICogQGludGVyZmFjZSBJRHVyYXRpb25cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbc2Vjb25kc11cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXHJcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXHJcbiAgICAgKi9cclxuICAgIER1cmF0aW9uOiB0aW1lVHlwZSA9IHtcclxuICAgICAgICBmaWVsZHM6IHtcclxuICAgICAgICAgICAgc2Vjb25kczoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbmFub3M6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcclxuICAgICAgICAgICAgICAgIGlkOiAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY29tbW9uKFwidGltZXN0YW1wXCIsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIG1lc3NhZ2UuXHJcbiAgICAgKiBAaW50ZXJmYWNlIElUaW1lc3RhbXBcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbc2Vjb25kc11cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXHJcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXHJcbiAgICAgKi9cclxuICAgIFRpbWVzdGFtcDogdGltZVR5cGVcclxufSk7XHJcblxyXG5jb21tb24oXCJlbXB0eVwiLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkVtcHR5IG1lc3NhZ2UuXHJcbiAgICAgKiBAaW50ZXJmYWNlIElFbXB0eVxyXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxyXG4gICAgICovXHJcbiAgICBFbXB0eToge1xyXG4gICAgICAgIGZpZWxkczoge31cclxuICAgIH1cclxufSk7XHJcblxyXG5jb21tb24oXCJzdHJ1Y3RcIiwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgbWVzc2FnZS5cclxuICAgICAqIEBpbnRlcmZhY2UgSVN0cnVjdFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSVZhbHVlPn0gW2ZpZWxkc11cclxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cclxuICAgICAqL1xyXG4gICAgU3RydWN0OiB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICAgICAga2V5VHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSBtZXNzYWdlLlxyXG4gICAgICogQGludGVyZmFjZSBJVmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2tpbmRdXHJcbiAgICAgKiBAcHJvcGVydHkgezB9IFtudWxsVmFsdWVdXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlclZhbHVlXVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHJpbmdWYWx1ZV1cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Jvb2xWYWx1ZV1cclxuICAgICAqIEBwcm9wZXJ0eSB7SVN0cnVjdH0gW3N0cnVjdFZhbHVlXVxyXG4gICAgICogQHByb3BlcnR5IHtJTGlzdFZhbHVlfSBbbGlzdFZhbHVlXVxyXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxyXG4gICAgICovXHJcbiAgICBWYWx1ZToge1xyXG4gICAgICAgIG9uZW9mczoge1xyXG4gICAgICAgICAgICBraW5kOiB7XHJcbiAgICAgICAgICAgICAgICBvbmVvZjogW1xyXG4gICAgICAgICAgICAgICAgICAgIFwibnVsbFZhbHVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJWYWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nVmFsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICBcImJvb2xWYWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic3RydWN0VmFsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICBcImxpc3RWYWx1ZVwiXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICBudWxsVmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiTnVsbFZhbHVlXCIsXHJcbiAgICAgICAgICAgICAgICBpZDogMVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBudW1iZXJWYWx1ZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcclxuICAgICAgICAgICAgICAgIGlkOiAyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9vbFZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcclxuICAgICAgICAgICAgICAgIGlkOiA0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0cnVjdFZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlN0cnVjdFwiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGlzdFZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkxpc3RWYWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgTnVsbFZhbHVlOiB7XHJcbiAgICAgICAgdmFsdWVzOiB7XHJcbiAgICAgICAgICAgIE5VTExfVkFMVUU6IDBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbWVzc2FnZS5cclxuICAgICAqIEBpbnRlcmZhY2UgSUxpc3RWYWx1ZVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPElWYWx1ZT59IFt2YWx1ZXNdXHJcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXHJcbiAgICAgKi9cclxuICAgIExpc3RWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICB2YWx1ZXM6IHtcclxuICAgICAgICAgICAgICAgIHJ1bGU6IFwicmVwZWF0ZWRcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY29tbW9uKFwid3JhcHBlcnNcIiwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZSBtZXNzYWdlLlxyXG4gICAgICogQGludGVyZmFjZSBJRG91YmxlVmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxyXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxyXG4gICAgICovXHJcbiAgICBEb3VibGVWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlIG1lc3NhZ2UuXHJcbiAgICAgKiBAaW50ZXJmYWNlIElGbG9hdFZhbHVlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cclxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cclxuICAgICAqL1xyXG4gICAgRmxvYXRWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUgbWVzc2FnZS5cclxuICAgICAqIEBpbnRlcmZhY2UgSUludDY0VmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXHJcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXHJcbiAgICAgKi9cclxuICAgIEludDY0VmFsdWU6IHtcclxuICAgICAgICBmaWVsZHM6IHtcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZSBtZXNzYWdlLlxyXG4gICAgICogQGludGVyZmFjZSBJVUludDY0VmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXHJcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXHJcbiAgICAgKi9cclxuICAgIFVJbnQ2NFZhbHVlOiB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgbWVzc2FnZS5cclxuICAgICAqIEBpbnRlcmZhY2UgSUludDMyVmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxyXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxyXG4gICAgICovXHJcbiAgICBJbnQzMlZhbHVlOiB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDMyXCIsXHJcbiAgICAgICAgICAgICAgICBpZDogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUgbWVzc2FnZS5cclxuICAgICAqIEBpbnRlcmZhY2UgSVVJbnQzMlZhbHVlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cclxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cclxuICAgICAqL1xyXG4gICAgVUludDMyVmFsdWU6IHtcclxuICAgICAgICBmaWVsZHM6IHtcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDMyXCIsXHJcbiAgICAgICAgICAgICAgICBpZDogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlIG1lc3NhZ2UuXHJcbiAgICAgKiBAaW50ZXJmYWNlIElCb29sVmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWx1ZV1cclxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cclxuICAgICAqL1xyXG4gICAgQm9vbFZhbHVlOiB7XHJcbiAgICAgICAgZmllbGRzOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZSBtZXNzYWdlLlxyXG4gICAgICogQGludGVyZmFjZSBJU3RyaW5nVmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlXVxyXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxyXG4gICAgICovXHJcbiAgICBTdHJpbmdWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlIG1lc3NhZ2UuXHJcbiAgICAgKiBAaW50ZXJmYWNlIElCeXRlc1ZhbHVlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbdmFsdWVdXHJcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXHJcbiAgICAgKi9cclxuICAgIEJ5dGVzVmFsdWU6IHtcclxuICAgICAgICBmaWVsZHM6IHtcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgICAgIGlkOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY29tbW9uKFwiZmllbGRfbWFza1wiLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayBtZXNzYWdlLlxyXG4gICAgICogQGludGVyZmFjZSBJRG91YmxlVmFsdWVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxyXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxyXG4gICAgICovXHJcbiAgICBGaWVsZE1hc2s6IHtcclxuICAgICAgICBmaWVsZHM6IHtcclxuICAgICAgICAgICAgcGF0aHM6IHtcclxuICAgICAgICAgICAgICAgIHJ1bGU6IFwicmVwZWF0ZWRcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICBpZDogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSByb290IGRlZmluaXRpb24gb2YgdGhlIHNwZWNpZmllZCBjb21tb24gcHJvdG8gZmlsZS5cclxuICpcclxuICogQnVuZGxlZCBkZWZpbml0aW9ucyBhcmU6XHJcbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90b1xyXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90b1xyXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90b1xyXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9maWVsZF9tYXNrLnByb3RvXHJcbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3N0cnVjdC5wcm90b1xyXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG9cclxuICogLSBnb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG9cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgUHJvdG8gZmlsZSBuYW1lXHJcbiAqIEByZXR1cm5zIHtJTmFtZXNwYWNlfG51bGx9IFJvb3QgZGVmaW5pdGlvbiBvciBgbnVsbGAgaWYgbm90IGRlZmluZWRcclxuICovXHJcbmNvbW1vbi5nZXQgPSBmdW5jdGlvbiBnZXQoZmlsZSkge1xyXG4gICAgcmV0dXJuIGNvbW1vbltmaWxlXSB8fCBudWxsO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n/**\r\n * Runtime message from/to plain object converters.\r\n * @namespace\r\n */\r\nvar converter = exports;\r\n\r\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n/**\r\n * Generates a partial value fromObject conveter.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} prop Property reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\r\n    var defaultAlreadyEmitted = false;\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    if (field.resolvedType) {\r\n        if (field.resolvedType instanceof Enum) { gen\r\n            (\"switch(d%s){\", prop);\r\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\r\n                // enum unknown values passthrough\r\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen\r\n                    (\"default:\")\r\n                        (\"if(typeof(d%s)===\\\"number\\\"){m%s=d%s;break}\", prop, prop, prop);\r\n                    if (!field.repeated) gen // fallback to default value only for\r\n                                             // arrays, to avoid leaving holes.\r\n                        (\"break\");           // for non-repeated fields, just ignore\r\n                    defaultAlreadyEmitted = true;\r\n                }\r\n                gen\r\n                (\"case%j:\", keys[i])\r\n                (\"case %i:\", values[keys[i]])\r\n                    (\"m%s=%j\", prop, values[keys[i]])\r\n                    (\"break\");\r\n            } gen\r\n            (\"}\");\r\n        } else gen\r\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\r\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\r\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\r\n    } else {\r\n        var isUnsigned = false;\r\n        switch (field.type) {\r\n            case \"double\":\r\n            case \"float\": gen\r\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\r\n                break;\r\n            case \"uint32\":\r\n            case \"fixed32\": gen\r\n                (\"m%s=d%s>>>0\", prop, prop);\r\n                break;\r\n            case \"int32\":\r\n            case \"sint32\":\r\n            case \"sfixed32\": gen\r\n                (\"m%s=d%s|0\", prop, prop);\r\n                break;\r\n            case \"uint64\":\r\n                isUnsigned = true;\r\n                // eslint-disable-next-line no-fallthrough\r\n            case \"int64\":\r\n            case \"sint64\":\r\n            case \"fixed64\":\r\n            case \"sfixed64\": gen\r\n                (\"if(util.Long)\")\r\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\r\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\r\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\r\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\r\n                    (\"m%s=d%s\", prop, prop)\r\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\r\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\r\n                break;\r\n            case \"bytes\": gen\r\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\r\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\r\n                (\"else if(d%s.length >= 0)\", prop)\r\n                    (\"m%s=d%s\", prop, prop);\r\n                break;\r\n            case \"string\": gen\r\n                (\"m%s=String(d%s)\", prop, prop);\r\n                break;\r\n            case \"bool\": gen\r\n                (\"m%s=Boolean(d%s)\", prop, prop);\r\n                break;\r\n            /* default: gen\r\n                (\"m%s=d%s\", prop, prop);\r\n                break; */\r\n        }\r\n    }\r\n    return gen;\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n}\r\n\r\n/**\r\n * Generates a plain object to runtime message converter specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nconverter.fromObject = function fromObject(mtype) {\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    var fields = mtype.fieldsArray;\r\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\r\n    (\"if(d instanceof this.ctor)\")\r\n        (\"return d\");\r\n    if (!fields.length) return gen\r\n    (\"return new this.ctor\");\r\n    gen\r\n    (\"var m=new this.ctor\");\r\n    for (var i = 0; i < fields.length; ++i) {\r\n        var field  = fields[i].resolve(),\r\n            prop   = util.safeProp(field.name);\r\n\r\n        // Map fields\r\n        if (field.map) { gen\r\n    (\"if(d%s){\", prop)\r\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\r\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\r\n        (\"m%s={}\", prop)\r\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\r\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n        // Repeated fields\r\n        } else if (field.repeated) { gen\r\n    (\"if(d%s){\", prop)\r\n        (\"if(!Array.isArray(d%s))\", prop)\r\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\r\n        (\"m%s=[]\", prop)\r\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\r\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n        // Non-repeated fields\r\n        } else {\r\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\r\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\r\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\r\n            if (!(field.resolvedType instanceof Enum)) gen\r\n    (\"}\");\r\n        }\r\n    } return gen\r\n    (\"return m\");\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n};\r\n\r\n/**\r\n * Generates a partial value toObject converter.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} prop Property reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    if (field.resolvedType) {\r\n        if (field.resolvedType instanceof Enum) gen\r\n            (\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\r\n        else gen\r\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\r\n    } else {\r\n        var isUnsigned = false;\r\n        switch (field.type) {\r\n            case \"double\":\r\n            case \"float\": gen\r\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\r\n                break;\r\n            case \"uint64\":\r\n                isUnsigned = true;\r\n                // eslint-disable-next-line no-fallthrough\r\n            case \"int64\":\r\n            case \"sint64\":\r\n            case \"fixed64\":\r\n            case \"sfixed64\": gen\r\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\r\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\r\n            (\"else\") // Long-like\r\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\r\n                break;\r\n            case \"bytes\": gen\r\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\r\n                break;\r\n            default: gen\r\n            (\"d%s=m%s\", prop, prop);\r\n                break;\r\n        }\r\n    }\r\n    return gen;\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n}\r\n\r\n/**\r\n * Generates a runtime message to plain object converter specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nconverter.toObject = function toObject(mtype) {\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\r\n    if (!fields.length)\r\n        return util.codegen()(\"return {}\");\r\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\r\n    (\"if(!o)\")\r\n        (\"o={}\")\r\n    (\"var d={}\");\r\n\r\n    var repeatedFields = [],\r\n        mapFields = [],\r\n        normalFields = [],\r\n        i = 0;\r\n    for (; i < fields.length; ++i)\r\n        if (!fields[i].partOf)\r\n            ( fields[i].resolve().repeated ? repeatedFields\r\n            : fields[i].map ? mapFields\r\n            : normalFields).push(fields[i]);\r\n\r\n    if (repeatedFields.length) { gen\r\n    (\"if(o.arrays||o.defaults){\");\r\n        for (i = 0; i < repeatedFields.length; ++i) gen\r\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\r\n        gen\r\n    (\"}\");\r\n    }\r\n\r\n    if (mapFields.length) { gen\r\n    (\"if(o.objects||o.defaults){\");\r\n        for (i = 0; i < mapFields.length; ++i) gen\r\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\r\n        gen\r\n    (\"}\");\r\n    }\r\n\r\n    if (normalFields.length) { gen\r\n    (\"if(o.defaults){\");\r\n        for (i = 0; i < normalFields.length; ++i) {\r\n            var field = normalFields[i],\r\n                prop  = util.safeProp(field.name);\r\n            if (field.resolvedType instanceof Enum) gen\r\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\r\n            else if (field.long) gen\r\n        (\"if(util.Long){\")\r\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\r\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\r\n        (\"}else\")\r\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\r\n            else if (field.bytes) {\r\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\r\n                gen\r\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\r\n        (\"else{\")\r\n            (\"d%s=%s\", prop, arrayDefault)\r\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\r\n        (\"}\");\r\n            } else gen\r\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\r\n        } gen\r\n    (\"}\");\r\n    }\r\n    var hasKs2 = false;\r\n    for (i = 0; i < fields.length; ++i) {\r\n        var field = fields[i],\r\n            index = mtype._fieldsArray.indexOf(field),\r\n            prop  = util.safeProp(field.name);\r\n        if (field.map) {\r\n            if (!hasKs2) { hasKs2 = true; gen\r\n    (\"var ks2\");\r\n            } gen\r\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\r\n        (\"d%s={}\", prop)\r\n        (\"for(var j=0;j<ks2.length;++j){\");\r\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\r\n        (\"}\");\r\n        } else if (field.repeated) { gen\r\n    (\"if(m%s&&m%s.length){\", prop, prop)\r\n        (\"d%s=[]\", prop)\r\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\r\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\r\n        (\"}\");\r\n        } else { gen\r\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\r\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\r\n        if (field.partOf) gen\r\n        (\"if(o.oneofs)\")\r\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\r\n        }\r\n        gen\r\n    (\"}\");\r\n    }\r\n    return gen\r\n    (\"return d\");\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNGQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxzRkFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCwwQkFBMEI7QUFDMUIsNEZBQTRGLGlCQUFpQjtBQUM3RztBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLHVEQUF1RCxRQUFRLE1BQU07QUFDckU7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxlQUFlO0FBQ2YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiwwQ0FBMEMsWUFBWSxLQUFLO0FBQzNEO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhLEtBQUs7QUFDeEM7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyxvQkFBb0Isc0JBQXNCO0FBQzFDLGdCQUFnQjtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHFCQUFxQjtBQUNyQixvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsY0FBYztBQUNkLDZDQUE2QztBQUM3QyxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQSxjQUFjO0FBQ2QsNkNBQTZDO0FBQzdDLGdCQUFnQjtBQUNoQixzQkFBc0IsYUFBYSxLQUFLO0FBQ3hDO0FBQ0EsV0FBVztBQUNYLFVBQVUsMkJBQTJCO0FBQ3JDLDBCQUEwQjtBQUMxQjtBQUNBLHNCQUFzQixhQUFhLEtBQUs7QUFDeEM7QUFDQSxXQUFXO0FBQ1gsVUFBVSxPQUFPO0FBQ2pCLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29udmVydGVyLmpzPzM3NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBSdW50aW1lIG1lc3NhZ2UgZnJvbS90byBwbGFpbiBvYmplY3QgY29udmVydGVycy5cclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGNvbnZlcnRlciA9IGV4cG9ydHM7XHJcblxyXG52YXIgRW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIiksXHJcbiAgICB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIGZyb21PYmplY3QgY29udmV0ZXIuXHJcbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcclxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxyXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCBwcm9wKSB7XHJcbiAgICB2YXIgZGVmYXVsdEFscmVhZHlFbWl0dGVkID0gZmFsc2U7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXHJcbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XHJcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXHJcbiAgICAgICAgICAgIChcInN3aXRjaChkJXMpe1wiLCBwcm9wKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdmFsdWVzID0gZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlcywga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZW51bSB1bmtub3duIHZhbHVlcyBwYXNzdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXlzW2ldXSA9PT0gZmllbGQudHlwZURlZmF1bHQgJiYgIWRlZmF1bHRBbHJlYWR5RW1pdHRlZCkgeyBnZW5cclxuICAgICAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YoZCVzKT09PVxcXCJudW1iZXJcXFwiKXttJXM9ZCVzO2JyZWFrfVwiLCBwcm9wLCBwcm9wLCBwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnJlcGVhdGVkKSBnZW4gLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCB2YWx1ZSBvbmx5IGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheXMsIHRvIGF2b2lkIGxlYXZpbmcgaG9sZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpOyAgICAgICAgICAgLy8gZm9yIG5vbi1yZXBlYXRlZCBmaWVsZHMsIGp1c3QgaWdub3JlXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEFscmVhZHlFbWl0dGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdlblxyXG4gICAgICAgICAgICAgICAgKFwiY2FzZSVqOlwiLCBrZXlzW2ldKVxyXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgdmFsdWVzW2tleXNbaV1dKVxyXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz0lalwiLCBwcm9wLCB2YWx1ZXNba2V5c1tpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIik7XHJcbiAgICAgICAgICAgIH0gZ2VuXHJcbiAgICAgICAgICAgIChcIn1cIik7XHJcbiAgICAgICAgfSBlbHNlIGdlblxyXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXHJcbiAgICAgICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxyXG4gICAgICAgICAgICAoXCJtJXM9dHlwZXNbJWldLmZyb21PYmplY3QoZCVzKVwiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJtJXM9TnVtYmVyKGQlcylcIiwgcHJvcCwgcHJvcCk7IC8vIGFsc28gY2F0Y2hlcyBcIk5hTlwiLCBcIkluZmluaXR5XCJcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6IGdlblxyXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlcz4+PjBcIiwgcHJvcCwgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxyXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc3wwXCIsIHByb3AsIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcclxuICAgICAgICAgICAgICAgIGlzVW5zaWduZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cclxuICAgICAgICAgICAgICAgIChcImlmKHV0aWwuTG9uZylcIilcclxuICAgICAgICAgICAgICAgICAgICAoXCIobSVzPXV0aWwuTG9uZy5mcm9tVmFsdWUoZCVzKSkudW5zaWduZWQ9JWpcIiwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZClcclxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxyXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1wYXJzZUludChkJXMsMTApXCIsIHByb3AsIHByb3ApXHJcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwibnVtYmVyXFxcIilcIiwgcHJvcClcclxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApXHJcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcclxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9bmV3IHV0aWwuTG9uZ0JpdHMoZCVzLmxvdz4+PjAsZCVzLmhpZ2g+Pj4wKS50b051bWJlciglcylcIiwgcHJvcCwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZCA/IFwidHJ1ZVwiIDogXCJcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxyXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInV0aWwuYmFzZTY0LmRlY29kZShkJXMsbSVzPXV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aChkJXMpKSwwKVwiLCBwcm9wLCBwcm9wLCBwcm9wKVxyXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZihkJXMubGVuZ3RoID49IDApXCIsIHByb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxyXG4gICAgICAgICAgICAgICAgKFwibSVzPVN0cmluZyhkJXMpXCIsIHByb3AsIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxyXG4gICAgICAgICAgICAgICAgKFwibSVzPUJvb2xlYW4oZCVzKVwiLCBwcm9wLCBwcm9wKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvKiBkZWZhdWx0OiBnZW5cclxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgKi9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2VuO1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwbGFpbiBvYmplY3QgdG8gcnVudGltZSBtZXNzYWdlIGNvbnZlcnRlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cclxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcclxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcclxuICovXHJcbmNvbnZlcnRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChtdHlwZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xyXG4gICAgdmFyIGZpZWxkcyA9IG10eXBlLmZpZWxkc0FycmF5O1xyXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJkXCJdLCBtdHlwZS5uYW1lICsgXCIkZnJvbU9iamVjdFwiKVxyXG4gICAgKFwiaWYoZCBpbnN0YW5jZW9mIHRoaXMuY3RvcilcIilcclxuICAgICAgICAoXCJyZXR1cm4gZFwiKTtcclxuICAgIGlmICghZmllbGRzLmxlbmd0aCkgcmV0dXJuIGdlblxyXG4gICAgKFwicmV0dXJuIG5ldyB0aGlzLmN0b3JcIik7XHJcbiAgICBnZW5cclxuICAgIChcInZhciBtPW5ldyB0aGlzLmN0b3JcIik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBmaWVsZCAgPSBmaWVsZHNbaV0ucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgICBwcm9wICAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xyXG5cclxuICAgICAgICAvLyBNYXAgZmllbGRzXHJcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cclxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXHJcbiAgICAgICAgKFwiaWYodHlwZW9mIGQlcyE9PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxyXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxyXG4gICAgICAgIChcIm0lcz17fVwiLCBwcm9wKVxyXG4gICAgICAgIChcImZvcih2YXIga3M9T2JqZWN0LmtleXMoZCVzKSxpPTA7aTxrcy5sZW5ndGg7KytpKXtcIiwgcHJvcCk7XHJcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2tzW2ldXVwiKVxyXG4gICAgICAgIChcIn1cIilcclxuICAgIChcIn1cIik7XHJcblxyXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXHJcbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxyXG4gICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KGQlcykpXCIsIHByb3ApXHJcbiAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogYXJyYXkgZXhwZWN0ZWRcIilcclxuICAgICAgICAoXCJtJXM9W11cIiwgcHJvcClcclxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGQlcy5sZW5ndGg7KytpKXtcIiwgcHJvcCk7XHJcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2ldXCIpXHJcbiAgICAgICAgKFwifVwiKVxyXG4gICAgKFwifVwiKTtcclxuXHJcbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkIGZpZWxkc1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKSBnZW4gLy8gbm8gbmVlZCB0byB0ZXN0IGZvciBudWxsL3VuZGVmaW5lZCBpZiBhbiBlbnVtICh1c2VzIHN3aXRjaClcclxuICAgIChcImlmKGQlcyE9bnVsbCl7XCIsIHByb3ApOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXHJcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wKTtcclxuICAgICAgICAgICAgaWYgKCEoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpIGdlblxyXG4gICAgKFwifVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9IHJldHVybiBnZW5cclxuICAgIChcInJldHVybiBtXCIpO1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSB0b09iamVjdCBjb252ZXJ0ZXIuXHJcbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcclxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxyXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xyXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xyXG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cclxuICAgICAgICAgICAgKFwiZCVzPW8uZW51bXM9PT1TdHJpbmc/KHR5cGVzWyVpXS52YWx1ZXNbbSVzXT09PXVuZGVmaW5lZD9tJXM6dHlwZXNbJWldLnZhbHVlc1ttJXNdKTptJXNcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCwgcHJvcCk7XHJcbiAgICAgICAgZWxzZSBnZW5cclxuICAgICAgICAgICAgKFwiZCVzPXR5cGVzWyVpXS50b09iamVjdChtJXMsbylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBpc1Vuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6IGdlblxyXG4gICAgICAgICAgICAoXCJkJXM9by5qc29uJiYhaXNGaW5pdGUobSVzKT9TdHJpbmcobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxyXG4gICAgICAgICAgICAgICAgaXNVbnNpZ25lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxyXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgbSVzPT09XFxcIm51bWJlclxcXCIpXCIsIHByb3ApXHJcbiAgICAgICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9TdHJpbmcobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcClcclxuICAgICAgICAgICAgKFwiZWxzZVwiKSAvLyBMb25nLWxpa2VcclxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP3V0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtJXMpOm8ubG9uZ3M9PT1OdW1iZXI/bmV3IHV0aWwuTG9uZ0JpdHMobSVzLmxvdz4+PjAsbSVzLmhpZ2g+Pj4wKS50b051bWJlciglcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIGlzVW5zaWduZWQgPyBcInRydWVcIjogXCJcIiwgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxyXG4gICAgICAgICAgICAoXCJkJXM9by5ieXRlcz09PVN0cmluZz91dGlsLmJhc2U2NC5lbmNvZGUobSVzLDAsbSVzLmxlbmd0aCk6by5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGdlblxyXG4gICAgICAgICAgICAoXCJkJXM9bSVzXCIsIHByb3AsIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdlbjtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcnVudGltZSBtZXNzYWdlIHRvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXHJcbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXHJcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXHJcbiAqL1xyXG5jb252ZXJ0ZXIudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtdHlwZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xyXG4gICAgdmFyIGZpZWxkcyA9IG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcclxuICAgIGlmICghZmllbGRzLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gdXRpbC5jb2RlZ2VuKCkoXCJyZXR1cm4ge31cIik7XHJcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIiwgXCJvXCJdLCBtdHlwZS5uYW1lICsgXCIkdG9PYmplY3RcIilcclxuICAgIChcImlmKCFvKVwiKVxyXG4gICAgICAgIChcIm89e31cIilcclxuICAgIChcInZhciBkPXt9XCIpO1xyXG5cclxuICAgIHZhciByZXBlYXRlZEZpZWxkcyA9IFtdLFxyXG4gICAgICAgIG1hcEZpZWxkcyA9IFtdLFxyXG4gICAgICAgIG5vcm1hbEZpZWxkcyA9IFtdLFxyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgZm9yICg7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgaWYgKCFmaWVsZHNbaV0ucGFydE9mKVxyXG4gICAgICAgICAgICAoIGZpZWxkc1tpXS5yZXNvbHZlKCkucmVwZWF0ZWQgPyByZXBlYXRlZEZpZWxkc1xyXG4gICAgICAgICAgICA6IGZpZWxkc1tpXS5tYXAgPyBtYXBGaWVsZHNcclxuICAgICAgICAgICAgOiBub3JtYWxGaWVsZHMpLnB1c2goZmllbGRzW2ldKTtcclxuXHJcbiAgICBpZiAocmVwZWF0ZWRGaWVsZHMubGVuZ3RoKSB7IGdlblxyXG4gICAgKFwiaWYoby5hcnJheXN8fG8uZGVmYXVsdHMpe1wiKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0ZWRGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxyXG4gICAgICAgIChcImQlcz1bXVwiLCB1dGlsLnNhZmVQcm9wKHJlcGVhdGVkRmllbGRzW2ldLm5hbWUpKTtcclxuICAgICAgICBnZW5cclxuICAgIChcIn1cIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hcEZpZWxkcy5sZW5ndGgpIHsgZ2VuXHJcbiAgICAoXCJpZihvLm9iamVjdHN8fG8uZGVmYXVsdHMpe1wiKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWFwRmllbGRzLmxlbmd0aDsgKytpKSBnZW5cclxuICAgICAgICAoXCJkJXM9e31cIiwgdXRpbC5zYWZlUHJvcChtYXBGaWVsZHNbaV0ubmFtZSkpO1xyXG4gICAgICAgIGdlblxyXG4gICAgKFwifVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9ybWFsRmllbGRzLmxlbmd0aCkgeyBnZW5cclxuICAgIChcImlmKG8uZGVmYXVsdHMpe1wiKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9ybWFsRmllbGRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG5vcm1hbEZpZWxkc1tpXSxcclxuICAgICAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIGdlblxyXG4gICAgICAgIChcImQlcz1vLmVudW1zPT09U3RyaW5nPyVqOiVqXCIsIHByb3AsIGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW2ZpZWxkLnR5cGVEZWZhdWx0XSwgZmllbGQudHlwZURlZmF1bHQpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5sb25nKSBnZW5cclxuICAgICAgICAoXCJpZih1dGlsLkxvbmcpe1wiKVxyXG4gICAgICAgICAgICAoXCJ2YXIgbj1uZXcgdXRpbC5Mb25nKCVpLCVpLCVqKVwiLCBmaWVsZC50eXBlRGVmYXVsdC5sb3csIGZpZWxkLnR5cGVEZWZhdWx0LmhpZ2gsIGZpZWxkLnR5cGVEZWZhdWx0LnVuc2lnbmVkKVxyXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9uLnRvU3RyaW5nKCk6by5sb25ncz09PU51bWJlcj9uLnRvTnVtYmVyKCk6blwiLCBwcm9wKVxyXG4gICAgICAgIChcIn1lbHNlXCIpXHJcbiAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nPyVqOiVpXCIsIHByb3AsIGZpZWxkLnR5cGVEZWZhdWx0LnRvU3RyaW5nKCksIGZpZWxkLnR5cGVEZWZhdWx0LnRvTnVtYmVyKCkpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5ieXRlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycmF5RGVmYXVsdCA9IFwiW1wiICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmllbGQudHlwZURlZmF1bHQpLmpvaW4oXCIsXCIpICsgXCJdXCI7XHJcbiAgICAgICAgICAgICAgICBnZW5cclxuICAgICAgICAoXCJpZihvLmJ5dGVzPT09U3RyaW5nKWQlcz0lalwiLCBwcm9wLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZmllbGQudHlwZURlZmF1bHQpKVxyXG4gICAgICAgIChcImVsc2V7XCIpXHJcbiAgICAgICAgICAgIChcImQlcz0lc1wiLCBwcm9wLCBhcnJheURlZmF1bHQpXHJcbiAgICAgICAgICAgIChcImlmKG8uYnl0ZXMhPT1BcnJheSlkJXM9dXRpbC5uZXdCdWZmZXIoZCVzKVwiLCBwcm9wLCBwcm9wKVxyXG4gICAgICAgIChcIn1cIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBnZW5cclxuICAgICAgICAoXCJkJXM9JWpcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQpOyAvLyBhbHNvIG1lc3NhZ2VzICg9bnVsbClcclxuICAgICAgICB9IGdlblxyXG4gICAgKFwifVwiKTtcclxuICAgIH1cclxuICAgIHZhciBoYXNLczIgPSBmYWxzZTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV0sXHJcbiAgICAgICAgICAgIGluZGV4ID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxyXG4gICAgICAgICAgICBwcm9wICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XHJcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc0tzMikgeyBoYXNLczIgPSB0cnVlOyBnZW5cclxuICAgIChcInZhciBrczJcIik7XHJcbiAgICAgICAgICAgIH0gZ2VuXHJcbiAgICAoXCJpZihtJXMmJihrczI9T2JqZWN0LmtleXMobSVzKSkubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcclxuICAgICAgICAoXCJkJXM9e31cIiwgcHJvcClcclxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPGtzMi5sZW5ndGg7KytqKXtcIik7XHJcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltrczJbal1dXCIpXHJcbiAgICAgICAgKFwifVwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxyXG4gICAgKFwiaWYobSVzJiZtJXMubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcclxuICAgICAgICAoXCJkJXM9W11cIiwgcHJvcClcclxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPG0lcy5sZW5ndGg7KytqKXtcIiwgcHJvcCk7XHJcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltqXVwiKVxyXG4gICAgICAgIChcIn1cIik7XHJcbiAgICAgICAgfSBlbHNlIHsgZ2VuXHJcbiAgICAoXCJpZihtJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcHJvcCwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcclxuICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wKTtcclxuICAgICAgICBpZiAoZmllbGQucGFydE9mKSBnZW5cclxuICAgICAgICAoXCJpZihvLm9uZW9mcylcIilcclxuICAgICAgICAgICAgKFwiZCVzPSVqXCIsIHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpLCBmaWVsZC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2VuXHJcbiAgICAoXCJ9XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdlblxyXG4gICAgKFwicmV0dXJuIGRcIik7XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = decoder;\r\n\r\nvar Enum    = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    types   = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"),\r\n    util    = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nfunction missing(field) {\r\n    return \"missing required '\" + field.name + \"'\";\r\n}\r\n\r\n/**\r\n * Generates a decoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nfunction decoder(mtype) {\r\n    /* eslint-disable no-unexpected-multiline */\r\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\r\n    (\"if(!(r instanceof Reader))\")\r\n        (\"r=Reader.create(r)\")\r\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\r\n    (\"while(r.pos<c){\")\r\n        (\"var t=r.uint32()\");\r\n    if (mtype.group) gen\r\n        (\"if((t&7)===4)\")\r\n            (\"break\");\r\n    gen\r\n        (\"switch(t>>>3){\");\r\n\r\n    var i = 0;\r\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\r\n        var field = mtype._fieldsArray[i].resolve(),\r\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\r\n            ref   = \"m\" + util.safeProp(field.name); gen\r\n            (\"case %i: {\", field.id);\r\n\r\n        // Map fields\r\n        if (field.map) { gen\r\n                (\"if(%s===util.emptyObject)\", ref)\r\n                    (\"%s={}\", ref)\r\n                (\"var c2 = r.uint32()+r.pos\");\r\n\r\n            if (types.defaults[field.keyType] !== undefined) gen\r\n                (\"k=%j\", types.defaults[field.keyType]);\r\n            else gen\r\n                (\"k=null\");\r\n\r\n            if (types.defaults[type] !== undefined) gen\r\n                (\"value=%j\", types.defaults[type]);\r\n            else gen\r\n                (\"value=null\");\r\n\r\n            gen\r\n                (\"while(r.pos<c2){\")\r\n                    (\"var tag2=r.uint32()\")\r\n                    (\"switch(tag2>>>3){\")\r\n                        (\"case 1: k=r.%s(); break\", field.keyType)\r\n                        (\"case 2:\");\r\n\r\n            if (types.basic[type] === undefined) gen\r\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\r\n            else gen\r\n                            (\"value=r.%s()\", type);\r\n\r\n            gen\r\n                            (\"break\")\r\n                        (\"default:\")\r\n                            (\"r.skipType(tag2&7)\")\r\n                            (\"break\")\r\n                    (\"}\")\r\n                (\"}\");\r\n\r\n            if (types.long[field.keyType] !== undefined) gen\r\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\r\n            else gen\r\n                (\"%s[k]=value\", ref);\r\n\r\n        // Repeated fields\r\n        } else if (field.repeated) { gen\r\n\r\n                (\"if(!(%s&&%s.length))\", ref, ref)\r\n                    (\"%s=[]\", ref);\r\n\r\n            // Packable (always check for forward and backward compatiblity)\r\n            if (types.packed[type] !== undefined) gen\r\n                (\"if((t&7)===2){\")\r\n                    (\"var c2=r.uint32()+r.pos\")\r\n                    (\"while(r.pos<c2)\")\r\n                        (\"%s.push(r.%s())\", ref, type)\r\n                (\"}else\");\r\n\r\n            // Non-packed\r\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\r\n                    ? \"%s.push(types[%i].decode(r))\"\r\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\r\n            else gen\r\n                    (\"%s.push(r.%s())\", ref, type);\r\n\r\n        // Non-repeated\r\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\r\n                ? \"%s=types[%i].decode(r)\"\r\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\r\n        else gen\r\n                (\"%s=r.%s()\", ref, type);\r\n        gen\r\n                (\"break\")\r\n            (\"}\");\r\n        // Unknown fields\r\n    } gen\r\n            (\"default:\")\r\n                (\"r.skipType(t&7)\")\r\n                (\"break\")\r\n\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n    // Field presence\r\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\r\n        var rfield = mtype._fieldsArray[i];\r\n        if (rfield.required) gen\r\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\r\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\r\n    }\r\n\r\n    return gen\r\n    (\"return m\");\r\n    /* eslint-enable no-unexpected-multiline */\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0ZBQVE7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLHdGQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLG1CQUFtQjtBQUMxSCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0Q7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHVDQUF1QztBQUN2Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcz85YWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZXI7XHJcblxyXG52YXIgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXHJcbiAgICB0eXBlcyAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXHJcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuXHJcbmZ1bmN0aW9uIG1pc3NpbmcoZmllbGQpIHtcclxuICAgIHJldHVybiBcIm1pc3NpbmcgcmVxdWlyZWQgJ1wiICsgZmllbGQubmFtZSArIFwiJ1wiO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgZGVjb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cclxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcclxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZXIobXR5cGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXHJcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcInJcIiwgXCJsXCJdLCBtdHlwZS5uYW1lICsgXCIkZGVjb2RlXCIpXHJcbiAgICAoXCJpZighKHIgaW5zdGFuY2VvZiBSZWFkZXIpKVwiKVxyXG4gICAgICAgIChcInI9UmVhZGVyLmNyZWF0ZShyKVwiKVxyXG4gICAgKFwidmFyIGM9bD09PXVuZGVmaW5lZD9yLmxlbjpyLnBvcytsLG09bmV3IHRoaXMuY3RvclwiICsgKG10eXBlLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGQubWFwOyB9KS5sZW5ndGggPyBcIixrLHZhbHVlXCIgOiBcIlwiKSlcclxuICAgIChcIndoaWxlKHIucG9zPGMpe1wiKVxyXG4gICAgICAgIChcInZhciB0PXIudWludDMyKClcIik7XHJcbiAgICBpZiAobXR5cGUuZ3JvdXApIGdlblxyXG4gICAgICAgIChcImlmKCh0JjcpPT09NClcIilcclxuICAgICAgICAgICAgKFwiYnJlYWtcIik7XHJcbiAgICBnZW5cclxuICAgICAgICAoXCJzd2l0Y2godD4+PjMpe1wiKTtcclxuXHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICBmb3IgKDsgaSA8IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcclxuICAgICAgICAgICAgdHlwZSAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcclxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7IGdlblxyXG4gICAgICAgICAgICAoXCJjYXNlICVpOiB7XCIsIGZpZWxkLmlkKTtcclxuXHJcbiAgICAgICAgLy8gTWFwIGZpZWxkc1xyXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJpZiglcz09PXV0aWwuZW1wdHlPYmplY3QpXCIsIHJlZilcclxuICAgICAgICAgICAgICAgICAgICAoXCIlcz17fVwiLCByZWYpXHJcbiAgICAgICAgICAgICAgICAoXCJ2YXIgYzIgPSByLnVpbnQzMigpK3IucG9zXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxyXG4gICAgICAgICAgICAgICAgKFwiaz0lalwiLCB0eXBlcy5kZWZhdWx0c1tmaWVsZC5rZXlUeXBlXSk7XHJcbiAgICAgICAgICAgIGVsc2UgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJrPW51bGxcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZXMuZGVmYXVsdHNbdHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJ2YWx1ZT0lalwiLCB0eXBlcy5kZWZhdWx0c1t0eXBlXSk7XHJcbiAgICAgICAgICAgIGVsc2UgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJ2YWx1ZT1udWxsXCIpO1xyXG5cclxuICAgICAgICAgICAgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJ3aGlsZShyLnBvczxjMil7XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIHRhZzI9ci51aW50MzIoKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInN3aXRjaCh0YWcyPj4+Myl7XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImNhc2UgMTogaz1yLiVzKCk7IGJyZWFrXCIsIGZpZWxkLmtleVR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImNhc2UgMjpcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT10eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSlcIiwgaSk7IC8vIGNhbid0IGJlIGdyb3Vwc1xyXG4gICAgICAgICAgICBlbHNlIGdlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwidmFsdWU9ci4lcygpXCIsIHR5cGUpO1xyXG5cclxuICAgICAgICAgICAgZ2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0YWcyJjcpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIChcIn1cIilcclxuICAgICAgICAgICAgICAgIChcIn1cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZXMubG9uZ1tmaWVsZC5rZXlUeXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cclxuICAgICAgICAgICAgICAgIChcIiVzW3R5cGVvZiBrPT09XFxcIm9iamVjdFxcXCI/dXRpbC5sb25nVG9IYXNoKGspOmtdPXZhbHVlXCIsIHJlZik7XHJcbiAgICAgICAgICAgIGVsc2UgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCIlc1trXT12YWx1ZVwiLCByZWYpO1xyXG5cclxuICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcclxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxyXG5cclxuICAgICAgICAgICAgICAgIChcImlmKCEoJXMmJiVzLmxlbmd0aCkpXCIsIHJlZiwgcmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPVtdXCIsIHJlZik7XHJcblxyXG4gICAgICAgICAgICAvLyBQYWNrYWJsZSAoYWx3YXlzIGNoZWNrIGZvciBmb3J3YXJkIGFuZCBiYWNrd2FyZCBjb21wYXRpYmxpdHkpXHJcbiAgICAgICAgICAgIGlmICh0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJpZigodCY3KT09PTIpe1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInZhciBjMj1yLnVpbnQzMigpK3IucG9zXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAoXCJ9ZWxzZVwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcclxuICAgICAgICAgICAgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlbihmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICA/IFwiJXMucHVzaCh0eXBlc1slaV0uZGVjb2RlKHIpKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiVzLnB1c2godHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpKVwiLCByZWYsIGkpO1xyXG4gICAgICAgICAgICBlbHNlIGdlblxyXG4gICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpO1xyXG5cclxuICAgICAgICAvLyBOb24tcmVwZWF0ZWRcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlbihmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcclxuICAgICAgICAgICAgICAgID8gXCIlcz10eXBlc1slaV0uZGVjb2RlKHIpXCJcclxuICAgICAgICAgICAgICAgIDogXCIlcz10eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSlcIiwgcmVmLCBpKTtcclxuICAgICAgICBlbHNlIGdlblxyXG4gICAgICAgICAgICAgICAgKFwiJXM9ci4lcygpXCIsIHJlZiwgdHlwZSk7XHJcbiAgICAgICAgZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxyXG4gICAgICAgICAgICAoXCJ9XCIpO1xyXG4gICAgICAgIC8vIFVua25vd24gZmllbGRzXHJcbiAgICB9IGdlblxyXG4gICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxyXG4gICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0JjcpXCIpXHJcbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxyXG5cclxuICAgICAgICAoXCJ9XCIpXHJcbiAgICAoXCJ9XCIpO1xyXG5cclxuICAgIC8vIEZpZWxkIHByZXNlbmNlXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXR5cGUuX2ZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHJmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXTtcclxuICAgICAgICBpZiAocmZpZWxkLnJlcXVpcmVkKSBnZW5cclxuICAgIChcImlmKCFtLmhhc093blByb3BlcnR5KCVqKSlcIiwgcmZpZWxkLm5hbWUpXHJcbiAgICAgICAgKFwidGhyb3cgdXRpbC5Qcm90b2NvbEVycm9yKCVqLHtpbnN0YW5jZTptfSlcIiwgbWlzc2luZyhyZmllbGQpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2VuXHJcbiAgICAoXCJyZXR1cm4gbVwiKTtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = encoder;\r\n\r\nvar Enum     = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    types    = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"),\r\n    util     = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n/**\r\n * Generates a partial message type encoder.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genTypePartial(gen, field, fieldIndex, ref) {\r\n    return field.resolvedType.group\r\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\r\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\r\n}\r\n\r\n/**\r\n * Generates an encoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nfunction encoder(mtype) {\r\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\r\n    (\"if(!w)\")\r\n        (\"w=Writer.create()\");\r\n\r\n    var i, ref;\r\n\r\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\r\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\r\n\r\n    for (var i = 0; i < fields.length; ++i) {\r\n        var field    = fields[i].resolve(),\r\n            index    = mtype._fieldsArray.indexOf(field),\r\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\r\n            wireType = types.basic[type];\r\n            ref      = \"m\" + util.safeProp(field.name);\r\n\r\n        // Map fields\r\n        if (field.map) {\r\n            gen\r\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\r\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\r\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\r\n            if (wireType === undefined) gen\r\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\r\n            else gen\r\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\r\n            gen\r\n        (\"}\")\r\n    (\"}\");\r\n\r\n            // Repeated fields\r\n        } else if (field.repeated) { gen\r\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\r\n\r\n            // Packed repeated\r\n            if (field.packed && types.packed[type] !== undefined) { gen\r\n\r\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\r\n        (\"for(var i=0;i<%s.length;++i)\", ref)\r\n            (\"w.%s(%s[i])\", type, ref)\r\n        (\"w.ldelim()\");\r\n\r\n            // Non-packed\r\n            } else { gen\r\n\r\n        (\"for(var i=0;i<%s.length;++i)\", ref);\r\n                if (wireType === undefined)\r\n            genTypePartial(gen, field, index, ref + \"[i]\");\r\n                else gen\r\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\r\n\r\n            } gen\r\n    (\"}\");\r\n\r\n        // Non-repeated\r\n        } else {\r\n            if (field.optional) gen\r\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\r\n\r\n            if (wireType === undefined)\r\n        genTypePartial(gen, field, index, ref);\r\n            else gen\r\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\r\n\r\n        }\r\n    }\r\n\r\n    return gen\r\n    (\"return w\");\r\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0ZBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdGQUFTO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyxzRkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx5Q0FBeUMsWUFBWSxLQUFLO0FBQzFEO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckMsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanM/Yzk1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVyO1xyXG5cclxudmFyIEVudW0gICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcclxuICAgIHR5cGVzICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXHJcbiAgICB1dGlsICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBtZXNzYWdlIHR5cGUgZW5jb2Rlci5cclxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcclxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcclxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuVHlwZVBhcnRpYWwoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcmVmKSB7XHJcbiAgICByZXR1cm4gZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXHJcbiAgICAgICAgPyBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKSkudWludDMyKCVpKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMykgPj4+IDAsIChmaWVsZC5pZCA8PCAzIHwgNCkgPj4+IDApXHJcbiAgICAgICAgOiBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKS5mb3JrKCkpLmxkZWxpbSgpXCIsIGZpZWxkSW5kZXgsIHJlZiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYW4gZW5jb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cclxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcclxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZXIobXR5cGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cclxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiLCBcIndcIl0sIG10eXBlLm5hbWUgKyBcIiRlbmNvZGVcIilcclxuICAgIChcImlmKCF3KVwiKVxyXG4gICAgICAgIChcInc9V3JpdGVyLmNyZWF0ZSgpXCIpO1xyXG5cclxuICAgIHZhciBpLCByZWY7XHJcblxyXG4gICAgLy8gXCJ3aGVuIGEgbWVzc2FnZSBpcyBzZXJpYWxpemVkIGl0cyBrbm93biBmaWVsZHMgc2hvdWxkIGJlIHdyaXR0ZW4gc2VxdWVudGlhbGx5IGJ5IGZpZWxkIG51bWJlclwiXHJcbiAgICB2YXIgZmllbGRzID0gLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGZpZWxkICAgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcclxuICAgICAgICAgICAgaW5kZXggICAgPSBtdHlwZS5fZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCksXHJcbiAgICAgICAgICAgIHR5cGUgICAgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlID0gdHlwZXMuYmFzaWNbdHlwZV07XHJcbiAgICAgICAgICAgIHJlZiAgICAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xyXG5cclxuICAgICAgICAvLyBNYXAgZmllbGRzXHJcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkge1xyXG4gICAgICAgICAgICBnZW5cclxuICAgIChcImlmKCVzIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSkgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxyXG4gICAgICAgIChcImZvcih2YXIga3M9T2JqZWN0LmtleXMoJXMpLGk9MDtpPGtzLmxlbmd0aDsrK2kpe1wiLCByZWYpXHJcbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKCkudWludDMyKCVpKS4lcyhrc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMCwgOCB8IHR5cGVzLm1hcEtleVtmaWVsZC5rZXlUeXBlXSwgZmllbGQua2V5VHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKSBnZW5cclxuICAgICAgICAgICAgKFwidHlwZXNbJWldLmVuY29kZSglc1trc1tpXV0sdy51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCkubGRlbGltKClcIiwgaW5kZXgsIHJlZik7IC8vIGNhbid0IGJlIGdyb3Vwc1xyXG4gICAgICAgICAgICBlbHNlIGdlblxyXG4gICAgICAgICAgICAoXCIudWludDMyKCVpKS4lcyglc1trc1tpXV0pLmxkZWxpbSgpXCIsIDE2IHwgd2lyZVR5cGUsIHR5cGUsIHJlZik7XHJcbiAgICAgICAgICAgIGdlblxyXG4gICAgICAgIChcIn1cIilcclxuICAgIChcIn1cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcclxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxyXG4gICAgKFwiaWYoJXMhPW51bGwmJiVzLmxlbmd0aCl7XCIsIHJlZiwgcmVmKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxyXG5cclxuICAgICAgICAgICAgLy8gUGFja2VkIHJlcGVhdGVkXHJcbiAgICAgICAgICAgIGlmIChmaWVsZC5wYWNrZWQgJiYgdHlwZXMucGFja2VkW3R5cGVdICE9PSB1bmRlZmluZWQpIHsgZ2VuXHJcblxyXG4gICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKClcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMClcclxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpXCIsIHJlZilcclxuICAgICAgICAgICAgKFwidy4lcyglc1tpXSlcIiwgdHlwZSwgcmVmKVxyXG4gICAgICAgIChcIncubGRlbGltKClcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXHJcbiAgICAgICAgICAgIH0gZWxzZSB7IGdlblxyXG5cclxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpXCIsIHJlZik7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZ2VuVHlwZVBhcnRpYWwoZ2VuLCBmaWVsZCwgaW5kZXgsIHJlZiArIFwiW2ldXCIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBnZW5cclxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcclxuXHJcbiAgICAgICAgICAgIH0gZ2VuXHJcbiAgICAoXCJ9XCIpO1xyXG5cclxuICAgICAgICAvLyBOb24tcmVwZWF0ZWRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZmllbGQub3B0aW9uYWwpIGdlblxyXG4gICAgKFwiaWYoJXMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sJWopKVwiLCByZWYsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXHJcblxyXG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmKTtcclxuICAgICAgICAgICAgZWxzZSBnZW5cclxuICAgICAgICAoXCJ3LnVpbnQzMiglaSkuJXMoJXMpXCIsIChmaWVsZC5pZCA8PCAzIHwgd2lyZVR5cGUpID4+PiAwLCB0eXBlLCByZWYpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdlblxyXG4gICAgKFwicmV0dXJuIHdcIik7XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Enum;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\r\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\r\n\r\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\"),\r\n    util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n/**\r\n * Constructs a new enum instance.\r\n * @classdesc Reflected enum.\r\n * @extends ReflectionObject\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {Object.<string,number>} [values] Enum values as an object, by name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] The comment for this enum\r\n * @param {Object.<string,string>} [comments] The value comments for this enum\r\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\r\n */\r\nfunction Enum(name, values, options, comment, comments, valuesOptions) {\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    if (values && typeof values !== \"object\")\r\n        throw TypeError(\"values must be an object\");\r\n\r\n    /**\r\n     * Enum values by id.\r\n     * @type {Object.<number,string>}\r\n     */\r\n    this.valuesById = {};\r\n\r\n    /**\r\n     * Enum values by name.\r\n     * @type {Object.<string,number>}\r\n     */\r\n    this.values = Object.create(this.valuesById); // toJSON, marker\r\n\r\n    /**\r\n     * Enum comment text.\r\n     * @type {string|null}\r\n     */\r\n    this.comment = comment;\r\n\r\n    /**\r\n     * Value comment texts, if any.\r\n     * @type {Object.<string,string>}\r\n     */\r\n    this.comments = comments || {};\r\n\r\n    /**\r\n     * Values options, if any\r\n     * @type {Object<string, Object<string, *>>|undefined}\r\n     */\r\n    this.valuesOptions = valuesOptions;\r\n\r\n    /**\r\n     * Reserved ranges, if any.\r\n     * @type {Array.<number[]|string>}\r\n     */\r\n    this.reserved = undefined; // toJSON\r\n\r\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\r\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\r\n    // static and reflection code alike instead of emitting generic object definitions.\r\n\r\n    if (values)\r\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\r\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\r\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\r\n}\r\n\r\n/**\r\n * Enum descriptor.\r\n * @interface IEnum\r\n * @property {Object.<string,number>} values Enum values\r\n * @property {Object.<string,*>} [options] Enum options\r\n */\r\n\r\n/**\r\n * Constructs an enum from an enum descriptor.\r\n * @param {string} name Enum name\r\n * @param {IEnum} json Enum descriptor\r\n * @returns {Enum} Created enum\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nEnum.fromJSON = function fromJSON(name, json) {\r\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\r\n    enm.reserved = json.reserved;\r\n    return enm;\r\n};\r\n\r\n/**\r\n * Converts this enum to an enum descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IEnum} Enum descriptor\r\n */\r\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"options\"       , this.options,\r\n        \"valuesOptions\" , this.valuesOptions,\r\n        \"values\"        , this.values,\r\n        \"reserved\"      , this.reserved && this.reserved.length ? this.reserved : undefined,\r\n        \"comment\"       , keepComments ? this.comment : undefined,\r\n        \"comments\"      , keepComments ? this.comments : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * Adds a value to this enum.\r\n * @param {string} name Value name\r\n * @param {number} id Value id\r\n * @param {string} [comment] Comment, if any\r\n * @param {Object.<string, *>|undefined} [options] Options, if any\r\n * @returns {Enum} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a value with this name or id\r\n */\r\nEnum.prototype.add = function add(name, id, comment, options) {\r\n    // utilized by the parser but not by .fromJSON\r\n\r\n    if (!util.isString(name))\r\n        throw TypeError(\"name must be a string\");\r\n\r\n    if (!util.isInteger(id))\r\n        throw TypeError(\"id must be an integer\");\r\n\r\n    if (this.values[name] !== undefined)\r\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\r\n\r\n    if (this.isReservedId(id))\r\n        throw Error(\"id \" + id + \" is reserved in \" + this);\r\n\r\n    if (this.isReservedName(name))\r\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\r\n\r\n    if (this.valuesById[id] !== undefined) {\r\n        if (!(this.options && this.options.allow_alias))\r\n            throw Error(\"duplicate id \" + id + \" in \" + this);\r\n        this.values[name] = id;\r\n    } else\r\n        this.valuesById[this.values[name] = id] = name;\r\n\r\n    if (options) {\r\n        if (this.valuesOptions === undefined)\r\n            this.valuesOptions = {};\r\n        this.valuesOptions[name] = options || null;\r\n    }\r\n\r\n    this.comments[name] = comment || null;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes a value from this enum\r\n * @param {string} name Value name\r\n * @returns {Enum} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `name` is not a name of this enum\r\n */\r\nEnum.prototype.remove = function remove(name) {\r\n\r\n    if (!util.isString(name))\r\n        throw TypeError(\"name must be a string\");\r\n\r\n    var val = this.values[name];\r\n    if (val == null)\r\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\r\n\r\n    delete this.valuesById[val];\r\n    delete this.values[name];\r\n    delete this.comments[name];\r\n    if (this.valuesOptions)\r\n        delete this.valuesOptions[name];\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nEnum.prototype.isReservedId = function isReservedId(id) {\r\n    return Namespace.isReservedId(this.reserved, id);\r\n};\r\n\r\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nEnum.prototype.isReservedName = function isReservedName(name) {\r\n    return Namespace.isReservedName(this.reserved, name);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW51bS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDBGQUFVO0FBQ3pDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBYTtBQUNyQyxXQUFXLG1CQUFPLENBQUMsc0ZBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUTtBQUNuQixXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLDRDQUE0QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhCQUE4QjtBQUN6QyxhQUFhLE1BQU07QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CLFlBQVksV0FBVztBQUN2QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW51bS5qcz80YjRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEVudW07XHJcblxyXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcclxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XHJcbigoRW51bS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBFbnVtKS5jbGFzc05hbWUgPSBcIkVudW1cIjtcclxuXHJcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIiksXHJcbiAgICB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGVudW0gaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIGVudW0uXHJcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gW3ZhbHVlc10gRW51bSB2YWx1ZXMgYXMgYW4gb2JqZWN0LCBieSBuYW1lXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gVGhlIGNvbW1lbnQgZm9yIHRoaXMgZW51bVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IFtjb21tZW50c10gVGhlIHZhbHVlIGNvbW1lbnRzIGZvciB0aGlzIGVudW1cclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxPYmplY3Q8c3RyaW5nLCo+Pnx1bmRlZmluZWR9IFt2YWx1ZXNPcHRpb25zXSBUaGUgdmFsdWUgb3B0aW9ucyBmb3IgdGhpcyBlbnVtXHJcbiAqL1xyXG5mdW5jdGlvbiBFbnVtKG5hbWUsIHZhbHVlcywgb3B0aW9ucywgY29tbWVudCwgY29tbWVudHMsIHZhbHVlc09wdGlvbnMpIHtcclxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICBpZiAodmFsdWVzICYmIHR5cGVvZiB2YWx1ZXMgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidmFsdWVzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW51bSB2YWx1ZXMgYnkgaWQuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsc3RyaW5nPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52YWx1ZXNCeUlkID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBuYW1lLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc0J5SWQpOyAvLyB0b0pTT04sIG1hcmtlclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW51bSBjb21tZW50IHRleHQuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSBjb21tZW50IHRleHRzLCBpZiBhbnkuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb21tZW50cyA9IGNvbW1lbnRzIHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWVzIG9wdGlvbnMsIGlmIGFueVxyXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsICo+Pnx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsdWVzT3B0aW9ucyA9IHZhbHVlc09wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cclxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyW118c3RyaW5nPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXHJcblxyXG4gICAgLy8gTm90ZSB0aGF0IHZhbHVlcyBpbmhlcml0IHZhbHVlc0J5SWQgb24gdGhlaXIgcHJvdG90eXBlIHdoaWNoIG1ha2VzIHRoZW0gYSBUeXBlU2NyaXB0LVxyXG4gICAgLy8gY29tcGF0aWJsZSBlbnVtLiBUaGlzIGlzIHVzZWQgYnkgcGJ0cyB0byB3cml0ZSBhY3R1YWwgZW51bSBkZWZpbml0aW9ucyB0aGF0IHdvcmsgZm9yXHJcbiAgICAvLyBzdGF0aWMgYW5kIHJlZmxlY3Rpb24gY29kZSBhbGlrZSBpbnN0ZWFkIG9mIGVtaXR0aW5nIGdlbmVyaWMgb2JqZWN0IGRlZmluaXRpb25zLlxyXG5cclxuICAgIGlmICh2YWx1ZXMpXHJcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNba2V5c1tpXV0gPT09IFwibnVtYmVyXCIpIC8vIHVzZSBmb3J3YXJkIGVudHJpZXMgb25seVxyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNCeUlkWyB0aGlzLnZhbHVlc1trZXlzW2ldXSA9IHZhbHVlc1trZXlzW2ldXSBdID0ga2V5c1tpXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVudW0gZGVzY3JpcHRvci5cclxuICogQGludGVyZmFjZSBJRW51bVxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj59IHZhbHVlcyBFbnVtIHZhbHVlc1xyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRW51bSBvcHRpb25zXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYW4gZW51bSBmcm9tIGFuIGVudW0gZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXHJcbiAqIEBwYXJhbSB7SUVudW19IGpzb24gRW51bSBkZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtFbnVtfSBDcmVhdGVkIGVudW1cclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICovXHJcbkVudW0uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XHJcbiAgICB2YXIgZW5tID0gbmV3IEVudW0obmFtZSwganNvbi52YWx1ZXMsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLmNvbW1lbnRzKTtcclxuICAgIGVubS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XHJcbiAgICByZXR1cm4gZW5tO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgZW51bSB0byBhbiBlbnVtIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7SUVudW19IEVudW0gZGVzY3JpcHRvclxyXG4gKi9cclxuRW51bS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcclxuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcclxuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcclxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAsIHRoaXMub3B0aW9ucyxcclxuICAgICAgICBcInZhbHVlc09wdGlvbnNcIiAsIHRoaXMudmFsdWVzT3B0aW9ucyxcclxuICAgICAgICBcInZhbHVlc1wiICAgICAgICAsIHRoaXMudmFsdWVzLFxyXG4gICAgICAgIFwicmVzZXJ2ZWRcIiAgICAgICwgdGhpcy5yZXNlcnZlZCAmJiB0aGlzLnJlc2VydmVkLmxlbmd0aCA/IHRoaXMucmVzZXJ2ZWQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJjb21tZW50XCIgICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJjb21tZW50c1wiICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnRzIDogdW5kZWZpbmVkXHJcbiAgICBdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgdmFsdWUgdG8gdGhpcyBlbnVtLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBWYWx1ZSBpZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQsIGlmIGFueVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPnx1bmRlZmluZWR9IFtvcHRpb25zXSBPcHRpb25zLCBpZiBhbnlcclxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZhbHVlIHdpdGggdGhpcyBuYW1lIG9yIGlkXHJcbiAqL1xyXG5FbnVtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgaWQsIGNvbW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIC8vIHV0aWxpemVkIGJ5IHRoZSBwYXJzZXIgYnV0IG5vdCBieSAuZnJvbUpTT05cclxuXHJcbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xyXG5cclxuICAgIGlmICghdXRpbC5pc0ludGVnZXIoaWQpKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcclxuXHJcbiAgICBpZiAodGhpcy52YWx1ZXNbbmFtZV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcclxuXHJcbiAgICBpZiAodGhpcy5pc1Jlc2VydmVkSWQoaWQpKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwiaWQgXCIgKyBpZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUobmFtZSkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcclxuXHJcbiAgICBpZiAodGhpcy52YWx1ZXNCeUlkW2lkXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hbGxvd19hbGlhcykpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xyXG4gICAgICAgIHRoaXMudmFsdWVzW25hbWVdID0gaWQ7XHJcbiAgICB9IGVsc2VcclxuICAgICAgICB0aGlzLnZhbHVlc0J5SWRbdGhpcy52YWx1ZXNbbmFtZV0gPSBpZF0gPSBuYW1lO1xyXG5cclxuICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzT3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlc09wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLnZhbHVlc09wdGlvbnNbbmFtZV0gPSBvcHRpb25zIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21tZW50c1tuYW1lXSA9IGNvbW1lbnQgfHwgbnVsbDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoaXMgZW51bVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXHJcbiAqIEByZXR1cm5zIHtFbnVtfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICogQHRocm93cyB7RXJyb3J9IElmIGBuYW1lYCBpcyBub3QgYSBuYW1lIG9mIHRoaXMgZW51bVxyXG4gKi9cclxuRW51bS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcclxuXHJcbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xyXG5cclxuICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlc1tuYW1lXTtcclxuICAgIGlmICh2YWwgPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiBcIiArIHRoaXMpO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc0J5SWRbdmFsXTtcclxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lXTtcclxuICAgIGRlbGV0ZSB0aGlzLmNvbW1lbnRzW25hbWVdO1xyXG4gICAgaWYgKHRoaXMudmFsdWVzT3B0aW9ucylcclxuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZXNPcHRpb25zW25hbWVdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAqL1xyXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQoaWQpIHtcclxuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxuRW51bS5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Field;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\r\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\r\n\r\nvar Enum  = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"),\r\n    util  = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nvar Type; // cyclic\r\n\r\nvar ruleRe = /^required|optional|repeated$/;\r\n\r\n/**\r\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\r\n * @name Field\r\n * @classdesc Reflected message field.\r\n * @extends FieldBase\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {number} id Unique id within its namespace\r\n * @param {string} type Value type\r\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\r\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\r\n\r\n/**\r\n * Constructs a field from a field descriptor.\r\n * @param {string} name Field name\r\n * @param {IField} json Field descriptor\r\n * @returns {Field} Created field\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nField.fromJSON = function fromJSON(name, json) {\r\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\r\n};\r\n\r\n/**\r\n * Not an actual constructor. Use {@link Field} instead.\r\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\r\n * @exports FieldBase\r\n * @extends ReflectionObject\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {number} id Unique id within its namespace\r\n * @param {string} type Value type\r\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\r\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] Comment associated with this field\r\n */\r\nfunction Field(name, id, type, rule, extend, options, comment) {\r\n\r\n    if (util.isObject(rule)) {\r\n        comment = extend;\r\n        options = rule;\r\n        rule = extend = undefined;\r\n    } else if (util.isObject(extend)) {\r\n        comment = options;\r\n        options = extend;\r\n        extend = undefined;\r\n    }\r\n\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    if (!util.isInteger(id) || id < 0)\r\n        throw TypeError(\"id must be a non-negative integer\");\r\n\r\n    if (!util.isString(type))\r\n        throw TypeError(\"type must be a string\");\r\n\r\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))\r\n        throw TypeError(\"rule must be a string rule\");\r\n\r\n    if (extend !== undefined && !util.isString(extend))\r\n        throw TypeError(\"extend must be a string\");\r\n\r\n    /**\r\n     * Field rule, if any.\r\n     * @type {string|undefined}\r\n     */\r\n    if (rule === \"proto3_optional\") {\r\n        rule = \"optional\";\r\n    }\r\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\r\n\r\n    /**\r\n     * Field type.\r\n     * @type {string}\r\n     */\r\n    this.type = type; // toJSON\r\n\r\n    /**\r\n     * Unique field id.\r\n     * @type {number}\r\n     */\r\n    this.id = id; // toJSON, marker\r\n\r\n    /**\r\n     * Extended type if different from parent.\r\n     * @type {string|undefined}\r\n     */\r\n    this.extend = extend || undefined; // toJSON\r\n\r\n    /**\r\n     * Whether this field is required.\r\n     * @type {boolean}\r\n     */\r\n    this.required = rule === \"required\";\r\n\r\n    /**\r\n     * Whether this field is optional.\r\n     * @type {boolean}\r\n     */\r\n    this.optional = !this.required;\r\n\r\n    /**\r\n     * Whether this field is repeated.\r\n     * @type {boolean}\r\n     */\r\n    this.repeated = rule === \"repeated\";\r\n\r\n    /**\r\n     * Whether this field is a map or not.\r\n     * @type {boolean}\r\n     */\r\n    this.map = false;\r\n\r\n    /**\r\n     * Message this field belongs to.\r\n     * @type {Type|null}\r\n     */\r\n    this.message = null;\r\n\r\n    /**\r\n     * OneOf this field belongs to, if any,\r\n     * @type {OneOf|null}\r\n     */\r\n    this.partOf = null;\r\n\r\n    /**\r\n     * The field type's default value.\r\n     * @type {*}\r\n     */\r\n    this.typeDefault = null;\r\n\r\n    /**\r\n     * The field's default value on prototypes.\r\n     * @type {*}\r\n     */\r\n    this.defaultValue = null;\r\n\r\n    /**\r\n     * Whether this field's value should be treated as a long.\r\n     * @type {boolean}\r\n     */\r\n    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\r\n\r\n    /**\r\n     * Whether this field's value is a buffer.\r\n     * @type {boolean}\r\n     */\r\n    this.bytes = type === \"bytes\";\r\n\r\n    /**\r\n     * Resolved type if not a basic type.\r\n     * @type {Type|Enum|null}\r\n     */\r\n    this.resolvedType = null;\r\n\r\n    /**\r\n     * Sister-field within the extended type if a declaring extension field.\r\n     * @type {Field|null}\r\n     */\r\n    this.extensionField = null;\r\n\r\n    /**\r\n     * Sister-field within the declaring namespace if an extended field.\r\n     * @type {Field|null}\r\n     */\r\n    this.declaringField = null;\r\n\r\n    /**\r\n     * Internally remembers whether this field is packed.\r\n     * @type {boolean|null}\r\n     * @private\r\n     */\r\n    this._packed = null;\r\n\r\n    /**\r\n     * Comment for this field.\r\n     * @type {string|null}\r\n     */\r\n    this.comment = comment;\r\n}\r\n\r\n/**\r\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\r\n * @name Field#packed\r\n * @type {boolean}\r\n * @readonly\r\n */\r\nObject.defineProperty(Field.prototype, \"packed\", {\r\n    get: function() {\r\n        // defaults to packed=true if not explicity set to false\r\n        if (this._packed === null)\r\n            this._packed = this.getOption(\"packed\") !== false;\r\n        return this._packed;\r\n    }\r\n});\r\n\r\n/**\r\n * @override\r\n */\r\nField.prototype.setOption = function setOption(name, value, ifNotSet) {\r\n    if (name === \"packed\") // clear cached before setting\r\n        this._packed = null;\r\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\r\n};\r\n\r\n/**\r\n * Field descriptor.\r\n * @interface IField\r\n * @property {string} [rule=\"optional\"] Field rule\r\n * @property {string} type Field type\r\n * @property {number} id Field id\r\n * @property {Object.<string,*>} [options] Field options\r\n */\r\n\r\n/**\r\n * Extension field descriptor.\r\n * @interface IExtensionField\r\n * @extends IField\r\n * @property {string} extend Extended type\r\n */\r\n\r\n/**\r\n * Converts this field to a field descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IField} Field descriptor\r\n */\r\nField.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"rule\"    , this.rule !== \"optional\" && this.rule || undefined,\r\n        \"type\"    , this.type,\r\n        \"id\"      , this.id,\r\n        \"extend\"  , this.extend,\r\n        \"options\" , this.options,\r\n        \"comment\" , keepComments ? this.comment : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * Resolves this field's type references.\r\n * @returns {Field} `this`\r\n * @throws {Error} If any reference cannot be resolved\r\n */\r\nField.prototype.resolve = function resolve() {\r\n\r\n    if (this.resolved)\r\n        return this;\r\n\r\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it\r\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\r\n        if (this.resolvedType instanceof Type)\r\n            this.typeDefault = null;\r\n        else // instanceof Enum\r\n            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\r\n    } else if (this.options && this.options.proto3_optional) {\r\n        // proto3 scalar value marked optional; should default to null\r\n        this.typeDefault = null;\r\n    }\r\n\r\n    // use explicitly set default value if present\r\n    if (this.options && this.options[\"default\"] != null) {\r\n        this.typeDefault = this.options[\"default\"];\r\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\")\r\n            this.typeDefault = this.resolvedType.values[this.typeDefault];\r\n    }\r\n\r\n    // remove unnecessary options\r\n    if (this.options) {\r\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))\r\n            delete this.options.packed;\r\n        if (!Object.keys(this.options).length)\r\n            this.options = undefined;\r\n    }\r\n\r\n    // convert to internal data type if necesssary\r\n    if (this.long) {\r\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\r\n\r\n        /* istanbul ignore else */\r\n        if (Object.freeze)\r\n            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\r\n\r\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\r\n        var buf;\r\n        if (util.base64.test(this.typeDefault))\r\n            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\r\n        else\r\n            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\r\n        this.typeDefault = buf;\r\n    }\r\n\r\n    // take special care of maps and repeated fields\r\n    if (this.map)\r\n        this.defaultValue = util.emptyObject;\r\n    else if (this.repeated)\r\n        this.defaultValue = util.emptyArray;\r\n    else\r\n        this.defaultValue = this.typeDefault;\r\n\r\n    // ensure proper value on prototype\r\n    if (this.parent instanceof Type)\r\n        this.parent.ctor.prototype[this.name] = this.defaultValue;\r\n\r\n    return ReflectionObject.prototype.resolve.call(this);\r\n};\r\n\r\n/**\r\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\r\n * @typedef FieldDecorator\r\n * @type {function}\r\n * @param {Object} prototype Target prototype\r\n * @param {string} fieldName Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Field decorator (TypeScript).\r\n * @name Field.d\r\n * @function\r\n * @param {number} fieldId Field id\r\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\r\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\r\n * @param {T} [defaultValue] Default value\r\n * @returns {FieldDecorator} Decorator function\r\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\r\n */\r\nField.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\r\n\r\n    // submessage: decorate the submessage and use its name as the type\r\n    if (typeof fieldType === \"function\")\r\n        fieldType = util.decorateType(fieldType).name;\r\n\r\n    // enum reference: create a reflected copy of the enum and keep reuseing it\r\n    else if (fieldType && typeof fieldType === \"object\")\r\n        fieldType = util.decorateEnum(fieldType).name;\r\n\r\n    return function fieldDecorator(prototype, fieldName) {\r\n        util.decorateType(prototype.constructor)\r\n            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { \"default\": defaultValue }));\r\n    };\r\n};\r\n\r\n/**\r\n * Field decorator (TypeScript).\r\n * @name Field.d\r\n * @function\r\n * @param {number} fieldId Field id\r\n * @param {Constructor<T>|string} fieldType Field type\r\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\r\n * @returns {FieldDecorator} Decorator function\r\n * @template T extends Message<T>\r\n * @variation 2\r\n */\r\n// like Field.d but without a default value\r\n\r\n// Sets up cyclic dependencies (called in index-light)\r\nField._configure = function configure(Type_) {\r\n    Type = Type_;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywwRkFBVTtBQUN6QztBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHNGQUFRO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyx3RkFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsc0ZBQVE7QUFDNUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVywwQkFBMEI7QUFDckMsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcsTUFBTTtBQUNOLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWUsS0FBSyxrQkFBa0I7QUFDNUU7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsK0lBQStJO0FBQzFKLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsR0FBRztBQUNkLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsa0NBQWtDO0FBQzdDLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9maWVsZC5qcz8xYjVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEZpZWxkO1xyXG5cclxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XHJcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xyXG4oKEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEZpZWxkKS5jbGFzc05hbWUgPSBcIkZpZWxkXCI7XHJcblxyXG52YXIgRW51bSAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxyXG4gICAgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcclxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuXHJcbnZhciBUeXBlOyAvLyBjeWNsaWNcclxuXHJcbnZhciBydWxlUmUgPSAvXnJlcXVpcmVkfG9wdGlvbmFsfHJlcGVhdGVkJC87XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBtZXNzYWdlIGZpZWxkIGluc3RhbmNlLiBOb3RlIHRoYXQge0BsaW5rIE1hcEZpZWxkfG1hcCBmaWVsZHN9IGhhdmUgdGhlaXIgb3duIGNsYXNzLlxyXG4gKiBAbmFtZSBGaWVsZFxyXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkLlxyXG4gKiBAZXh0ZW5kcyBGaWVsZEJhc2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbZXh0ZW5kXSBFeHRlbmRlZCB0eXBlIGlmIGRpZmZlcmVudCBmcm9tIHBhcmVudFxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgZmllbGQgZnJvbSBhIGZpZWxkIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICogQHBhcmFtIHtJRmllbGR9IGpzb24gRmllbGQgZGVzY3JpcHRvclxyXG4gKiBAcmV0dXJucyB7RmllbGR9IENyZWF0ZWQgZmllbGRcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICovXHJcbkZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZChuYW1lLCBqc29uLmlkLCBqc29uLnR5cGUsIGpzb24ucnVsZSwganNvbi5leHRlbmQsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIEZpZWxkfSBpbnN0ZWFkLlxyXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkcy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxyXG4gKiBAZXhwb3J0cyBGaWVsZEJhc2VcclxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtleHRlbmRdIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxyXG4gKi9cclxuZnVuY3Rpb24gRmllbGQobmFtZSwgaWQsIHR5cGUsIHJ1bGUsIGV4dGVuZCwgb3B0aW9ucywgY29tbWVudCkge1xyXG5cclxuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJ1bGUpKSB7XHJcbiAgICAgICAgY29tbWVudCA9IGV4dGVuZDtcclxuICAgICAgICBvcHRpb25zID0gcnVsZTtcclxuICAgICAgICBydWxlID0gZXh0ZW5kID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGV4dGVuZCkpIHtcclxuICAgICAgICBjb21tZW50ID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0gZXh0ZW5kO1xyXG4gICAgICAgIGV4dGVuZCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpZCkgfHwgaWQgPCAwKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcclxuXHJcbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcodHlwZSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xyXG5cclxuICAgIGlmIChydWxlICE9PSB1bmRlZmluZWQgJiYgIXJ1bGVSZS50ZXN0KHJ1bGUgPSBydWxlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnVsZSBtdXN0IGJlIGEgc3RyaW5nIHJ1bGVcIik7XHJcblxyXG4gICAgaWYgKGV4dGVuZCAhPT0gdW5kZWZpbmVkICYmICF1dGlsLmlzU3RyaW5nKGV4dGVuZCkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZXh0ZW5kIG11c3QgYmUgYSBzdHJpbmdcIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWVsZCBydWxlLCBpZiBhbnkuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgaWYgKHJ1bGUgPT09IFwicHJvdG8zX29wdGlvbmFsXCIpIHtcclxuICAgICAgICBydWxlID0gXCJvcHRpb25hbFwiO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ydWxlID0gcnVsZSAmJiBydWxlICE9PSBcIm9wdGlvbmFsXCIgPyBydWxlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpZWxkIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlOyAvLyB0b0pTT05cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuaXF1ZSBmaWVsZCBpZC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaWQgPSBpZDsgLy8gdG9KU09OLCBtYXJrZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50LlxyXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXh0ZW5kID0gZXh0ZW5kIHx8IHVuZGVmaW5lZDsgLy8gdG9KU09OXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXF1aXJlZCA9IHJ1bGUgPT09IFwicmVxdWlyZWRcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBvcHRpb25hbC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbmFsID0gIXRoaXMucmVxdWlyZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVwZWF0ZWQuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT09IFwicmVwZWF0ZWRcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBhIG1hcCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXAgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lc3NhZ2UgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLlxyXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9uZU9mIHRoaXMgZmllbGQgYmVsb25ncyB0bywgaWYgYW55LFxyXG4gICAgICogQHR5cGUge09uZU9mfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFydE9mID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWVsZCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWVsZCdzIGRlZmF1bHQgdmFsdWUgb24gcHJvdG90eXBlcy5cclxuICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxvbmcuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb25nID0gdXRpbC5Mb25nID8gdHlwZXMubG9uZ1t0eXBlXSAhPT0gdW5kZWZpbmVkIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBpcyBhIGJ1ZmZlci5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJ5dGVzID0gdHlwZSA9PT0gXCJieXRlc1wiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZWQgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxyXG4gICAgICogQHR5cGUge1R5cGV8RW51bXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBleHRlbmRlZCB0eXBlIGlmIGEgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZC5cclxuICAgICAqIEB0eXBlIHtGaWVsZHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4dGVuc2lvbkZpZWxkID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGRlY2xhcmluZyBuYW1lc3BhY2UgaWYgYW4gZXh0ZW5kZWQgZmllbGQuXHJcbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWNsYXJpbmdGaWVsZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbGx5IHJlbWVtYmVycyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW58bnVsbH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3BhY2tlZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLiBPbmx5IHJlbGV2YW50IHdoZW4gcmVwZWF0ZWQgYW5kIHdvcmtpbmcgd2l0aCBwcm90bzIuXHJcbiAqIEBuYW1lIEZpZWxkI3BhY2tlZFxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQHJlYWRvbmx5XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmllbGQucHJvdG90eXBlLCBcInBhY2tlZFwiLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIGlmIG5vdCBleHBsaWNpdHkgc2V0IHRvIGZhbHNlXHJcbiAgICAgICAgaWYgKHRoaXMuX3BhY2tlZCA9PT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5fcGFja2VkID0gdGhpcy5nZXRPcHRpb24oXCJwYWNrZWRcIikgIT09IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrZWQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuRmllbGQucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcclxuICAgIGlmIChuYW1lID09PSBcInBhY2tlZFwiKSAvLyBjbGVhciBjYWNoZWQgYmVmb3JlIHNldHRpbmdcclxuICAgICAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbi5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBpZk5vdFNldCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRmllbGQgZGVzY3JpcHRvci5cclxuICogQGludGVyZmFjZSBJRmllbGRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBGaWVsZCB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBGaWVsZCBpZFxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRmllbGQgb3B0aW9uc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBFeHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cclxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uRmllbGRcclxuICogQGV4dGVuZHMgSUZpZWxkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGZpZWxkIHRvIGEgZmllbGQgZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtJRmllbGR9IEZpZWxkIGRlc2NyaXB0b3JcclxuICovXHJcbkZpZWxkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xyXG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xyXG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xyXG4gICAgICAgIFwicnVsZVwiICAgICwgdGhpcy5ydWxlICE9PSBcIm9wdGlvbmFsXCIgJiYgdGhpcy5ydWxlIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICBcInR5cGVcIiAgICAsIHRoaXMudHlwZSxcclxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXHJcbiAgICAgICAgXCJleHRlbmRcIiAgLCB0aGlzLmV4dGVuZCxcclxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcclxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxyXG4gICAgXSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzb2x2ZXMgdGhpcyBmaWVsZCdzIHR5cGUgcmVmZXJlbmNlcy5cclxuICogQHJldHVybnMge0ZpZWxkfSBgdGhpc2BcclxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSByZWZlcmVuY2UgY2Fubm90IGJlIHJlc29sdmVkXHJcbiAqL1xyXG5GaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XHJcblxyXG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgaWYgKCh0aGlzLnR5cGVEZWZhdWx0ID0gdHlwZXMuZGVmYXVsdHNbdGhpcy50eXBlXSkgPT09IHVuZGVmaW5lZCkgeyAvLyBpZiBub3QgYSBiYXNpYyB0eXBlLCByZXNvbHZlIGl0XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUgPSAodGhpcy5kZWNsYXJpbmdGaWVsZCA/IHRoaXMuZGVjbGFyaW5nRmllbGQucGFyZW50IDogdGhpcy5wYXJlbnQpLmxvb2t1cFR5cGVPckVudW0odGhpcy50eXBlKTtcclxuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKVxyXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcclxuICAgICAgICBlbHNlIC8vIGluc3RhbmNlb2YgRW51bVxyXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW09iamVjdC5rZXlzKHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlcylbMF1dOyAvLyBmaXJzdCBkZWZpbmVkXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucHJvdG8zX29wdGlvbmFsKSB7XHJcbiAgICAgICAgLy8gcHJvdG8zIHNjYWxhciB2YWx1ZSBtYXJrZWQgb3B0aW9uYWw7IHNob3VsZCBkZWZhdWx0IHRvIG51bGxcclxuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2UgZXhwbGljaXRseSBzZXQgZGVmYXVsdCB2YWx1ZSBpZiBwcmVzZW50XHJcbiAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdO1xyXG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbdGhpcy50eXBlRGVmYXVsdF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IG9wdGlvbnNcclxuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhY2tlZCA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMucGFja2VkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yZXNvbHZlZFR5cGUgJiYgISh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnBhY2tlZDtcclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udmVydCB0byBpbnRlcm5hbCBkYXRhIHR5cGUgaWYgbmVjZXNzc2FyeVxyXG4gICAgaWYgKHRoaXMubG9uZykge1xyXG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB1dGlsLkxvbmcuZnJvbU51bWJlcih0aGlzLnR5cGVEZWZhdWx0LCB0aGlzLnR5cGUuY2hhckF0KDApID09PSBcInVcIik7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpXHJcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcy50eXBlRGVmYXVsdCk7IC8vIGxvbmcgaW5zdGFuY2VzIGFyZSBtZWFudCB0byBiZSBpbW11dGFibGUgYW55d2F5IChpLmUuIHVzZSBzbWFsbCBpbnQgY2FjaGUgdGhhdCBldmVuIHJlcXVpcmVzIGl0KVxyXG5cclxuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlcyAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhciBidWY7XHJcbiAgICAgICAgaWYgKHV0aWwuYmFzZTY0LnRlc3QodGhpcy50eXBlRGVmYXVsdCkpXHJcbiAgICAgICAgICAgIHV0aWwuYmFzZTY0LmRlY29kZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLmJhc2U2NC5sZW5ndGgodGhpcy50eXBlRGVmYXVsdCkpLCAwKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHV0aWwudXRmOC53cml0ZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLnV0ZjgubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XHJcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IGJ1ZjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0YWtlIHNwZWNpYWwgY2FyZSBvZiBtYXBzIGFuZCByZXBlYXRlZCBmaWVsZHNcclxuICAgIGlmICh0aGlzLm1hcClcclxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHV0aWwuZW1wdHlPYmplY3Q7XHJcbiAgICBlbHNlIGlmICh0aGlzLnJlcGVhdGVkKVxyXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdXRpbC5lbXB0eUFycmF5O1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy50eXBlRGVmYXVsdDtcclxuXHJcbiAgICAvLyBlbnN1cmUgcHJvcGVyIHZhbHVlIG9uIHByb3RvdHlwZVxyXG4gICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHlwZSlcclxuICAgICAgICB0aGlzLnBhcmVudC5jdG9yLnByb3RvdHlwZVt0aGlzLm5hbWVdID0gdGhpcy5kZWZhdWx0VmFsdWU7XHJcblxyXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIEZpZWxkLmR9IGFuZCB7QGxpbmsgTWFwRmllbGQuZH0gKFR5cGVTY3JpcHQpLlxyXG4gKiBAdHlwZWRlZiBGaWVsZERlY29yYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IHByb3RvdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIEZpZWxkIG5hbWVcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cclxuICogQG5hbWUgRmllbGQuZFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcclxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcInN0cmluZ1wifFwiYm9vbFwifFwiYnl0ZXNcInxPYmplY3R9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXHJcbiAqIEBwYXJhbSB7XCJvcHRpb25hbFwifFwicmVxdWlyZWRcInxcInJlcGVhdGVkXCJ9IFtmaWVsZFJ1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXHJcbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gRGVmYXVsdCB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIG51bWJlciB8IG51bWJlcltdIHwgTG9uZyB8IExvbmdbXSB8IHN0cmluZyB8IHN0cmluZ1tdIHwgYm9vbGVhbiB8IGJvb2xlYW5bXSB8IFVpbnQ4QXJyYXkgfCBVaW50OEFycmF5W10gfCBCdWZmZXIgfCBCdWZmZXJbXVxyXG4gKi9cclxuRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlRmllbGQoZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIGRlZmF1bHRWYWx1ZSkge1xyXG5cclxuICAgIC8vIHN1Ym1lc3NhZ2U6IGRlY29yYXRlIHRoZSBzdWJtZXNzYWdlIGFuZCB1c2UgaXRzIG5hbWUgYXMgdGhlIHR5cGVcclxuICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZVR5cGUoZmllbGRUeXBlKS5uYW1lO1xyXG5cclxuICAgIC8vIGVudW0gcmVmZXJlbmNlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxyXG4gICAgZWxzZSBpZiAoZmllbGRUeXBlICYmIHR5cGVvZiBmaWVsZFR5cGUgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZUVudW0oZmllbGRUeXBlKS5uYW1lO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBmaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xyXG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcclxuICAgICAgICAgICAgLmFkZChuZXcgRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZFR5cGUsIGZpZWxkUnVsZSwgeyBcImRlZmF1bHRcIjogZGVmYXVsdFZhbHVlIH0pKTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cclxuICogQG5hbWUgRmllbGQuZFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPnxzdHJpbmd9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXHJcbiAqIEBwYXJhbSB7XCJvcHRpb25hbFwifFwicmVxdWlyZWRcInxcInJlcGVhdGVkXCJ9IFtmaWVsZFJ1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXHJcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxyXG4gKiBAdmFyaWF0aW9uIDJcclxuICovXHJcbi8vIGxpa2UgRmllbGQuZCBidXQgd2l0aG91dCBhIGRlZmF1bHQgdmFsdWVcclxuXHJcbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxyXG5GaWVsZC5fY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlKFR5cGVfKSB7XHJcbiAgICBUeXBlID0gVHlwZV87XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nvar protobuf = module.exports = __webpack_require__(/*! ./index-minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js\");\r\n\r\nprotobuf.build = \"light\";\r\n\r\n/**\r\n * A node-style callback as used by {@link load} and {@link Root#load}.\r\n * @typedef LoadCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Root} [root] Root, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\r\n * @param {LoadCallback} callback Callback function\r\n * @returns {undefined}\r\n * @see {@link Root#load}\r\n */\r\nfunction load(filename, root, callback) {\r\n    if (typeof root === \"function\") {\r\n        callback = root;\r\n        root = new protobuf.Root();\r\n    } else if (!root)\r\n        root = new protobuf.Root();\r\n    return root.load(filename, callback);\r\n}\r\n\r\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\r\n * @name load\r\n * @function\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {LoadCallback} callback Callback function\r\n * @returns {undefined}\r\n * @see {@link Root#load}\r\n * @variation 2\r\n */\r\n// function load(filename:string, callback:LoadCallback):undefined\r\n\r\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\r\n * @name load\r\n * @function\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\r\n * @returns {Promise<Root>} Promise\r\n * @see {@link Root#load}\r\n * @variation 3\r\n */\r\n// function load(filename:string, [root:Root]):Promise<Root>\r\n\r\nprotobuf.load = load;\r\n\r\n/**\r\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\r\n * @returns {Root} Root namespace\r\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\r\n * @see {@link Root#loadSync}\r\n */\r\nfunction loadSync(filename, root) {\r\n    if (!root)\r\n        root = new protobuf.Root();\r\n    return root.loadSync(filename);\r\n}\r\n\r\nprotobuf.loadSync = loadSync;\r\n\r\n// Serialization\r\nprotobuf.encoder          = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js\");\r\nprotobuf.decoder          = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js\");\r\nprotobuf.verifier         = __webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js\");\r\nprotobuf.converter        = __webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js\");\r\n\r\n// Reflection\r\nprotobuf.ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\r\nprotobuf.Namespace        = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\r\nprotobuf.Root             = __webpack_require__(/*! ./root */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\");\r\nprotobuf.Enum             = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\");\r\nprotobuf.Type             = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\");\r\nprotobuf.Field            = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\");\r\nprotobuf.OneOf            = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\");\r\nprotobuf.MapField         = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\");\r\nprotobuf.Service          = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\");\r\nprotobuf.Method           = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\");\r\n\r\n// Runtime\r\nprotobuf.Message          = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\");\r\nprotobuf.wrappers         = __webpack_require__(/*! ./wrappers */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js\");\r\n\r\n// Utility\r\nprotobuf.types            = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\");\r\nprotobuf.util             = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n// Set up possibly cyclic reflection dependencies\r\nprotobuf.ReflectionObject._configure(protobuf.Root);\r\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\r\nprotobuf.Root._configure(protobuf.Type);\r\nprotobuf.Field._configure(protobuf.Type);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLDhJQUEyQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLEtBQUssZ0JBQWdCO0FBQ3RFO0FBQ0EsVUFBVTtBQUNWLFdBQVcsWUFBWTtBQUN2QixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsY0FBYztBQUN6QixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsY0FBYztBQUN6QixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakIsYUFBYSxlQUFlO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQixZQUFZLE9BQU87QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFPLENBQUMsNEZBQVc7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMsNEZBQVc7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMsOEZBQVk7QUFDaEQsNEJBQTRCLG1CQUFPLENBQUMsZ0dBQWE7QUFDakQ7QUFDQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLDBGQUFVO0FBQzlDLDRCQUE0QixtQkFBTyxDQUFDLGdHQUFhO0FBQ2pELDRCQUE0QixtQkFBTyxDQUFDLHNGQUFRO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLHNGQUFRO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLHNGQUFRO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLHdGQUFTO0FBQzdDLDRCQUE0QixtQkFBTyxDQUFDLHdGQUFTO0FBQzdDLDRCQUE0QixtQkFBTyxDQUFDLDhGQUFZO0FBQ2hELDRCQUE0QixtQkFBTyxDQUFDLDRGQUFXO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLDBGQUFVO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyw0RkFBVztBQUMvQyw0QkFBNEIsbUJBQU8sQ0FBQyw4RkFBWTtBQUNoRDtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFPLENBQUMsd0ZBQVM7QUFDN0MsNEJBQTRCLG1CQUFPLENBQUMsc0ZBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LWxpZ2h0LmpzPzhhMGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbWluaW1hbFwiKTtcclxuXHJcbnByb3RvYnVmLmJ1aWxkID0gXCJsaWdodFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBsb2FkfSBhbmQge0BsaW5rIFJvb3QjbG9hZH0uXHJcbiAqIEB0eXBlZGVmIExvYWRDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290LCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxyXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cclxuICovXHJcbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIHJvb3QsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodHlwZW9mIHJvb3QgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGNhbGxiYWNrID0gcm9vdDtcclxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcclxuICAgIH0gZWxzZSBpZiAoIXJvb3QpXHJcbiAgICAgICAgcm9vdCA9IG5ldyBwcm90b2J1Zi5Sb290KCk7XHJcbiAgICByZXR1cm4gcm9vdC5sb2FkKGZpbGVuYW1lLCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXHJcbiAqIEBuYW1lIGxvYWRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxyXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxyXG4gKiBAdmFyaWF0aW9uIDJcclxuICovXHJcbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxyXG5cclxuLyoqXHJcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxyXG4gKiBAbmFtZSBsb2FkXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcclxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxyXG4gKiBAdmFyaWF0aW9uIDNcclxuICovXHJcbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbcm9vdDpSb290XSk6UHJvbWlzZTxSb290PlxyXG5cclxucHJvdG9idWYubG9hZCA9IGxvYWQ7XHJcblxyXG4vKipcclxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxyXG4gKiBAc2VlIHtAbGluayBSb290I2xvYWRTeW5jfVxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIHJvb3QpIHtcclxuICAgIGlmICghcm9vdClcclxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcclxuICAgIHJldHVybiByb290LmxvYWRTeW5jKGZpbGVuYW1lKTtcclxufVxyXG5cclxucHJvdG9idWYubG9hZFN5bmMgPSBsb2FkU3luYztcclxuXHJcbi8vIFNlcmlhbGl6YXRpb25cclxucHJvdG9idWYuZW5jb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIik7XHJcbnByb3RvYnVmLmRlY29kZXIgICAgICAgICAgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpO1xyXG5wcm90b2J1Zi52ZXJpZmllciAgICAgICAgID0gcmVxdWlyZShcIi4vdmVyaWZpZXJcIik7XHJcbnByb3RvYnVmLmNvbnZlcnRlciAgICAgICAgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIik7XHJcblxyXG4vLyBSZWZsZWN0aW9uXHJcbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XHJcbnByb3RvYnVmLk5hbWVzcGFjZSAgICAgICAgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XHJcbnByb3RvYnVmLlJvb3QgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpO1xyXG5wcm90b2J1Zi5FbnVtICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKTtcclxucHJvdG9idWYuVHlwZSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XHJcbnByb3RvYnVmLkZpZWxkICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcclxucHJvdG9idWYuT25lT2YgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xyXG5wcm90b2J1Zi5NYXBGaWVsZCAgICAgICAgID0gcmVxdWlyZShcIi4vbWFwZmllbGRcIik7XHJcbnByb3RvYnVmLlNlcnZpY2UgICAgICAgICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xyXG5wcm90b2J1Zi5NZXRob2QgICAgICAgICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpO1xyXG5cclxuLy8gUnVudGltZVxyXG5wcm90b2J1Zi5NZXNzYWdlICAgICAgICAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcclxucHJvdG9idWYud3JhcHBlcnMgICAgICAgICA9IHJlcXVpcmUoXCIuL3dyYXBwZXJzXCIpO1xyXG5cclxuLy8gVXRpbGl0eVxyXG5wcm90b2J1Zi50eXBlcyAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XHJcbnByb3RvYnVmLnV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG5cclxuLy8gU2V0IHVwIHBvc3NpYmx5IGN5Y2xpYyByZWZsZWN0aW9uIGRlcGVuZGVuY2llc1xyXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUocHJvdG9idWYuUm9vdCk7XHJcbnByb3RvYnVmLk5hbWVzcGFjZS5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLlNlcnZpY2UsIHByb3RvYnVmLkVudW0pO1xyXG5wcm90b2J1Zi5Sb290Ll9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XHJcbnByb3RvYnVmLkZpZWxkLl9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nvar protobuf = exports;\r\n\r\n/**\r\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\r\n * @name build\r\n * @type {string}\r\n * @const\r\n */\r\nprotobuf.build = \"minimal\";\r\n\r\n// Serialization\r\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\");\r\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js\");\r\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\");\r\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js\");\r\n\r\n// Utility\r\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js\");\r\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js\");\r\nprotobuf.configure    = configure;\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Reconfigures the library according to the environment.\r\n * @returns {undefined}\r\n */\r\nfunction configure() {\r\n    protobuf.util._configure();\r\n    protobuf.Writer._configure(protobuf.BufferWriter);\r\n    protobuf.Reader._configure(protobuf.BufferReader);\r\n}\r\n\r\n// Set up buffer utility according to the environment\r\nconfigure();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBGQUFVO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLHdHQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQywwRkFBVTtBQUMxQyx3QkFBd0IsbUJBQU8sQ0FBQyx3R0FBaUI7QUFDakQ7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLHNHQUFnQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBTztBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyx3RkFBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzPzM1YTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXHJcbiAqIEBuYW1lIGJ1aWxkXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcclxuXHJcbi8vIFNlcmlhbGl6YXRpb25cclxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xyXG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xyXG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XHJcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XHJcblxyXG4vLyBVdGlsaXR5XHJcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xyXG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcclxucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlndXJlKCkge1xyXG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XHJcbiAgICBwcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xyXG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcclxufVxyXG5cclxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcclxuY29uZmlndXJlKCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nvar protobuf = module.exports = __webpack_require__(/*! ./index-light */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js\");\r\n\r\nprotobuf.build = \"full\";\r\n\r\n// Parser\r\nprotobuf.tokenize         = __webpack_require__(/*! ./tokenize */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js\");\r\nprotobuf.parse            = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js\");\r\nprotobuf.common           = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js\");\r\n\r\n// Configure parser\r\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLDBJQUF5QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLDhGQUFZO0FBQ2hELDRCQUE0QixtQkFBTyxDQUFDLHdGQUFTO0FBQzdDLDRCQUE0QixtQkFBTyxDQUFDLDBGQUFVO0FBQzlDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC5qcz82YjE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgcHJvdG9idWYgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luZGV4LWxpZ2h0XCIpO1xyXG5cclxucHJvdG9idWYuYnVpbGQgPSBcImZ1bGxcIjtcclxuXHJcbi8vIFBhcnNlclxyXG5wcm90b2J1Zi50b2tlbml6ZSAgICAgICAgID0gcmVxdWlyZShcIi4vdG9rZW5pemVcIik7XHJcbnByb3RvYnVmLnBhcnNlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcclxucHJvdG9idWYuY29tbW9uICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcclxuXHJcbi8vIENvbmZpZ3VyZSBwYXJzZXJcclxucHJvdG9idWYuUm9vdC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLnBhcnNlLCBwcm90b2J1Zi5jb21tb24pO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = MapField;\r\n\r\n// extends Field\r\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\");\r\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\r\n\r\nvar types   = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"),\r\n    util    = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n/**\r\n * Constructs a new map field instance.\r\n * @classdesc Reflected map field.\r\n * @extends FieldBase\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {number} id Unique id within its namespace\r\n * @param {string} keyType Key type\r\n * @param {string} type Value type\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] Comment associated with this field\r\n */\r\nfunction MapField(name, id, keyType, type, options, comment) {\r\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\r\n\r\n    /* istanbul ignore if */\r\n    if (!util.isString(keyType))\r\n        throw TypeError(\"keyType must be a string\");\r\n\r\n    /**\r\n     * Key type.\r\n     * @type {string}\r\n     */\r\n    this.keyType = keyType; // toJSON, marker\r\n\r\n    /**\r\n     * Resolved key type if not a basic type.\r\n     * @type {ReflectionObject|null}\r\n     */\r\n    this.resolvedKeyType = null;\r\n\r\n    // Overrides Field#map\r\n    this.map = true;\r\n}\r\n\r\n/**\r\n * Map field descriptor.\r\n * @interface IMapField\r\n * @extends {IField}\r\n * @property {string} keyType Key type\r\n */\r\n\r\n/**\r\n * Extension map field descriptor.\r\n * @interface IExtensionMapField\r\n * @extends IMapField\r\n * @property {string} extend Extended type\r\n */\r\n\r\n/**\r\n * Constructs a map field from a map field descriptor.\r\n * @param {string} name Field name\r\n * @param {IMapField} json Map field descriptor\r\n * @returns {MapField} Created map field\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nMapField.fromJSON = function fromJSON(name, json) {\r\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\r\n};\r\n\r\n/**\r\n * Converts this map field to a map field descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMapField} Map field descriptor\r\n */\r\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"keyType\" , this.keyType,\r\n        \"type\"    , this.type,\r\n        \"id\"      , this.id,\r\n        \"extend\"  , this.extend,\r\n        \"options\" , this.options,\r\n        \"comment\" , keepComments ? this.comment : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nMapField.prototype.resolve = function resolve() {\r\n    if (this.resolved)\r\n        return this;\r\n\r\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\r\n    if (types.mapKey[this.keyType] === undefined)\r\n        throw Error(\"invalid key type: \" + this.keyType);\r\n\r\n    return Field.prototype.resolve.call(this);\r\n};\r\n\r\n/**\r\n * Map field decorator (TypeScript).\r\n * @name MapField.d\r\n * @function\r\n * @param {number} fieldId Field id\r\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\r\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\r\n * @returns {FieldDecorator} Decorator function\r\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\r\n */\r\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\r\n\r\n    // submessage value: decorate the submessage and use its name as the type\r\n    if (typeof fieldValueType === \"function\")\r\n        fieldValueType = util.decorateType(fieldValueType).name;\r\n\r\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\r\n    else if (fieldValueType && typeof fieldValueType === \"object\")\r\n        fieldValueType = util.decorateEnum(fieldValueType).name;\r\n\r\n    return function mapFieldDecorator(prototype, fieldName) {\r\n        util.decorateType(prototype.constructor)\r\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\r\n    };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWFwZmllbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsd0ZBQVM7QUFDN0I7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx3RkFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsc0ZBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLCtHQUErRztBQUMxSCxXQUFXLDRKQUE0SixHQUFHO0FBQzFLLGFBQWEsZ0JBQWdCO0FBQzdCLHlCQUF5Qiw2RkFBNkY7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWFwZmllbGQuanM/YTMxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBNYXBGaWVsZDtcclxuXHJcbi8vIGV4dGVuZHMgRmllbGRcclxudmFyIEZpZWxkID0gcmVxdWlyZShcIi4vZmllbGRcIik7XHJcbigoTWFwRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE1hcEZpZWxkKS5jbGFzc05hbWUgPSBcIk1hcEZpZWxkXCI7XHJcblxyXG52YXIgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxyXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBtYXAgZmllbGQgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG1hcCBmaWVsZC5cclxuICogQGV4dGVuZHMgRmllbGRCYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFZhbHVlIHR5cGVcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcclxuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXHJcbiAqL1xyXG5mdW5jdGlvbiBNYXBGaWVsZChuYW1lLCBpZCwga2V5VHlwZSwgdHlwZSwgb3B0aW9ucywgY29tbWVudCkge1xyXG4gICAgRmllbGQuY2FsbCh0aGlzLCBuYW1lLCBpZCwgdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMsIGNvbW1lbnQpO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKGtleVR5cGUpKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImtleVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtleSB0eXBlLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5rZXlUeXBlID0ga2V5VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVkIGtleSB0eXBlIGlmIG5vdCBhIGJhc2ljIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc29sdmVkS2V5VHlwZSA9IG51bGw7XHJcblxyXG4gICAgLy8gT3ZlcnJpZGVzIEZpZWxkI21hcFxyXG4gICAgdGhpcy5tYXAgPSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogTWFwIGZpZWxkIGRlc2NyaXB0b3IuXHJcbiAqIEBpbnRlcmZhY2UgSU1hcEZpZWxkXHJcbiAqIEBleHRlbmRzIHtJRmllbGR9XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBtYXAgZmllbGQgZGVzY3JpcHRvci5cclxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uTWFwRmllbGRcclxuICogQGV4dGVuZHMgSU1hcEZpZWxkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbWFwIGZpZWxkIGZyb20gYSBtYXAgZmllbGQgZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gKiBAcGFyYW0ge0lNYXBGaWVsZH0ganNvbiBNYXAgZmllbGQgZGVzY3JpcHRvclxyXG4gKiBAcmV0dXJucyB7TWFwRmllbGR9IENyZWF0ZWQgbWFwIGZpZWxkXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXHJcbiAqL1xyXG5NYXBGaWVsZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcclxuICAgIHJldHVybiBuZXcgTWFwRmllbGQobmFtZSwganNvbi5pZCwganNvbi5rZXlUeXBlLCBqc29uLnR5cGUsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIG1hcCBmaWVsZCB0byBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxyXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcclxuICogQHJldHVybnMge0lNYXBGaWVsZH0gTWFwIGZpZWxkIGRlc2NyaXB0b3JcclxuICovXHJcbk1hcEZpZWxkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xyXG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xyXG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xyXG4gICAgICAgIFwia2V5VHlwZVwiICwgdGhpcy5rZXlUeXBlLFxyXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxyXG4gICAgICAgIFwiaWRcIiAgICAgICwgdGhpcy5pZCxcclxuICAgICAgICBcImV4dGVuZFwiICAsIHRoaXMuZXh0ZW5kLFxyXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxyXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXHJcbiAgICBdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbk1hcEZpZWxkLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcclxuICAgIGlmICh0aGlzLnJlc29sdmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIC8vIEJlc2lkZXMgYSB2YWx1ZSB0eXBlLCBtYXAgZmllbGRzIGhhdmUgYSBrZXkgdHlwZSB0aGF0IG1heSBiZSBcImFueSBzY2FsYXIgdHlwZSBleGNlcHQgZm9yIGZsb2F0aW5nIHBvaW50IHR5cGVzIGFuZCBieXRlc1wiXHJcbiAgICBpZiAodHlwZXMubWFwS2V5W3RoaXMua2V5VHlwZV0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQga2V5IHR5cGU6IFwiICsgdGhpcy5rZXlUeXBlKTtcclxuXHJcbiAgICByZXR1cm4gRmllbGQucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXAgZmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cclxuICogQG5hbWUgTWFwRmllbGQuZFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcclxuICogQHBhcmFtIHtcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifSBmaWVsZEtleVR5cGUgRmllbGQga2V5IHR5cGVcclxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifFwiYnl0ZXNcInxPYmplY3R8Q29uc3RydWN0b3I8e30+fSBmaWVsZFZhbHVlVHlwZSBGaWVsZCB2YWx1ZSB0eXBlXHJcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBMb25nIHwgc3RyaW5nIHwgYm9vbGVhbiB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudW1iZXJbXSB8IE1lc3NhZ2U8e30+IH1cclxuICovXHJcbk1hcEZpZWxkLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU1hcEZpZWxkKGZpZWxkSWQsIGZpZWxkS2V5VHlwZSwgZmllbGRWYWx1ZVR5cGUpIHtcclxuXHJcbiAgICAvLyBzdWJtZXNzYWdlIHZhbHVlOiBkZWNvcmF0ZSB0aGUgc3VibWVzc2FnZSBhbmQgdXNlIGl0cyBuYW1lIGFzIHRoZSB0eXBlXHJcbiAgICBpZiAodHlwZW9mIGZpZWxkVmFsdWVUeXBlID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFZhbHVlVHlwZSkubmFtZTtcclxuXHJcbiAgICAvLyBlbnVtIHJlZmVyZW5jZSB2YWx1ZTogY3JlYXRlIGEgcmVmbGVjdGVkIGNvcHkgb2YgdGhlIGVudW0gYW5kIGtlZXAgcmV1c2VpbmcgaXRcclxuICAgIGVsc2UgaWYgKGZpZWxkVmFsdWVUeXBlICYmIHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVFbnVtKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBtYXBGaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xyXG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcclxuICAgICAgICAgICAgLmFkZChuZXcgTWFwRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZEtleVR5cGUsIGZpZWxkVmFsdWVUeXBlKSk7XHJcbiAgICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Message;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs a new message instance.\r\n * @classdesc Abstract runtime message.\r\n * @constructor\r\n * @param {Properties<T>} [properties] Properties to set\r\n * @template T extends object = object\r\n */\r\nfunction Message(properties) {\r\n    // not used internally\r\n    if (properties)\r\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\r\n            this[keys[i]] = properties[keys[i]];\r\n}\r\n\r\n/**\r\n * Reference to the reflected type.\r\n * @name Message.$type\r\n * @type {Type}\r\n * @readonly\r\n */\r\n\r\n/**\r\n * Reference to the reflected type.\r\n * @name Message#$type\r\n * @type {Type}\r\n * @readonly\r\n */\r\n\r\n/*eslint-disable valid-jsdoc*/\r\n\r\n/**\r\n * Creates a new message of this type using the specified properties.\r\n * @param {Object.<string,*>} [properties] Properties to set\r\n * @returns {Message<T>} Message instance\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.create = function create(properties) {\r\n    return this.$type.create(properties);\r\n};\r\n\r\n/**\r\n * Encodes a message of this type.\r\n * @param {T|Object.<string,*>} message Message to encode\r\n * @param {Writer} [writer] Writer to use\r\n * @returns {Writer} Writer\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.encode = function encode(message, writer) {\r\n    return this.$type.encode(message, writer);\r\n};\r\n\r\n/**\r\n * Encodes a message of this type preceeded by its length as a varint.\r\n * @param {T|Object.<string,*>} message Message to encode\r\n * @param {Writer} [writer] Writer to use\r\n * @returns {Writer} Writer\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.encodeDelimited = function encodeDelimited(message, writer) {\r\n    return this.$type.encodeDelimited(message, writer);\r\n};\r\n\r\n/**\r\n * Decodes a message of this type.\r\n * @name Message.decode\r\n * @function\r\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\r\n * @returns {T} Decoded message\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.decode = function decode(reader) {\r\n    return this.$type.decode(reader);\r\n};\r\n\r\n/**\r\n * Decodes a message of this type preceeded by its length as a varint.\r\n * @name Message.decodeDelimited\r\n * @function\r\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\r\n * @returns {T} Decoded message\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.decodeDelimited = function decodeDelimited(reader) {\r\n    return this.$type.decodeDelimited(reader);\r\n};\r\n\r\n/**\r\n * Verifies a message of this type.\r\n * @name Message.verify\r\n * @function\r\n * @param {Object.<string,*>} message Plain object to verify\r\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\r\n */\r\nMessage.verify = function verify(message) {\r\n    return this.$type.verify(message);\r\n};\r\n\r\n/**\r\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\r\n * @param {Object.<string,*>} object Plain object\r\n * @returns {T} Message instance\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.fromObject = function fromObject(object) {\r\n    return this.$type.fromObject(object);\r\n};\r\n\r\n/**\r\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\r\n * @param {T} message Message instance\r\n * @param {IConversionOptions} [options] Conversion options\r\n * @returns {Object.<string,*>} Plain object\r\n * @template T extends Message<T>\r\n * @this Constructor<T>\r\n */\r\nMessage.toObject = function toObject(message, options) {\r\n    return this.$type.toObject(message, options);\r\n};\r\n\r\n/**\r\n * Converts this message to JSON.\r\n * @returns {Object.<string,*>} JSON object\r\n */\r\nMessage.prototype.toJSON = function toJSON() {\r\n    return this.$type.toObject(this, util.toJSONOptions);\r\n};\r\n\r\n/*eslint-enable valid-jsdoc*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsc0dBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21lc3NhZ2UuanM/ODU1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBtZXNzYWdlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEFic3RyYWN0IHJ1bnRpbWUgbWVzc2FnZS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7UHJvcGVydGllczxUPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBNZXNzYWdlKHByb3BlcnRpZXMpIHtcclxuICAgIC8vIG5vdCB1c2VkIGludGVybmFsbHlcclxuICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXHJcbiAqIEBuYW1lIE1lc3NhZ2UuJHR5cGVcclxuICogQHR5cGUge1R5cGV9XHJcbiAqIEByZWFkb25seVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWZlcmVuY2UgdG8gdGhlIHJlZmxlY3RlZCB0eXBlLlxyXG4gKiBAbmFtZSBNZXNzYWdlIyR0eXBlXHJcbiAqIEB0eXBlIHtUeXBlfVxyXG4gKiBAcmVhZG9ubHlcclxuICovXHJcblxyXG4vKmVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jKi9cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAqIEByZXR1cm5zIHtNZXNzYWdlPFQ+fSBNZXNzYWdlIGluc3RhbmNlXHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxyXG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxyXG4gKi9cclxuTWVzc2FnZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xyXG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuY3JlYXRlKHByb3BlcnRpZXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cclxuICogQHBhcmFtIHtUfE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgdG8gZW5jb2RlXHJcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gdXNlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cclxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cclxuICovXHJcbk1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge1R8T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSB0byBlbmNvZGVcclxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcclxuICogQHJldHVybnMge1dyaXRlcn0gV3JpdGVyXHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxyXG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxyXG4gKi9cclxuTWVzc2FnZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXHJcbiAqIEBuYW1lIE1lc3NhZ2UuZGVjb2RlXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcclxuICogQHJldHVybnMge1R9IERlY29kZWQgbWVzc2FnZVxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cclxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cclxuICovXHJcbk1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlKHJlYWRlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZURlbGltaXRlZFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlXHJcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XHJcbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XHJcbiAqL1xyXG5NZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgIHJldHVybiB0aGlzLiR0eXBlLmRlY29kZURlbGltaXRlZChyZWFkZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXHJcbiAqIEBuYW1lIE1lc3NhZ2UudmVyaWZ5XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcclxuICovXHJcbk1lc3NhZ2UudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiB0aGlzLiR0eXBlLnZlcmlmeShtZXNzYWdlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICogQHJldHVybnMge1R9IE1lc3NhZ2UgaW5zdGFuY2VcclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XHJcbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XHJcbiAqL1xyXG5NZXNzYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xyXG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZnJvbU9iamVjdChvYmplY3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7VH0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxyXG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxyXG4gKi9cclxuTWVzc2FnZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0byBKU09OLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XHJcbiAqL1xyXG5NZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kdHlwZS50b09iamVjdCh0aGlzLCB1dGlsLnRvSlNPTk9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyplc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jKi8iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Method;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\r\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\r\n\r\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n/**\r\n * Constructs a new service method instance.\r\n * @classdesc Reflected service method.\r\n * @extends ReflectionObject\r\n * @constructor\r\n * @param {string} name Method name\r\n * @param {string|undefined} type Method type, usually `\"rpc\"`\r\n * @param {string} requestType Request message type\r\n * @param {string} responseType Response message type\r\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\r\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] The comment for this method\r\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\r\n */\r\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\r\n\r\n    /* istanbul ignore next */\r\n    if (util.isObject(requestStream)) {\r\n        options = requestStream;\r\n        requestStream = responseStream = undefined;\r\n    } else if (util.isObject(responseStream)) {\r\n        options = responseStream;\r\n        responseStream = undefined;\r\n    }\r\n\r\n    /* istanbul ignore if */\r\n    if (!(type === undefined || util.isString(type)))\r\n        throw TypeError(\"type must be a string\");\r\n\r\n    /* istanbul ignore if */\r\n    if (!util.isString(requestType))\r\n        throw TypeError(\"requestType must be a string\");\r\n\r\n    /* istanbul ignore if */\r\n    if (!util.isString(responseType))\r\n        throw TypeError(\"responseType must be a string\");\r\n\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    /**\r\n     * Method type.\r\n     * @type {string}\r\n     */\r\n    this.type = type || \"rpc\"; // toJSON\r\n\r\n    /**\r\n     * Request type.\r\n     * @type {string}\r\n     */\r\n    this.requestType = requestType; // toJSON, marker\r\n\r\n    /**\r\n     * Whether requests are streamed or not.\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.requestStream = requestStream ? true : undefined; // toJSON\r\n\r\n    /**\r\n     * Response type.\r\n     * @type {string}\r\n     */\r\n    this.responseType = responseType; // toJSON\r\n\r\n    /**\r\n     * Whether responses are streamed or not.\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.responseStream = responseStream ? true : undefined; // toJSON\r\n\r\n    /**\r\n     * Resolved request type.\r\n     * @type {Type|null}\r\n     */\r\n    this.resolvedRequestType = null;\r\n\r\n    /**\r\n     * Resolved response type.\r\n     * @type {Type|null}\r\n     */\r\n    this.resolvedResponseType = null;\r\n\r\n    /**\r\n     * Comment for this method\r\n     * @type {string|null}\r\n     */\r\n    this.comment = comment;\r\n\r\n    /**\r\n     * Options properly parsed into an object\r\n     */\r\n    this.parsedOptions = parsedOptions;\r\n}\r\n\r\n/**\r\n * Method descriptor.\r\n * @interface IMethod\r\n * @property {string} [type=\"rpc\"] Method type\r\n * @property {string} requestType Request type\r\n * @property {string} responseType Response type\r\n * @property {boolean} [requestStream=false] Whether requests are streamed\r\n * @property {boolean} [responseStream=false] Whether responses are streamed\r\n * @property {Object.<string,*>} [options] Method options\r\n * @property {string} comment Method comments\r\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\r\n */\r\n\r\n/**\r\n * Constructs a method from a method descriptor.\r\n * @param {string} name Method name\r\n * @param {IMethod} json Method descriptor\r\n * @returns {Method} Created method\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nMethod.fromJSON = function fromJSON(name, json) {\r\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\r\n};\r\n\r\n/**\r\n * Converts this method to a method descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMethod} Method descriptor\r\n */\r\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\r\n        \"requestType\"    , this.requestType,\r\n        \"requestStream\"  , this.requestStream,\r\n        \"responseType\"   , this.responseType,\r\n        \"responseStream\" , this.responseStream,\r\n        \"options\"        , this.options,\r\n        \"comment\"        , keepComments ? this.comment : undefined,\r\n        \"parsedOptions\"  , this.parsedOptions,\r\n    ]);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nMethod.prototype.resolve = function resolve() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.resolved)\r\n        return this;\r\n\r\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\r\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\r\n\r\n    return ReflectionObject.prototype.resolve.call(this);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWV0aG9kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMEZBQVU7QUFDekM7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxzRkFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsbUJBQW1CO0FBQ2pDLGNBQWMsUUFBUTtBQUN0QixjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21ldGhvZC5qcz83OTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcclxuXHJcbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxyXG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcclxuKChNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWV0aG9kKS5jbGFzc05hbWUgPSBcIk1ldGhvZFwiO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgc2VydmljZSBtZXRob2QgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UgbWV0aG9kLlxyXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHR5cGUgTWV0aG9kIHR5cGUsIHVzdWFsbHkgYFwicnBjXCJgXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VHlwZSBSZXF1ZXN0IG1lc3NhZ2UgdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIG1lc3NhZ2UgdHlwZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0LjxzdHJpbmcsKj59IFtyZXF1ZXN0U3RyZWFtXSBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3QuPHN0cmluZywqPn0gW3Jlc3BvbnNlU3RyZWFtXSBXaGV0aGVyIHRoZSByZXNwb25zZSBpcyBzdHJlYW1lZFxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIFRoZSBjb21tZW50IGZvciB0aGlzIG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcGFyc2VkT3B0aW9uc10gRGVjbGFyZWQgb3B0aW9ucywgcHJvcGVybHkgcGFyc2VkIGludG8gYW4gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBNZXRob2QobmFtZSwgdHlwZSwgcmVxdWVzdFR5cGUsIHJlc3BvbnNlVHlwZSwgcmVxdWVzdFN0cmVhbSwgcmVzcG9uc2VTdHJlYW0sIG9wdGlvbnMsIGNvbW1lbnQsIHBhcnNlZE9wdGlvbnMpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocmVxdWVzdFN0cmVhbSkpIHtcclxuICAgICAgICBvcHRpb25zID0gcmVxdWVzdFN0cmVhbTtcclxuICAgICAgICByZXF1ZXN0U3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QocmVzcG9uc2VTdHJlYW0pKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHJlc3BvbnNlU3RyZWFtO1xyXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCEodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHV0aWwuaXNTdHJpbmcodHlwZSkpKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXF1ZXN0VHlwZSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdFR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXNwb25zZVR5cGUpKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlc3BvbnNlVHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xyXG5cclxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ldGhvZCB0eXBlLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gdHlwZSB8fCBcInJwY1wiOyAvLyB0b0pTT05cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgdHlwZS5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdFR5cGUgPSByZXF1ZXN0VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXF1ZXN0U3RyZWFtID0gcmVxdWVzdFN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzcG9uc2UgdHlwZS5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlOyAvLyB0b0pTT05cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA/IHRydWUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZWQgcmVxdWVzdCB0eXBlLlxyXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIHR5cGUuXHJcbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb25zIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBwYXJzZWRPcHRpb25zO1xyXG59XHJcblxyXG4vKipcclxuICogTWV0aG9kIGRlc2NyaXB0b3IuXHJcbiAqIEBpbnRlcmZhY2UgSU1ldGhvZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGU9XCJycGNcIl0gTWV0aG9kIHR5cGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3RUeXBlIFJlcXVlc3QgdHlwZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIHR5cGVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWVzdFN0cmVhbT1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzcG9uc2VTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gTWV0aG9kIG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbW1lbnQgTWV0aG9kIGNvbW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwYXJzZWRPcHRpb25zXSBNZXRob2Qgb3B0aW9ucyBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcclxuICovXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG1ldGhvZCBmcm9tIGEgbWV0aG9kIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXHJcbiAqIEBwYXJhbSB7SU1ldGhvZH0ganNvbiBNZXRob2QgZGVzY3JpcHRvclxyXG4gKiBAcmV0dXJucyB7TWV0aG9kfSBDcmVhdGVkIG1ldGhvZFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gKi9cclxuTWV0aG9kLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xyXG4gICAgcmV0dXJuIG5ldyBNZXRob2QobmFtZSwganNvbi50eXBlLCBqc29uLnJlcXVlc3RUeXBlLCBqc29uLnJlc3BvbnNlVHlwZSwganNvbi5yZXF1ZXN0U3RyZWFtLCBqc29uLnJlc3BvbnNlU3RyZWFtLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCwganNvbi5wYXJzZWRPcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIG1ldGhvZCB0byBhIG1ldGhvZCBkZXNjcmlwdG9yLlxyXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcclxuICogQHJldHVybnMge0lNZXRob2R9IE1ldGhvZCBkZXNjcmlwdG9yXHJcbiAqL1xyXG5NZXRob2QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XHJcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XHJcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXHJcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgICwgdGhpcy50eXBlICE9PSBcInJwY1wiICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRoaXMudHlwZSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJyZXF1ZXN0VHlwZVwiICAgICwgdGhpcy5yZXF1ZXN0VHlwZSxcclxuICAgICAgICBcInJlcXVlc3RTdHJlYW1cIiAgLCB0aGlzLnJlcXVlc3RTdHJlYW0sXHJcbiAgICAgICAgXCJyZXNwb25zZVR5cGVcIiAgICwgdGhpcy5yZXNwb25zZVR5cGUsXHJcbiAgICAgICAgXCJyZXNwb25zZVN0cmVhbVwiICwgdGhpcy5yZXNwb25zZVN0cmVhbSxcclxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAgLCB0aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgXCJjb21tZW50XCIgICAgICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkLFxyXG4gICAgICAgIFwicGFyc2VkT3B0aW9uc1wiICAsIHRoaXMucGFyc2VkT3B0aW9ucyxcclxuICAgIF0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuTWV0aG9kLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnJlc29sdmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXF1ZXN0VHlwZSk7XHJcbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gdGhpcy5wYXJlbnQubG9va3VwVHlwZSh0aGlzLnJlc3BvbnNlVHlwZSk7XHJcblxyXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Namespace;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\r\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\r\n\r\nvar Field    = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"),\r\n    util     = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\"),\r\n    OneOf    = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\");\r\n\r\nvar Type,    // cyclic\r\n    Service,\r\n    Enum;\r\n\r\n/**\r\n * Constructs a new namespace instance.\r\n * @name Namespace\r\n * @classdesc Reflected namespace.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\r\n\r\n/**\r\n * Constructs a namespace from JSON.\r\n * @memberof Namespace\r\n * @function\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} json JSON object\r\n * @returns {Namespace} Created namespace\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nNamespace.fromJSON = function fromJSON(name, json) {\r\n    return new Namespace(name, json.options).addJSON(json.nested);\r\n};\r\n\r\n/**\r\n * Converts an array of reflection objects to JSON.\r\n * @memberof Namespace\r\n * @param {ReflectionObject[]} array Object array\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\r\n */\r\nfunction arrayToJSON(array, toJSONOptions) {\r\n    if (!(array && array.length))\r\n        return undefined;\r\n    var obj = {};\r\n    for (var i = 0; i < array.length; ++i)\r\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\r\n    return obj;\r\n}\r\n\r\nNamespace.arrayToJSON = arrayToJSON;\r\n\r\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nNamespace.isReservedId = function isReservedId(reserved, id) {\r\n    if (reserved)\r\n        for (var i = 0; i < reserved.length; ++i)\r\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\r\n                return true;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nNamespace.isReservedName = function isReservedName(reserved, name) {\r\n    if (reserved)\r\n        for (var i = 0; i < reserved.length; ++i)\r\n            if (reserved[i] === name)\r\n                return true;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Not an actual constructor. Use {@link Namespace} instead.\r\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\r\n * @exports NamespaceBase\r\n * @extends ReflectionObject\r\n * @abstract\r\n * @constructor\r\n * @param {string} name Namespace name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @see {@link Namespace}\r\n */\r\nfunction Namespace(name, options) {\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    /**\r\n     * Nested objects by name.\r\n     * @type {Object.<string,ReflectionObject>|undefined}\r\n     */\r\n    this.nested = undefined; // toJSON\r\n\r\n    /**\r\n     * Cached nested objects as an array.\r\n     * @type {ReflectionObject[]|null}\r\n     * @private\r\n     */\r\n    this._nestedArray = null;\r\n}\r\n\r\nfunction clearCache(namespace) {\r\n    namespace._nestedArray = null;\r\n    return namespace;\r\n}\r\n\r\n/**\r\n * Nested objects of this namespace as an array for iteration.\r\n * @name NamespaceBase#nestedArray\r\n * @type {ReflectionObject[]}\r\n * @readonly\r\n */\r\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\r\n    get: function() {\r\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\r\n    }\r\n});\r\n\r\n/**\r\n * Namespace descriptor.\r\n * @interface INamespace\r\n * @property {Object.<string,*>} [options] Namespace options\r\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\r\n */\r\n\r\n/**\r\n * Any extension field descriptor.\r\n * @typedef AnyExtensionField\r\n * @type {IExtensionField|IExtensionMapField}\r\n */\r\n\r\n/**\r\n * Any nested object descriptor.\r\n * @typedef AnyNestedObject\r\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\r\n */\r\n\r\n/**\r\n * Converts this namespace to a namespace descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {INamespace} Namespace descriptor\r\n */\r\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    return util.toObject([\r\n        \"options\" , this.options,\r\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\r\n    ]);\r\n};\r\n\r\n/**\r\n * Adds nested objects to this namespace from nested object descriptors.\r\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\r\n * @returns {Namespace} `this`\r\n */\r\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\r\n    var ns = this;\r\n    /* istanbul ignore else */\r\n    if (nestedJson) {\r\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\r\n            nested = nestedJson[names[i]];\r\n            ns.add( // most to least likely\r\n                ( nested.fields !== undefined\r\n                ? Type.fromJSON\r\n                : nested.values !== undefined\r\n                ? Enum.fromJSON\r\n                : nested.methods !== undefined\r\n                ? Service.fromJSON\r\n                : nested.id !== undefined\r\n                ? Field.fromJSON\r\n                : Namespace.fromJSON )(names[i], nested)\r\n            );\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Gets the nested object of the specified name.\r\n * @param {string} name Nested object name\r\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\r\n */\r\nNamespace.prototype.get = function get(name) {\r\n    return this.nested && this.nested[name]\r\n        || null;\r\n};\r\n\r\n/**\r\n * Gets the values of the nested {@link Enum|enum} of the specified name.\r\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\r\n * @param {string} name Nested enum name\r\n * @returns {Object.<string,number>} Enum values\r\n * @throws {Error} If there is no such enum\r\n */\r\nNamespace.prototype.getEnum = function getEnum(name) {\r\n    if (this.nested && this.nested[name] instanceof Enum)\r\n        return this.nested[name].values;\r\n    throw Error(\"no such enum: \" + name);\r\n};\r\n\r\n/**\r\n * Adds a nested object to this namespace.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name\r\n */\r\nNamespace.prototype.add = function add(object) {\r\n\r\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\r\n        throw TypeError(\"object must be a valid nested object\");\r\n\r\n    if (!this.nested)\r\n        this.nested = {};\r\n    else {\r\n        var prev = this.get(object.name);\r\n        if (prev) {\r\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\r\n                // replace plain namespace but keep existing nested elements and options\r\n                var nested = prev.nestedArray;\r\n                for (var i = 0; i < nested.length; ++i)\r\n                    object.add(nested[i]);\r\n                this.remove(prev);\r\n                if (!this.nested)\r\n                    this.nested = {};\r\n                object.setOptions(prev.options, true);\r\n\r\n            } else\r\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\r\n        }\r\n    }\r\n    this.nested[object.name] = object;\r\n    object.onAdd(this);\r\n    return clearCache(this);\r\n};\r\n\r\n/**\r\n * Removes a nested object from this namespace.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Namespace} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this namespace\r\n */\r\nNamespace.prototype.remove = function remove(object) {\r\n\r\n    if (!(object instanceof ReflectionObject))\r\n        throw TypeError(\"object must be a ReflectionObject\");\r\n    if (object.parent !== this)\r\n        throw Error(object + \" is not a member of \" + this);\r\n\r\n    delete this.nested[object.name];\r\n    if (!Object.keys(this.nested).length)\r\n        this.nested = undefined;\r\n\r\n    object.onRemove(this);\r\n    return clearCache(this);\r\n};\r\n\r\n/**\r\n * Defines additial namespaces within this one if not yet existing.\r\n * @param {string|string[]} path Path to create\r\n * @param {*} [json] Nested types to create from JSON\r\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\r\n */\r\nNamespace.prototype.define = function define(path, json) {\r\n\r\n    if (util.isString(path))\r\n        path = path.split(\".\");\r\n    else if (!Array.isArray(path))\r\n        throw TypeError(\"illegal path\");\r\n    if (path && path.length && path[0] === \"\")\r\n        throw Error(\"path must be relative\");\r\n\r\n    var ptr = this;\r\n    while (path.length > 0) {\r\n        var part = path.shift();\r\n        if (ptr.nested && ptr.nested[part]) {\r\n            ptr = ptr.nested[part];\r\n            if (!(ptr instanceof Namespace))\r\n                throw Error(\"path conflicts with non-namespace objects\");\r\n        } else\r\n            ptr.add(ptr = new Namespace(part));\r\n    }\r\n    if (json)\r\n        ptr.addJSON(json);\r\n    return ptr;\r\n};\r\n\r\n/**\r\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\r\n * @returns {Namespace} `this`\r\n */\r\nNamespace.prototype.resolveAll = function resolveAll() {\r\n    var nested = this.nestedArray, i = 0;\r\n    while (i < nested.length)\r\n        if (nested[i] instanceof Namespace)\r\n            nested[i++].resolveAll();\r\n        else\r\n            nested[i++].resolve();\r\n    return this.resolve();\r\n};\r\n\r\n/**\r\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\r\n * @param {string|string[]} path Path to look up\r\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\r\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n */\r\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\r\n\r\n    /* istanbul ignore next */\r\n    if (typeof filterTypes === \"boolean\") {\r\n        parentAlreadyChecked = filterTypes;\r\n        filterTypes = undefined;\r\n    } else if (filterTypes && !Array.isArray(filterTypes))\r\n        filterTypes = [ filterTypes ];\r\n\r\n    if (util.isString(path) && path.length) {\r\n        if (path === \".\")\r\n            return this.root;\r\n        path = path.split(\".\");\r\n    } else if (!path.length)\r\n        return this;\r\n\r\n    // Start at root if path is absolute\r\n    if (path[0] === \"\")\r\n        return this.root.lookup(path.slice(1), filterTypes);\r\n\r\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\r\n    var found = this.get(path[0]);\r\n    if (found) {\r\n        if (path.length === 1) {\r\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\r\n                return found;\r\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\r\n            return found;\r\n\r\n    // Otherwise try each nested namespace\r\n    } else\r\n        for (var i = 0; i < this.nestedArray.length; ++i)\r\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\r\n                return found;\r\n\r\n    // If there hasn't been a match, try again at the parent\r\n    if (this.parent === null || parentAlreadyChecked)\r\n        return null;\r\n    return this.parent.lookup(path, filterTypes);\r\n};\r\n\r\n/**\r\n * Looks up the reflection object at the specified path, relative to this namespace.\r\n * @name NamespaceBase#lookup\r\n * @function\r\n * @param {string|string[]} path Path to look up\r\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\r\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\r\n * @variation 2\r\n */\r\n// lookup(path: string, [parentAlreadyChecked: boolean])\r\n\r\n/**\r\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type\r\n * @throws {Error} If `path` does not point to a type\r\n */\r\nNamespace.prototype.lookupType = function lookupType(path) {\r\n    var found = this.lookup(path, [ Type ]);\r\n    if (!found)\r\n        throw Error(\"no such type: \" + path);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Enum} Looked up enum\r\n * @throws {Error} If `path` does not point to an enum\r\n */\r\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\r\n    var found = this.lookup(path, [ Enum ]);\r\n    if (!found)\r\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Type} Looked up type or enum\r\n * @throws {Error} If `path` does not point to a type or enum\r\n */\r\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\r\n    var found = this.lookup(path, [ Type, Enum ]);\r\n    if (!found)\r\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n/**\r\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\r\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\r\n * @param {string|string[]} path Path to look up\r\n * @returns {Service} Looked up service\r\n * @throws {Error} If `path` does not point to a service\r\n */\r\nNamespace.prototype.lookupService = function lookupService(path) {\r\n    var found = this.lookup(path, [ Service ]);\r\n    if (!found)\r\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\r\n    return found;\r\n};\r\n\r\n// Sets up cyclic dependencies (called in index-light)\r\nNamespace._configure = function(Type_, Service_, Enum_) {\r\n    Type    = Type_;\r\n    Service = Service_;\r\n    Enum    = Enum_;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMEZBQVU7QUFDekM7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyx3RkFBUztBQUNoQyxlQUFlLG1CQUFPLENBQUMsc0ZBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdGQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsV0FBVztBQUN4QixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsOEJBQThCLHlCQUF5QjtBQUN2RCxXQUFXLFFBQVE7QUFDbkIsYUFBYSx3QkFBd0I7QUFDckMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWEsV0FBVztBQUN4QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWEsV0FBVztBQUN4QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsR0FBRztBQUNkLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEIsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsU0FBUztBQUNwQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQyxxREFBcUQsK0JBQStCO0FBQ3BGLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsTUFBTTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRCxxREFBcUQsK0JBQStCO0FBQ3BGLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsTUFBTTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQixJQUFJLGlCQUFpQjtBQUN2RCxxREFBcUQsK0JBQStCO0FBQ3BGLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsTUFBTTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QyxxREFBcUQsK0JBQStCO0FBQ3BGLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9uYW1lc3BhY2UuanM/MTYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XHJcblxyXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcclxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XHJcbigoTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE5hbWVzcGFjZSkuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcclxuXHJcbnZhciBGaWVsZCAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxyXG4gICAgdXRpbCAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxyXG4gICAgT25lT2YgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcclxuXHJcbnZhciBUeXBlLCAgICAvLyBjeWNsaWNcclxuICAgIFNlcnZpY2UsXHJcbiAgICBFbnVtO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgbmFtZXNwYWNlIGluc3RhbmNlLlxyXG4gKiBAbmFtZSBOYW1lc3BhY2VcclxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbmFtZXNwYWNlLlxyXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmFtZXNwYWNlIGZyb20gSlNPTi5cclxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0ganNvbiBKU09OIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBDcmVhdGVkIG5hbWVzcGFjZVxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gKi9cclxuTmFtZXNwYWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xyXG4gICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UobmFtZSwganNvbi5vcHRpb25zKS5hZGRKU09OKGpzb24ubmVzdGVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiByZWZsZWN0aW9uIG9iamVjdHMgdG8gSlNPTi5cclxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxyXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3RbXX0gYXJyYXkgT2JqZWN0IGFycmF5XHJcbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfSBKU09OIG9iamVjdCBvciBgdW5kZWZpbmVkYCB3aGVuIGFycmF5IGlzIGVtcHR5XHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheVRvSlNPTihhcnJheSwgdG9KU09OT3B0aW9ucykge1xyXG4gICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSlcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcclxuICAgICAgICBvYmpbYXJyYXlbaV0ubmFtZV0gPSBhcnJheVtpXS50b0pTT04odG9KU09OT3B0aW9ucyk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5OYW1lc3BhY2UuYXJyYXlUb0pTT04gPSBhcnJheVRvSlNPTjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxuTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChyZXNlcnZlZCwgaWQpIHtcclxuICAgIGlmIChyZXNlcnZlZClcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc2VydmVkW2ldICE9PSBcInN0cmluZ1wiICYmIHJlc2VydmVkW2ldWzBdIDw9IGlkICYmIHJlc2VydmVkW2ldWzFdID4gaWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz58dW5kZWZpbmVkfSByZXNlcnZlZCBBcnJheSBvZiByZXNlcnZlZCByYW5nZXMgYW5kIG5hbWVzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxuTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUocmVzZXJ2ZWQsIG5hbWUpIHtcclxuICAgIGlmIChyZXNlcnZlZClcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRbaV0gPT09IG5hbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIE5hbWVzcGFjZX0gaW5zdGVhZC5cclxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0aW9uIG9iamVjdHMgY29udGFpbmluZyBuZXN0ZWQgb2JqZWN0cy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxyXG4gKiBAZXhwb3J0cyBOYW1lc3BhY2VCYXNlXHJcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcclxuICogQGFic3RyYWN0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xyXG4gKiBAc2VlIHtAbGluayBOYW1lc3BhY2V9XHJcbiAqL1xyXG5mdW5jdGlvbiBOYW1lc3BhY2UobmFtZSwgb3B0aW9ucykge1xyXG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVzdGVkIG9iamVjdHMgYnkgbmFtZS5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSZWZsZWN0aW9uT2JqZWN0Pnx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBuZXN0ZWQgb2JqZWN0cyBhcyBhbiBhcnJheS5cclxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W118bnVsbH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX25lc3RlZEFycmF5ID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYXJDYWNoZShuYW1lc3BhY2UpIHtcclxuICAgIG5hbWVzcGFjZS5fbmVzdGVkQXJyYXkgPSBudWxsO1xyXG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE5lc3RlZCBvYmplY3RzIG9mIHRoaXMgbmFtZXNwYWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXHJcbiAqIEBuYW1lIE5hbWVzcGFjZUJhc2UjbmVzdGVkQXJyYXlcclxuICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3RbXX1cclxuICogQHJlYWRvbmx5XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTmFtZXNwYWNlLnByb3RvdHlwZSwgXCJuZXN0ZWRBcnJheVwiLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXN0ZWRBcnJheSB8fCAodGhpcy5fbmVzdGVkQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5uZXN0ZWQpKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogTmFtZXNwYWNlIGRlc2NyaXB0b3IuXHJcbiAqIEBpbnRlcmZhY2UgSU5hbWVzcGFjZVxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gTmFtZXNwYWNlIG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBbbmVzdGVkXSBOZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFueSBleHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cclxuICogQHR5cGVkZWYgQW55RXh0ZW5zaW9uRmllbGRcclxuICogQHR5cGUge0lFeHRlbnNpb25GaWVsZHxJRXh0ZW5zaW9uTWFwRmllbGR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFueSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3IuXHJcbiAqIEB0eXBlZGVmIEFueU5lc3RlZE9iamVjdFxyXG4gKiBAdHlwZSB7SUVudW18SVR5cGV8SVNlcnZpY2V8QW55RXh0ZW5zaW9uRmllbGR8SU5hbWVzcGFjZXxJT25lT2Z9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgbmFtZXNwYWNlIHRvIGEgbmFtZXNwYWNlIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZX0gTmFtZXNwYWNlIGRlc2NyaXB0b3JcclxuICovXHJcbk5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcclxuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcclxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcclxuICAgICAgICBcIm5lc3RlZFwiICAsIGFycmF5VG9KU09OKHRoaXMubmVzdGVkQXJyYXksIHRvSlNPTk9wdGlvbnMpXHJcbiAgICBdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIG5lc3RlZCBvYmplY3RzIHRvIHRoaXMgbmFtZXNwYWNlIGZyb20gbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9ycy5cclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBuZXN0ZWRKc29uIEFueSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXHJcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxyXG4gKi9cclxuTmFtZXNwYWNlLnByb3RvdHlwZS5hZGRKU09OID0gZnVuY3Rpb24gYWRkSlNPTihuZXN0ZWRKc29uKSB7XHJcbiAgICB2YXIgbnMgPSB0aGlzO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChuZXN0ZWRKc29uKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhuZXN0ZWRKc29uKSwgaSA9IDAsIG5lc3RlZDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5lc3RlZCA9IG5lc3RlZEpzb25bbmFtZXNbaV1dO1xyXG4gICAgICAgICAgICBucy5hZGQoIC8vIG1vc3QgdG8gbGVhc3QgbGlrZWx5XHJcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXHJcbiAgICAgICAgICAgICAgICA6IG5lc3RlZC52YWx1ZXMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXHJcbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gU2VydmljZS5mcm9tSlNPTlxyXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxyXG4gICAgICAgICAgICAgICAgOiBOYW1lc3BhY2UuZnJvbUpTT04gKShuYW1lc1tpXSwgbmVzdGVkKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG5lc3RlZCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOZXN0ZWQgb2JqZWN0IG5hbWVcclxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gVGhlIHJlZmxlY3Rpb24gb2JqZWN0IG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0XHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cclxuICAgICAgICB8fCBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHZhbHVlcyBvZiB0aGUgbmVzdGVkIHtAbGluayBFbnVtfGVudW19IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICogVGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2dldHxnZXR9IGluIHRoYXQgaXQgcmV0dXJucyBhbiBlbnVtJ3MgdmFsdWVzIGRpcmVjdGx5IGFuZCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOZXN0ZWQgZW51bSBuYW1lXHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBFbnVtIHZhbHVlc1xyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBlbnVtXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLmdldEVudW0gPSBmdW5jdGlvbiBnZXRFbnVtKG5hbWUpIHtcclxuICAgIGlmICh0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXSBpbnN0YW5jZW9mIEVudW0pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmVzdGVkW25hbWVdLnZhbHVlcztcclxuICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBlbnVtOiBcIiArIG5hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIGFkZFxyXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcclxuXHJcbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgVHlwZSAgfHwgb2JqZWN0IGluc3RhbmNlb2YgT25lT2YgfHwgb2JqZWN0IGluc3RhbmNlb2YgRW51bSB8fCBvYmplY3QgaW5zdGFuY2VvZiBTZXJ2aWNlIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSB2YWxpZCBuZXN0ZWQgb2JqZWN0XCIpO1xyXG5cclxuICAgIGlmICghdGhpcy5uZXN0ZWQpXHJcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXQob2JqZWN0Lm5hbWUpO1xyXG4gICAgICAgIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2IGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAhKHByZXYgaW5zdGFuY2VvZiBUeXBlIHx8IHByZXYgaW5zdGFuY2VvZiBTZXJ2aWNlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwbGFpbiBuYW1lc3BhY2UgYnV0IGtlZXAgZXhpc3RpbmcgbmVzdGVkIGVsZW1lbnRzIGFuZCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkID0gcHJldi5uZXN0ZWRBcnJheTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVzdGVkLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5hZGQobmVzdGVkW2ldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHByZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5lc3RlZClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LnNldE9wdGlvbnMocHJldi5vcHRpb25zLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXSA9IG9iamVjdDtcclxuICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcclxuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyBuYW1lc3BhY2UuXHJcbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXHJcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG9iamVjdGAgaXMgbm90IGEgbWVtYmVyIG9mIHRoaXMgbmFtZXNwYWNlXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcclxuXHJcbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBSZWZsZWN0aW9uT2JqZWN0KSlcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIFJlZmxlY3Rpb25PYmplY3RcIik7XHJcbiAgICBpZiAob2JqZWN0LnBhcmVudCAhPT0gdGhpcylcclxuICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcclxuXHJcbiAgICBkZWxldGUgdGhpcy5uZXN0ZWRbb2JqZWN0Lm5hbWVdO1xyXG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm5lc3RlZCkubGVuZ3RoKVxyXG4gICAgICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcclxuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlZmluZXMgYWRkaXRpYWwgbmFtZXNwYWNlcyB3aXRoaW4gdGhpcyBvbmUgaWYgbm90IHlldCBleGlzdGluZy5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBjcmVhdGVcclxuICogQHBhcmFtIHsqfSBbanNvbl0gTmVzdGVkIHR5cGVzIHRvIGNyZWF0ZSBmcm9tIEpTT05cclxuICogQHJldHVybnMge05hbWVzcGFjZX0gUG9pbnRlciB0byB0aGUgbGFzdCBuYW1lc3BhY2UgY3JlYXRlZCBvciBgdGhpc2AgaWYgcGF0aCBpcyBlbXB0eVxyXG4gKi9cclxuTmFtZXNwYWNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocGF0aCwganNvbikge1xyXG5cclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHBhdGgpKVxyXG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlsbGVnYWwgcGF0aFwiKTtcclxuICAgIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoICYmIHBhdGhbMF0gPT09IFwiXCIpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIG11c3QgYmUgcmVsYXRpdmVcIik7XHJcblxyXG4gICAgdmFyIHB0ciA9IHRoaXM7XHJcbiAgICB3aGlsZSAocGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKHB0ci5uZXN0ZWQgJiYgcHRyLm5lc3RlZFtwYXJ0XSkge1xyXG4gICAgICAgICAgICBwdHIgPSBwdHIubmVzdGVkW3BhcnRdO1xyXG4gICAgICAgICAgICBpZiAoIShwdHIgaW5zdGFuY2VvZiBOYW1lc3BhY2UpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIGNvbmZsaWN0cyB3aXRoIG5vbi1uYW1lc3BhY2Ugb2JqZWN0c1wiKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcHRyLmFkZChwdHIgPSBuZXcgTmFtZXNwYWNlKHBhcnQpKTtcclxuICAgIH1cclxuICAgIGlmIChqc29uKVxyXG4gICAgICAgIHB0ci5hZGRKU09OKGpzb24pO1xyXG4gICAgcmV0dXJuIHB0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlcyB0aGlzIG5hbWVzcGFjZSdzIGFuZCBhbGwgaXRzIG5lc3RlZCBvYmplY3RzJyB0eXBlIHJlZmVyZW5jZXMuIFVzZWZ1bCB0byB2YWxpZGF0ZSBhIHJlZmxlY3Rpb24gdHJlZSwgYnV0IGNvbWVzIGF0IGEgY29zdC5cclxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xyXG4gICAgdmFyIG5lc3RlZCA9IHRoaXMubmVzdGVkQXJyYXksIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBuZXN0ZWQubGVuZ3RoKVxyXG4gICAgICAgIGlmIChuZXN0ZWRbaV0gaW5zdGFuY2VvZiBOYW1lc3BhY2UpXHJcbiAgICAgICAgICAgIG5lc3RlZFtpKytdLnJlc29sdmVBbGwoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG5lc3RlZFtpKytdLnJlc29sdmUoKTtcclxuICAgIHJldHVybiB0aGlzLnJlc29sdmUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBsb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBwYXRoIGluIHRoZSBzY29wZSBvZiB0aGlzIG5hbWVzcGFjZS5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXHJcbiAqIEBwYXJhbSB7KnxBcnJheS48Kj59IGZpbHRlclR5cGVzIEZpbHRlciB0eXBlcywgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSBjb25zdHJ1Y3RvcnMgb2YgYHByb3RvYnVmLlR5cGVgLCBgcHJvdG9idWYuRW51bWAsIGBwcm90b2J1Zi5TZXJ2aWNlYCBldGMuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBJZiBrbm93biwgd2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxyXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBMb29rZWQgdXAgb2JqZWN0IG9yIGBudWxsYCBpZiBub25lIGNvdWxkIGJlIGZvdW5kXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgcGFyZW50QWxyZWFkeUNoZWNrZWQpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJUeXBlcyA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBwYXJlbnRBbHJlYWR5Q2hlY2tlZCA9IGZpbHRlclR5cGVzO1xyXG4gICAgICAgIGZpbHRlclR5cGVzID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUeXBlcyAmJiAhQXJyYXkuaXNBcnJheShmaWx0ZXJUeXBlcykpXHJcbiAgICAgICAgZmlsdGVyVHlwZXMgPSBbIGZpbHRlclR5cGVzIF07XHJcblxyXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkgJiYgcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGF0aCA9PT0gXCIuXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XHJcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgfSBlbHNlIGlmICghcGF0aC5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgLy8gU3RhcnQgYXQgcm9vdCBpZiBwYXRoIGlzIGFic29sdXRlXHJcbiAgICBpZiAocGF0aFswXSA9PT0gXCJcIilcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcyk7XHJcblxyXG4gICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgcGFydCBtYXRjaGVzIGFueSBuZXN0ZWQgb2JqZWN0LCBhbmQgaWYgc28sIHRyYXZlcnNlIGlmIHBhdGggY29udGFpbnMgbW9yZVxyXG4gICAgdmFyIGZvdW5kID0gdGhpcy5nZXQocGF0aFswXSk7XHJcbiAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFmaWx0ZXJUeXBlcyB8fCBmaWx0ZXJUeXBlcy5pbmRleE9mKGZvdW5kLmNvbnN0cnVjdG9yKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgKGZvdW5kID0gZm91bmQubG9va3VwKHBhdGguc2xpY2UoMSksIGZpbHRlclR5cGVzLCB0cnVlKSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcclxuXHJcbiAgICAvLyBPdGhlcndpc2UgdHJ5IGVhY2ggbmVzdGVkIG5hbWVzcGFjZVxyXG4gICAgfSBlbHNlXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgKGZvdW5kID0gdGhpcy5fbmVzdGVkQXJyYXlbaV0ubG9va3VwKHBhdGgsIGZpbHRlclR5cGVzLCB0cnVlKSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaGFzbid0IGJlZW4gYSBtYXRjaCwgdHJ5IGFnYWluIGF0IHRoZSBwYXJlbnRcclxuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnRBbHJlYWR5Q2hlY2tlZClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB0aGlzLnBhcmVudC5sb29rdXAocGF0aCwgZmlsdGVyVHlwZXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI2xvb2t1cFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBXaGV0aGVyIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkXHJcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IExvb2tlZCB1cCBvYmplY3Qgb3IgYG51bGxgIGlmIG5vbmUgY291bGQgYmUgZm91bmRcclxuICogQHZhcmlhdGlvbiAyXHJcbiAqL1xyXG4vLyBsb29rdXAocGF0aDogc3RyaW5nLCBbcGFyZW50QWxyZWFkeUNoZWNrZWQ6IGJvb2xlYW5dKVxyXG5cclxuLyoqXHJcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxyXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGVcclxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGVcclxuICovXHJcbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwVHlwZSA9IGZ1bmN0aW9uIGxvb2t1cFR5cGUocGF0aCkge1xyXG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlIF0pO1xyXG4gICAgaWYgKCFmb3VuZClcclxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggdHlwZTogXCIgKyBwYXRoKTtcclxuICAgIHJldHVybiBmb3VuZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb29rcyB1cCB0aGUgdmFsdWVzIG9mIHRoZSB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxyXG4gKiBAcmV0dXJucyB7RW51bX0gTG9va2VkIHVwIGVudW1cclxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhbiBlbnVtXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cEVudW0gPSBmdW5jdGlvbiBsb29rdXBFbnVtKHBhdGgpIHtcclxuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgRW51bSBdKTtcclxuICAgIGlmICghZm91bmQpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIEVudW0gJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBvciB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxyXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGUgb3IgZW51bVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgdHlwZSBvciBlbnVtXHJcbiAqL1xyXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGVPckVudW0gPSBmdW5jdGlvbiBsb29rdXBUeXBlT3JFbnVtKHBhdGgpIHtcclxuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgVHlwZSwgRW51bSBdKTtcclxuICAgIGlmICghZm91bmQpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFR5cGUgb3IgRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XHJcbiAgICByZXR1cm4gZm91bmQ7XHJcbn07XHJcblxyXG4vKipcclxuICogTG9va3MgdXAgdGhlIHtAbGluayBTZXJ2aWNlfHNlcnZpY2V9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXHJcbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXHJcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBMb29rZWQgdXAgc2VydmljZVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgc2VydmljZVxyXG4gKi9cclxuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBTZXJ2aWNlID0gZnVuY3Rpb24gbG9va3VwU2VydmljZShwYXRoKSB7XHJcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFNlcnZpY2UgXSk7XHJcbiAgICBpZiAoIWZvdW5kKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBTZXJ2aWNlICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcclxuICAgIHJldHVybiBmb3VuZDtcclxufTtcclxuXHJcbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxyXG5OYW1lc3BhY2UuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBTZXJ2aWNlXywgRW51bV8pIHtcclxuICAgIFR5cGUgICAgPSBUeXBlXztcclxuICAgIFNlcnZpY2UgPSBTZXJ2aWNlXztcclxuICAgIEVudW0gICAgPSBFbnVtXztcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = ReflectionObject;\r\n\r\nReflectionObject.className = \"ReflectionObject\";\r\n\r\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nvar Root; // cyclic\r\n\r\n/**\r\n * Constructs a new reflection object instance.\r\n * @classdesc Base class of all reflection objects.\r\n * @constructor\r\n * @param {string} name Object name\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @abstract\r\n */\r\nfunction ReflectionObject(name, options) {\r\n\r\n    if (!util.isString(name))\r\n        throw TypeError(\"name must be a string\");\r\n\r\n    if (options && !util.isObject(options))\r\n        throw TypeError(\"options must be an object\");\r\n\r\n    /**\r\n     * Options.\r\n     * @type {Object.<string,*>|undefined}\r\n     */\r\n    this.options = options; // toJSON\r\n\r\n    /**\r\n     * Parsed Options.\r\n     * @type {Array.<Object.<string,*>>|undefined}\r\n     */\r\n    this.parsedOptions = null;\r\n\r\n    /**\r\n     * Unique name within its namespace.\r\n     * @type {string}\r\n     */\r\n    this.name = name;\r\n\r\n    /**\r\n     * Parent namespace.\r\n     * @type {Namespace|null}\r\n     */\r\n    this.parent = null;\r\n\r\n    /**\r\n     * Whether already resolved or not.\r\n     * @type {boolean}\r\n     */\r\n    this.resolved = false;\r\n\r\n    /**\r\n     * Comment text, if any.\r\n     * @type {string|null}\r\n     */\r\n    this.comment = null;\r\n\r\n    /**\r\n     * Defining file name.\r\n     * @type {string|null}\r\n     */\r\n    this.filename = null;\r\n}\r\n\r\nObject.defineProperties(ReflectionObject.prototype, {\r\n\r\n    /**\r\n     * Reference to the root namespace.\r\n     * @name ReflectionObject#root\r\n     * @type {Root}\r\n     * @readonly\r\n     */\r\n    root: {\r\n        get: function() {\r\n            var ptr = this;\r\n            while (ptr.parent !== null)\r\n                ptr = ptr.parent;\r\n            return ptr;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Full name including leading dot.\r\n     * @name ReflectionObject#fullName\r\n     * @type {string}\r\n     * @readonly\r\n     */\r\n    fullName: {\r\n        get: function() {\r\n            var path = [ this.name ],\r\n                ptr = this.parent;\r\n            while (ptr) {\r\n                path.unshift(ptr.name);\r\n                ptr = ptr.parent;\r\n            }\r\n            return path.join(\".\");\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Converts this reflection object to its descriptor representation.\r\n * @returns {Object.<string,*>} Descriptor\r\n * @abstract\r\n */\r\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\r\n    throw Error(); // not implemented, shouldn't happen\r\n};\r\n\r\n/**\r\n * Called when this object is added to a parent.\r\n * @param {ReflectionObject} parent Parent added to\r\n * @returns {undefined}\r\n */\r\nReflectionObject.prototype.onAdd = function onAdd(parent) {\r\n    if (this.parent && this.parent !== parent)\r\n        this.parent.remove(this);\r\n    this.parent = parent;\r\n    this.resolved = false;\r\n    var root = parent.root;\r\n    if (root instanceof Root)\r\n        root._handleAdd(this);\r\n};\r\n\r\n/**\r\n * Called when this object is removed from a parent.\r\n * @param {ReflectionObject} parent Parent removed from\r\n * @returns {undefined}\r\n */\r\nReflectionObject.prototype.onRemove = function onRemove(parent) {\r\n    var root = parent.root;\r\n    if (root instanceof Root)\r\n        root._handleRemove(this);\r\n    this.parent = null;\r\n    this.resolved = false;\r\n};\r\n\r\n/**\r\n * Resolves this objects type references.\r\n * @returns {ReflectionObject} `this`\r\n */\r\nReflectionObject.prototype.resolve = function resolve() {\r\n    if (this.resolved)\r\n        return this;\r\n    if (this.root instanceof Root)\r\n        this.resolved = true; // only if part of a root\r\n    return this;\r\n};\r\n\r\n/**\r\n * Gets an option value.\r\n * @param {string} name Option name\r\n * @returns {*} Option value or `undefined` if not set\r\n */\r\nReflectionObject.prototype.getOption = function getOption(name) {\r\n    if (this.options)\r\n        return this.options[name];\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Sets an option.\r\n * @param {string} name Option name\r\n * @param {*} value Option value\r\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\r\n * @returns {ReflectionObject} `this`\r\n */\r\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\r\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\r\n        (this.options || (this.options = {}))[name] = value;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets a parsed option.\r\n * @param {string} name parsed Option name\r\n * @param {*} value Option value\r\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\r\n * @returns {ReflectionObject} `this`\r\n */\r\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\r\n    if (!this.parsedOptions) {\r\n        this.parsedOptions = [];\r\n    }\r\n    var parsedOptions = this.parsedOptions;\r\n    if (propName) {\r\n        // If setting a sub property of an option then try to merge it\r\n        // with an existing option\r\n        var opt = parsedOptions.find(function (opt) {\r\n            return Object.prototype.hasOwnProperty.call(opt, name);\r\n        });\r\n        if (opt) {\r\n            // If we found an existing option - just merge the property value\r\n            var newValue = opt[name];\r\n            util.setProperty(newValue, propName, value);\r\n        } else {\r\n            // otherwise, create a new option, set it's property and add it to the list\r\n            opt = {};\r\n            opt[name] = util.setProperty({}, propName, value);\r\n            parsedOptions.push(opt);\r\n        }\r\n    } else {\r\n        // Always create a new option when setting the value of the option itself\r\n        var newOpt = {};\r\n        newOpt[name] = value;\r\n        parsedOptions.push(newOpt);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets multiple options.\r\n * @param {Object.<string,*>} options Options to set\r\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\r\n * @returns {ReflectionObject} `this`\r\n */\r\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\r\n    if (options)\r\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\r\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Converts this instance to its string representation.\r\n * @returns {string} Class name[, space, full name]\r\n */\r\nReflectionObject.prototype.toString = function toString() {\r\n    var className = this.constructor.className,\r\n        fullName  = this.fullName;\r\n    if (fullName.length)\r\n        return className + \" \" + fullName;\r\n    return className;\r\n};\r\n\r\n// Sets up cyclic dependencies (called in index-light)\r\nReflectionObject._configure = function(Root_) {\r\n    Root = Root_;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsc0ZBQVE7QUFDM0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9vYmplY3QuanM/OWJjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0aW9uT2JqZWN0O1xyXG5cclxuUmVmbGVjdGlvbk9iamVjdC5jbGFzc05hbWUgPSBcIlJlZmxlY3Rpb25PYmplY3RcIjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuXHJcbnZhciBSb290OyAvLyBjeWNsaWNcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3Rpb24gb2JqZWN0IGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3Rpb24gb2JqZWN0cy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuZnVuY3Rpb24gUmVmbGVjdGlvbk9iamVjdChuYW1lLCBvcHRpb25zKSB7XHJcblxyXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucyAmJiAhdXRpbC5pc09iamVjdChvcHRpb25zKSlcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9ucy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPnx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIHRvSlNPTlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VkIE9wdGlvbnMuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCo+Pnx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZS5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJlbnQgbmFtZXNwYWNlLlxyXG4gICAgICogQHR5cGUge05hbWVzcGFjZXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGFscmVhZHkgcmVzb2x2ZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbW1lbnQgdGV4dCwgaWYgYW55LlxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5pbmcgZmlsZSBuYW1lLlxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcm9vdCBuYW1lc3BhY2UuXHJcbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I3Jvb3RcclxuICAgICAqIEB0eXBlIHtSb290fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHJvb3Q6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcHRyID0gdGhpcztcclxuICAgICAgICAgICAgd2hpbGUgKHB0ci5wYXJlbnQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gcHRyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdWxsIG5hbWUgaW5jbHVkaW5nIGxlYWRpbmcgZG90LlxyXG4gICAgICogQG5hbWUgUmVmbGVjdGlvbk9iamVjdCNmdWxsTmFtZVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBmdWxsTmFtZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gWyB0aGlzLm5hbWUgXSxcclxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB3aGlsZSAocHRyKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQocHRyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgcmVmbGVjdGlvbiBvYmplY3QgdG8gaXRzIGRlc2NyaXB0b3IgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzY3JpcHRvclxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgIHRocm93IEVycm9yKCk7IC8vIG5vdCBpbXBsZW1lbnRlZCwgc2hvdWxkbid0IGhhcHBlblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIGFkZGVkIHRvIGEgcGFyZW50LlxyXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IHBhcmVudCBQYXJlbnQgYWRkZWQgdG9cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XHJcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQgIT09IHBhcmVudClcclxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcclxuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XHJcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXHJcbiAgICAgICAgcm9vdC5faGFuZGxlQWRkKHRoaXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIHBhcmVudC5cclxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IHJlbW92ZWQgZnJvbVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcclxuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XHJcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXHJcbiAgICAgICAgcm9vdC5faGFuZGxlUmVtb3ZlKHRoaXMpO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc29sdmVzIHRoaXMgb2JqZWN0cyB0eXBlIHJlZmVyZW5jZXMuXHJcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcclxuICovXHJcblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xyXG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBpZiAodGhpcy5yb290IGluc3RhbmNlb2YgUm9vdClcclxuICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZTsgLy8gb25seSBpZiBwYXJ0IG9mIGEgcm9vdFxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBhbiBvcHRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbiBuYW1lXHJcbiAqIEByZXR1cm5zIHsqfSBPcHRpb24gdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgbm90IHNldFxyXG4gKi9cclxuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBhbiBvcHRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIHRoZSBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XHJcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcclxuICovXHJcblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcclxuICAgIGlmICghaWZOb3RTZXQgfHwgIXRoaXMub3B0aW9ucyB8fCB0aGlzLm9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAodGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSkpW25hbWVdID0gdmFsdWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIGEgcGFyc2VkIG9wdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgcGFyc2VkIE9wdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBkb3QgJy4nIGRlbGltaXRlZCBmdWxsIHBhdGggb2YgcHJvcGVydHkgd2l0aGluIHRoZSBvcHRpb24gdG8gc2V0LiBpZiB1bmRlZmluZWRcXGVtcHR5LCB3aWxsIGFkZCBhIG5ldyBvcHRpb24gd2l0aCB0aGF0IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcclxuICovXHJcblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldFBhcnNlZE9wdGlvbiA9IGZ1bmN0aW9uIHNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpIHtcclxuICAgIGlmICghdGhpcy5wYXJzZWRPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZWRPcHRpb25zID0gW107XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyc2VkT3B0aW9ucyA9IHRoaXMucGFyc2VkT3B0aW9ucztcclxuICAgIGlmIChwcm9wTmFtZSkge1xyXG4gICAgICAgIC8vIElmIHNldHRpbmcgYSBzdWIgcHJvcGVydHkgb2YgYW4gb3B0aW9uIHRoZW4gdHJ5IHRvIG1lcmdlIGl0XHJcbiAgICAgICAgLy8gd2l0aCBhbiBleGlzdGluZyBvcHRpb25cclxuICAgICAgICB2YXIgb3B0ID0gcGFyc2VkT3B0aW9ucy5maW5kKGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHQsIG5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvcHQpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYW4gZXhpc3Rpbmcgb3B0aW9uIC0ganVzdCBtZXJnZSB0aGUgcHJvcGVydHkgdmFsdWVcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gb3B0W25hbWVdO1xyXG4gICAgICAgICAgICB1dGlsLnNldFByb3BlcnR5KG5ld1ZhbHVlLCBwcm9wTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IG9wdGlvbiwgc2V0IGl0J3MgcHJvcGVydHkgYW5kIGFkZCBpdCB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICBvcHQgPSB7fTtcclxuICAgICAgICAgICAgb3B0W25hbWVdID0gdXRpbC5zZXRQcm9wZXJ0eSh7fSwgcHJvcE5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucy5wdXNoKG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgbmV3IG9wdGlvbiB3aGVuIHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gaXRzZWxmXHJcbiAgICAgICAgdmFyIG5ld09wdCA9IHt9O1xyXG4gICAgICAgIG5ld09wdFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIHBhcnNlZE9wdGlvbnMucHVzaChuZXdPcHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBtdWx0aXBsZSBvcHRpb25zLlxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE9wdGlvbnMgdG8gc2V0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIGFuIG9wdGlvbiBvbmx5IGlmIGl0IGlzbid0IGN1cnJlbnRseSBzZXRcclxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxyXG4gKi9cclxuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaWZOb3RTZXQpIHtcclxuICAgIGlmIChvcHRpb25zKVxyXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbihrZXlzW2ldLCBvcHRpb25zW2tleXNbaV1dLCBpZk5vdFNldCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGluc3RhbmNlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENsYXNzIG5hbWVbLCBzcGFjZSwgZnVsbCBuYW1lXVxyXG4gKi9cclxuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZSxcclxuICAgICAgICBmdWxsTmFtZSAgPSB0aGlzLmZ1bGxOYW1lO1xyXG4gICAgaWYgKGZ1bGxOYW1lLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lICsgXCIgXCIgKyBmdWxsTmFtZTtcclxuICAgIHJldHVybiBjbGFzc05hbWU7XHJcbn07XHJcblxyXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcclxuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlID0gZnVuY3Rpb24oUm9vdF8pIHtcclxuICAgIFJvb3QgPSBSb290XztcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = OneOf;\r\n\r\n// extends ReflectionObject\r\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\r\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\r\n\r\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"),\r\n    util  = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\n/**\r\n * Constructs a new oneof instance.\r\n * @classdesc Reflected oneof.\r\n * @extends ReflectionObject\r\n * @constructor\r\n * @param {string} name Oneof name\r\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] Comment associated with this field\r\n */\r\nfunction OneOf(name, fieldNames, options, comment) {\r\n    if (!Array.isArray(fieldNames)) {\r\n        options = fieldNames;\r\n        fieldNames = undefined;\r\n    }\r\n    ReflectionObject.call(this, name, options);\r\n\r\n    /* istanbul ignore if */\r\n    if (!(fieldNames === undefined || Array.isArray(fieldNames)))\r\n        throw TypeError(\"fieldNames must be an Array\");\r\n\r\n    /**\r\n     * Field names that belong to this oneof.\r\n     * @type {string[]}\r\n     */\r\n    this.oneof = fieldNames || []; // toJSON, marker\r\n\r\n    /**\r\n     * Fields that belong to this oneof as an array for iteration.\r\n     * @type {Field[]}\r\n     * @readonly\r\n     */\r\n    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\r\n\r\n    /**\r\n     * Comment for this field.\r\n     * @type {string|null}\r\n     */\r\n    this.comment = comment;\r\n}\r\n\r\n/**\r\n * Oneof descriptor.\r\n * @interface IOneOf\r\n * @property {Array.<string>} oneof Oneof field names\r\n * @property {Object.<string,*>} [options] Oneof options\r\n */\r\n\r\n/**\r\n * Constructs a oneof from a oneof descriptor.\r\n * @param {string} name Oneof name\r\n * @param {IOneOf} json Oneof descriptor\r\n * @returns {OneOf} Created oneof\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nOneOf.fromJSON = function fromJSON(name, json) {\r\n    return new OneOf(name, json.oneof, json.options, json.comment);\r\n};\r\n\r\n/**\r\n * Converts this oneof to a oneof descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IOneOf} Oneof descriptor\r\n */\r\nOneOf.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"options\" , this.options,\r\n        \"oneof\"   , this.oneof,\r\n        \"comment\" , keepComments ? this.comment : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * Adds the fields of the specified oneof to the parent if not already done so.\r\n * @param {OneOf} oneof The oneof\r\n * @returns {undefined}\r\n * @inner\r\n * @ignore\r\n */\r\nfunction addFieldsToParent(oneof) {\r\n    if (oneof.parent)\r\n        for (var i = 0; i < oneof.fieldsArray.length; ++i)\r\n            if (!oneof.fieldsArray[i].parent)\r\n                oneof.parent.add(oneof.fieldsArray[i]);\r\n}\r\n\r\n/**\r\n * Adds a field to this oneof and removes it from its current parent, if any.\r\n * @param {Field} field Field to add\r\n * @returns {OneOf} `this`\r\n */\r\nOneOf.prototype.add = function add(field) {\r\n\r\n    /* istanbul ignore if */\r\n    if (!(field instanceof Field))\r\n        throw TypeError(\"field must be a Field\");\r\n\r\n    if (field.parent && field.parent !== this.parent)\r\n        field.parent.remove(field);\r\n    this.oneof.push(field.name);\r\n    this.fieldsArray.push(field);\r\n    field.partOf = this; // field.parent remains null\r\n    addFieldsToParent(this);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes a field from this oneof and puts it back to the oneof's parent.\r\n * @param {Field} field Field to remove\r\n * @returns {OneOf} `this`\r\n */\r\nOneOf.prototype.remove = function remove(field) {\r\n\r\n    /* istanbul ignore if */\r\n    if (!(field instanceof Field))\r\n        throw TypeError(\"field must be a Field\");\r\n\r\n    var index = this.fieldsArray.indexOf(field);\r\n\r\n    /* istanbul ignore if */\r\n    if (index < 0)\r\n        throw Error(field + \" is not a member of \" + this);\r\n\r\n    this.fieldsArray.splice(index, 1);\r\n    index = this.oneof.indexOf(field.name);\r\n\r\n    /* istanbul ignore else */\r\n    if (index > -1) // theoretical\r\n        this.oneof.splice(index, 1);\r\n\r\n    field.partOf = null;\r\n    return this;\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nOneOf.prototype.onAdd = function onAdd(parent) {\r\n    ReflectionObject.prototype.onAdd.call(this, parent);\r\n    var self = this;\r\n    // Collect present fields\r\n    for (var i = 0; i < this.oneof.length; ++i) {\r\n        var field = parent.get(this.oneof[i]);\r\n        if (field && !field.partOf) {\r\n            field.partOf = self;\r\n            self.fieldsArray.push(field);\r\n        }\r\n    }\r\n    // Add not yet present fields\r\n    addFieldsToParent(this);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nOneOf.prototype.onRemove = function onRemove(parent) {\r\n    for (var i = 0, field; i < this.fieldsArray.length; ++i)\r\n        if ((field = this.fieldsArray[i]).parent)\r\n            field.parent.remove(field);\r\n    ReflectionObject.prototype.onRemove.call(this, parent);\r\n};\r\n\r\n/**\r\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\r\n * @typedef OneOfDecorator\r\n * @type {function}\r\n * @param {Object} prototype Target prototype\r\n * @param {string} oneofName OneOf name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * OneOf decorator (TypeScript).\r\n * @function\r\n * @param {...string} fieldNames Field names\r\n * @returns {OneOfDecorator} Decorator function\r\n * @template T extends string\r\n */\r\nOneOf.d = function decorateOneOf() {\r\n    var fieldNames = new Array(arguments.length),\r\n        index = 0;\r\n    while (index < arguments.length)\r\n        fieldNames[index] = arguments[index++];\r\n    return function oneOfDecorator(prototype, oneofName) {\r\n        util.decorateType(prototype.constructor)\r\n            .add(new OneOf(oneofName, fieldNames));\r\n        Object.defineProperty(prototype, oneofName, {\r\n            get: util.oneOfGetter(fieldNames),\r\n            set: util.oneOfSetter(fieldNames)\r\n        });\r\n    };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb25lb2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywwRkFBVTtBQUN6QztBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHdGQUFTO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxzRkFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzP2QzNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gT25lT2Y7XHJcblxyXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcclxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XHJcbigoT25lT2YucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gT25lT2YpLmNsYXNzTmFtZSA9IFwiT25lT2ZcIjtcclxuXHJcbnZhciBGaWVsZCA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxyXG4gICAgdXRpbCAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgb25lb2YgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG9uZW9mLlxyXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nW118T2JqZWN0LjxzdHJpbmcsKj59IFtmaWVsZE5hbWVzXSBGaWVsZCBuYW1lc1xyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcclxuICovXHJcbmZ1bmN0aW9uIE9uZU9mKG5hbWUsIGZpZWxkTmFtZXMsIG9wdGlvbnMsIGNvbW1lbnQpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBmaWVsZE5hbWVzO1xyXG4gICAgICAgIGZpZWxkTmFtZXMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIShmaWVsZE5hbWVzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGROYW1lcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmllbGQgbmFtZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBvbmVvZi5cclxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVvZiA9IGZpZWxkTmFtZXMgfHwgW107IC8vIHRvSlNPTiwgbWFya2VyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWVsZHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBvbmVvZiBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxyXG4gICAgICogQHR5cGUge0ZpZWxkW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgdGhpcy5maWVsZHNBcnJheSA9IFtdOyAvLyBkZWNsYXJlZCByZWFkb25seSBmb3IgY29uZm9ybWFuY2UsIHBvc3NpYmx5IG5vdCB5ZXQgYWRkZWQgdG8gcGFyZW50XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xyXG59XHJcblxyXG4vKipcclxuICogT25lb2YgZGVzY3JpcHRvci5cclxuICogQGludGVyZmFjZSBJT25lT2ZcclxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gb25lb2YgT25lb2YgZmllbGQgbmFtZXNcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE9uZW9mIG9wdGlvbnNcclxuICovXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG9uZW9mIGZyb20gYSBvbmVvZiBkZXNjcmlwdG9yLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXHJcbiAqIEBwYXJhbSB7SU9uZU9mfSBqc29uIE9uZW9mIGRlc2NyaXB0b3JcclxuICogQHJldHVybnMge09uZU9mfSBDcmVhdGVkIG9uZW9mXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXHJcbiAqL1xyXG5PbmVPZi5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcclxuICAgIHJldHVybiBuZXcgT25lT2YobmFtZSwganNvbi5vbmVvZiwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgb25lb2YgdG8gYSBvbmVvZiBkZXNjcmlwdG9yLlxyXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcclxuICogQHJldHVybnMge0lPbmVPZn0gT25lb2YgZGVzY3JpcHRvclxyXG4gKi9cclxuT25lT2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XHJcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XHJcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXHJcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgXCJvbmVvZlwiICAgLCB0aGlzLm9uZW9mLFxyXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXHJcbiAgICBdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBmaWVsZHMgb2YgdGhlIHNwZWNpZmllZCBvbmVvZiB0byB0aGUgcGFyZW50IGlmIG5vdCBhbHJlYWR5IGRvbmUgc28uXHJcbiAqIEBwYXJhbSB7T25lT2Z9IG9uZW9mIFRoZSBvbmVvZlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAaW5uZXJcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkRmllbGRzVG9QYXJlbnQob25lb2YpIHtcclxuICAgIGlmIChvbmVvZi5wYXJlbnQpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbmVvZi5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgaWYgKCFvbmVvZi5maWVsZHNBcnJheVtpXS5wYXJlbnQpXHJcbiAgICAgICAgICAgICAgICBvbmVvZi5wYXJlbnQuYWRkKG9uZW9mLmZpZWxkc0FycmF5W2ldKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBmaWVsZCB0byB0aGlzIG9uZW9mIGFuZCByZW1vdmVzIGl0IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50LCBpZiBhbnkuXHJcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIGFkZFxyXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxyXG4gKi9cclxuT25lT2YucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChmaWVsZCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xyXG5cclxuICAgIGlmIChmaWVsZC5wYXJlbnQgJiYgZmllbGQucGFyZW50ICE9PSB0aGlzLnBhcmVudClcclxuICAgICAgICBmaWVsZC5wYXJlbnQucmVtb3ZlKGZpZWxkKTtcclxuICAgIHRoaXMub25lb2YucHVzaChmaWVsZC5uYW1lKTtcclxuICAgIHRoaXMuZmllbGRzQXJyYXkucHVzaChmaWVsZCk7XHJcbiAgICBmaWVsZC5wYXJ0T2YgPSB0aGlzOyAvLyBmaWVsZC5wYXJlbnQgcmVtYWlucyBudWxsXHJcbiAgICBhZGRGaWVsZHNUb1BhcmVudCh0aGlzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBmaWVsZCBmcm9tIHRoaXMgb25lb2YgYW5kIHB1dHMgaXQgYmFjayB0byB0aGUgb25lb2YncyBwYXJlbnQuXHJcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIHJlbW92ZVxyXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxyXG4gKi9cclxuT25lT2YucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShmaWVsZCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xyXG5cclxuICAgIHZhciBpbmRleCA9IHRoaXMuZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCk7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKGZpZWxkICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5maWVsZHNBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgaW5kZXggPSB0aGlzLm9uZW9mLmluZGV4T2YoZmllbGQubmFtZSk7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmIChpbmRleCA+IC0xKSAvLyB0aGVvcmV0aWNhbFxyXG4gICAgICAgIHRoaXMub25lb2Yuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICBmaWVsZC5wYXJ0T2YgPSBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5PbmVPZi5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiBvbkFkZChwYXJlbnQpIHtcclxuICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgcGFyZW50KTtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIC8vIENvbGxlY3QgcHJlc2VudCBmaWVsZHNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vbmVvZi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBmaWVsZCA9IHBhcmVudC5nZXQodGhpcy5vbmVvZltpXSk7XHJcbiAgICAgICAgaWYgKGZpZWxkICYmICFmaWVsZC5wYXJ0T2YpIHtcclxuICAgICAgICAgICAgZmllbGQucGFydE9mID0gc2VsZjtcclxuICAgICAgICAgICAgc2VsZi5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbm90IHlldCBwcmVzZW50IGZpZWxkc1xyXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5PbmVPZi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgaWYgKChmaWVsZCA9IHRoaXMuZmllbGRzQXJyYXlbaV0pLnBhcmVudClcclxuICAgICAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XHJcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIHBhcmVudCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBPbmVPZi5kfSAoVHlwZVNjcmlwdCkuXHJcbiAqIEB0eXBlZGVmIE9uZU9mRGVjb3JhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVvZk5hbWUgT25lT2YgbmFtZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBPbmVPZiBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcclxuICogQHJldHVybnMge09uZU9mRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBzdHJpbmdcclxuICovXHJcbk9uZU9mLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU9uZU9mKCkge1xyXG4gICAgdmFyIGZpZWxkTmFtZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXHJcbiAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBmaWVsZE5hbWVzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvbmVPZkRlY29yYXRvcihwcm90b3R5cGUsIG9uZW9mTmFtZSkge1xyXG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcclxuICAgICAgICAgICAgLmFkZChuZXcgT25lT2Yob25lb2ZOYW1lLCBmaWVsZE5hbWVzKSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgb25lb2ZOYW1lLCB7XHJcbiAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcihmaWVsZE5hbWVzKSxcclxuICAgICAgICAgICAgc2V0OiB1dGlsLm9uZU9mU2V0dGVyKGZpZWxkTmFtZXMpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = parse;\r\n\r\nparse.filename = null;\r\nparse.defaults = { keepCase: false };\r\n\r\nvar tokenize  = __webpack_require__(/*! ./tokenize */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js\"),\r\n    Root      = __webpack_require__(/*! ./root */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\"),\r\n    Type      = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\"),\r\n    Field     = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"),\r\n    MapField  = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\"),\r\n    OneOf     = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\"),\r\n    Enum      = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    Service   = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\"),\r\n    Method    = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\"),\r\n    types     = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"),\r\n    util      = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nvar base10Re    = /^[1-9][0-9]*$/,\r\n    base10NegRe = /^-?[1-9][0-9]*$/,\r\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\r\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\r\n    base8Re     = /^0[0-7]+$/,\r\n    base8NegRe  = /^-?0[0-7]+$/,\r\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\r\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\r\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\r\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\r\n\r\n/**\r\n * Result object returned from {@link parse}.\r\n * @interface IParserResult\r\n * @property {string|undefined} package Package name, if declared\r\n * @property {string[]|undefined} imports Imports, if any\r\n * @property {string[]|undefined} weakImports Weak imports, if any\r\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\r\n * @property {Root} root Populated root instance\r\n */\r\n\r\n/**\r\n * Options modifying the behavior of {@link parse}.\r\n * @interface IParseOptions\r\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\r\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\r\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\r\n */\r\n\r\n/**\r\n * Options modifying the behavior of JSON serialization.\r\n * @interface IToJSONOptions\r\n * @property {boolean} [keepComments=false] Serializes comments.\r\n */\r\n\r\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @param {string} source Source contents\r\n * @param {Root} root Root to populate\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n */\r\nfunction parse(source, root, options) {\r\n    /* eslint-disable callback-return */\r\n    if (!(root instanceof Root)) {\r\n        options = root;\r\n        root = new Root();\r\n    }\r\n    if (!options)\r\n        options = parse.defaults;\r\n\r\n    var preferTrailingComment = options.preferTrailingComment || false;\r\n    var tn = tokenize(source, options.alternateCommentMode || false),\r\n        next = tn.next,\r\n        push = tn.push,\r\n        peek = tn.peek,\r\n        skip = tn.skip,\r\n        cmnt = tn.cmnt;\r\n\r\n    var head = true,\r\n        pkg,\r\n        imports,\r\n        weakImports,\r\n        syntax,\r\n        isProto3 = false;\r\n\r\n    var ptr = root;\r\n\r\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\r\n\r\n    /* istanbul ignore next */\r\n    function illegal(token, name, insideTryCatch) {\r\n        var filename = parse.filename;\r\n        if (!insideTryCatch)\r\n            parse.filename = null;\r\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\r\n    }\r\n\r\n    function readString() {\r\n        var values = [],\r\n            token;\r\n        do {\r\n            /* istanbul ignore if */\r\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\r\n                throw illegal(token);\r\n\r\n            values.push(next());\r\n            skip(token);\r\n            token = peek();\r\n        } while (token === \"\\\"\" || token === \"'\");\r\n        return values.join(\"\");\r\n    }\r\n\r\n    function readValue(acceptTypeRef) {\r\n        var token = next();\r\n        switch (token) {\r\n            case \"'\":\r\n            case \"\\\"\":\r\n                push(token);\r\n                return readString();\r\n            case \"true\": case \"TRUE\":\r\n                return true;\r\n            case \"false\": case \"FALSE\":\r\n                return false;\r\n        }\r\n        try {\r\n            return parseNumber(token, /* insideTryCatch */ true);\r\n        } catch (e) {\r\n\r\n            /* istanbul ignore else */\r\n            if (acceptTypeRef && typeRefRe.test(token))\r\n                return token;\r\n\r\n            /* istanbul ignore next */\r\n            throw illegal(token, \"value\");\r\n        }\r\n    }\r\n\r\n    function readRanges(target, acceptStrings) {\r\n        var token, start;\r\n        do {\r\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\r\n                target.push(readString());\r\n            else\r\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\r\n        } while (skip(\",\", true));\r\n        var dummy = {options: undefined};\r\n        dummy.setOption = function(name, value) {\r\n          if (this.options === undefined) this.options = {};\r\n          this.options[name] = value;\r\n        };\r\n        ifBlock(\r\n            dummy,\r\n            function parseRange_block(token) {\r\n              /* istanbul ignore else */\r\n              if (token === \"option\") {\r\n                parseOption(dummy, token);  // skip\r\n                skip(\";\");\r\n              } else\r\n                throw illegal(token);\r\n            },\r\n            function parseRange_line() {\r\n              parseInlineOptions(dummy);  // skip\r\n            });\r\n    }\r\n\r\n    function parseNumber(token, insideTryCatch) {\r\n        var sign = 1;\r\n        if (token.charAt(0) === \"-\") {\r\n            sign = -1;\r\n            token = token.substring(1);\r\n        }\r\n        switch (token) {\r\n            case \"inf\": case \"INF\": case \"Inf\":\r\n                return sign * Infinity;\r\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\r\n                return NaN;\r\n            case \"0\":\r\n                return 0;\r\n        }\r\n        if (base10Re.test(token))\r\n            return sign * parseInt(token, 10);\r\n        if (base16Re.test(token))\r\n            return sign * parseInt(token, 16);\r\n        if (base8Re.test(token))\r\n            return sign * parseInt(token, 8);\r\n\r\n        /* istanbul ignore else */\r\n        if (numberRe.test(token))\r\n            return sign * parseFloat(token);\r\n\r\n        /* istanbul ignore next */\r\n        throw illegal(token, \"number\", insideTryCatch);\r\n    }\r\n\r\n    function parseId(token, acceptNegative) {\r\n        switch (token) {\r\n            case \"max\": case \"MAX\": case \"Max\":\r\n                return 536870911;\r\n            case \"0\":\r\n                return 0;\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (!acceptNegative && token.charAt(0) === \"-\")\r\n            throw illegal(token, \"id\");\r\n\r\n        if (base10NegRe.test(token))\r\n            return parseInt(token, 10);\r\n        if (base16NegRe.test(token))\r\n            return parseInt(token, 16);\r\n\r\n        /* istanbul ignore else */\r\n        if (base8NegRe.test(token))\r\n            return parseInt(token, 8);\r\n\r\n        /* istanbul ignore next */\r\n        throw illegal(token, \"id\");\r\n    }\r\n\r\n    function parsePackage() {\r\n\r\n        /* istanbul ignore if */\r\n        if (pkg !== undefined)\r\n            throw illegal(\"package\");\r\n\r\n        pkg = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(pkg))\r\n            throw illegal(pkg, \"name\");\r\n\r\n        ptr = ptr.define(pkg);\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseImport() {\r\n        var token = peek();\r\n        var whichImports;\r\n        switch (token) {\r\n            case \"weak\":\r\n                whichImports = weakImports || (weakImports = []);\r\n                next();\r\n                break;\r\n            case \"public\":\r\n                next();\r\n                // eslint-disable-next-line no-fallthrough\r\n            default:\r\n                whichImports = imports || (imports = []);\r\n                break;\r\n        }\r\n        token = readString();\r\n        skip(\";\");\r\n        whichImports.push(token);\r\n    }\r\n\r\n    function parseSyntax() {\r\n        skip(\"=\");\r\n        syntax = readString();\r\n        isProto3 = syntax === \"proto3\";\r\n\r\n        /* istanbul ignore if */\r\n        if (!isProto3 && syntax !== \"proto2\")\r\n            throw illegal(syntax, \"syntax\");\r\n\r\n        skip(\";\");\r\n    }\r\n\r\n    function parseCommon(parent, token) {\r\n        switch (token) {\r\n\r\n            case \"option\":\r\n                parseOption(parent, token);\r\n                skip(\";\");\r\n                return true;\r\n\r\n            case \"message\":\r\n                parseType(parent, token);\r\n                return true;\r\n\r\n            case \"enum\":\r\n                parseEnum(parent, token);\r\n                return true;\r\n\r\n            case \"service\":\r\n                parseService(parent, token);\r\n                return true;\r\n\r\n            case \"extend\":\r\n                parseExtension(parent, token);\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function ifBlock(obj, fnIf, fnElse) {\r\n        var trailingLine = tn.line;\r\n        if (obj) {\r\n            if(typeof obj.comment !== \"string\") {\r\n              obj.comment = cmnt(); // try block-type comment\r\n            }\r\n            obj.filename = parse.filename;\r\n        }\r\n        if (skip(\"{\", true)) {\r\n            var token;\r\n            while ((token = next()) !== \"}\")\r\n                fnIf(token);\r\n            skip(\";\", true);\r\n        } else {\r\n            if (fnElse)\r\n                fnElse();\r\n            skip(\";\");\r\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment))\r\n                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\r\n        }\r\n    }\r\n\r\n    function parseType(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"type name\");\r\n\r\n        var type = new Type(token);\r\n        ifBlock(type, function parseType_block(token) {\r\n            if (parseCommon(type, token))\r\n                return;\r\n\r\n            switch (token) {\r\n\r\n                case \"map\":\r\n                    parseMapField(type, token);\r\n                    break;\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                    parseField(type, token);\r\n                    break;\r\n\r\n                case \"optional\":\r\n                    /* istanbul ignore if */\r\n                    if (isProto3) {\r\n                        parseField(type, \"proto3_optional\");\r\n                    } else {\r\n                        parseField(type, \"optional\");\r\n                    }\r\n                    break;\r\n\r\n                case \"oneof\":\r\n                    parseOneOf(type, token);\r\n                    break;\r\n\r\n                case \"extensions\":\r\n                    readRanges(type.extensions || (type.extensions = []));\r\n                    break;\r\n\r\n                case \"reserved\":\r\n                    readRanges(type.reserved || (type.reserved = []), true);\r\n                    break;\r\n\r\n                default:\r\n                    /* istanbul ignore if */\r\n                    if (!isProto3 || !typeRefRe.test(token))\r\n                        throw illegal(token);\r\n\r\n                    push(token);\r\n                    parseField(type, \"optional\");\r\n                    break;\r\n            }\r\n        });\r\n        parent.add(type);\r\n    }\r\n\r\n    function parseField(parent, rule, extend) {\r\n        var type = next();\r\n        if (type === \"group\") {\r\n            parseGroup(parent, rule);\r\n            return;\r\n        }\r\n        // Type names can consume multiple tokens, in multiple variants:\r\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\r\n        // Keep reading tokens until we get a type name with no period at the end,\r\n        // and the next token does not start with a period.\r\n        while (type.endsWith(\".\") || peek().startsWith(\".\")) {\r\n            type += next();\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(type))\r\n            throw illegal(type, \"type\");\r\n\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        name = applyCase(name);\r\n        skip(\"=\");\r\n\r\n        var field = new Field(name, parseId(next()), type, rule, extend);\r\n        ifBlock(field, function parseField_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(field, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseField_line() {\r\n            parseInlineOptions(field);\r\n        });\r\n\r\n        if (rule === \"proto3_optional\") {\r\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\r\n            var oneof = new OneOf(\"_\" + name);\r\n            field.setOption(\"proto3_optional\", true);\r\n            oneof.add(field);\r\n            parent.add(oneof);\r\n        } else {\r\n            parent.add(field);\r\n        }\r\n\r\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\r\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\r\n        // all known packable types and anything that could be an enum (= is not a basic type).\r\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\r\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\r\n    }\r\n\r\n    function parseGroup(parent, rule) {\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        var fieldName = util.lcFirst(name);\r\n        if (name === fieldName)\r\n            name = util.ucFirst(name);\r\n        skip(\"=\");\r\n        var id = parseId(next());\r\n        var type = new Type(name);\r\n        type.group = true;\r\n        var field = new Field(fieldName, id, name, rule);\r\n        field.filename = parse.filename;\r\n        ifBlock(type, function parseGroup_block(token) {\r\n            switch (token) {\r\n\r\n                case \"option\":\r\n                    parseOption(type, token);\r\n                    skip(\";\");\r\n                    break;\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                    parseField(type, token);\r\n                    break;\r\n\r\n                case \"optional\":\r\n                    /* istanbul ignore if */\r\n                    if (isProto3) {\r\n                        parseField(type, \"proto3_optional\");\r\n                    } else {\r\n                        parseField(type, \"optional\");\r\n                    }\r\n                    break;\r\n\r\n                case \"message\":\r\n                    parseType(type, token);\r\n                    break;\r\n\r\n                case \"enum\":\r\n                    parseEnum(type, token);\r\n                    break;\r\n\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw illegal(token); // there are no groups with proto3 semantics\r\n            }\r\n        });\r\n        parent.add(type)\r\n              .add(field);\r\n    }\r\n\r\n    function parseMapField(parent) {\r\n        skip(\"<\");\r\n        var keyType = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (types.mapKey[keyType] === undefined)\r\n            throw illegal(keyType, \"type\");\r\n\r\n        skip(\",\");\r\n        var valueType = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(valueType))\r\n            throw illegal(valueType, \"type\");\r\n\r\n        skip(\">\");\r\n        var name = next();\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(name))\r\n            throw illegal(name, \"name\");\r\n\r\n        skip(\"=\");\r\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\r\n        ifBlock(field, function parseMapField_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(field, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseMapField_line() {\r\n            parseInlineOptions(field);\r\n        });\r\n        parent.add(field);\r\n    }\r\n\r\n    function parseOneOf(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var oneof = new OneOf(applyCase(token));\r\n        ifBlock(oneof, function parseOneOf_block(token) {\r\n            if (token === \"option\") {\r\n                parseOption(oneof, token);\r\n                skip(\";\");\r\n            } else {\r\n                push(token);\r\n                parseField(oneof, \"optional\");\r\n            }\r\n        });\r\n        parent.add(oneof);\r\n    }\r\n\r\n    function parseEnum(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var enm = new Enum(token);\r\n        ifBlock(enm, function parseEnum_block(token) {\r\n          switch(token) {\r\n            case \"option\":\r\n              parseOption(enm, token);\r\n              skip(\";\");\r\n              break;\r\n\r\n            case \"reserved\":\r\n              readRanges(enm.reserved || (enm.reserved = []), true);\r\n              break;\r\n\r\n            default:\r\n              parseEnumValue(enm, token);\r\n          }\r\n        });\r\n        parent.add(enm);\r\n    }\r\n\r\n    function parseEnumValue(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token))\r\n            throw illegal(token, \"name\");\r\n\r\n        skip(\"=\");\r\n        var value = parseId(next(), true),\r\n            dummy = {\r\n                options: undefined\r\n            };\r\n        dummy.setOption = function(name, value) {\r\n            if (this.options === undefined)\r\n                this.options = {};\r\n            this.options[name] = value;\r\n        };\r\n        ifBlock(dummy, function parseEnumValue_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(dummy, token); // skip\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        }, function parseEnumValue_line() {\r\n            parseInlineOptions(dummy); // skip\r\n        });\r\n        parent.add(token, value, dummy.comment, dummy.options);\r\n    }\r\n\r\n    function parseOption(parent, token) {\r\n        var isCustom = skip(\"(\", true);\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var name = token;\r\n        var option = name;\r\n        var propName;\r\n\r\n        if (isCustom) {\r\n            skip(\")\");\r\n            name = \"(\" + name + \")\";\r\n            option = name;\r\n            token = peek();\r\n            if (fqTypeRefRe.test(token)) {\r\n                propName = token.slice(1); //remove '.' before property name\r\n                name += token;\r\n                next();\r\n            }\r\n        }\r\n        skip(\"=\");\r\n        var optionValue = parseOptionValue(parent, name);\r\n        setParsedOption(parent, option, optionValue, propName);\r\n    }\r\n\r\n    function parseOptionValue(parent, name) {\r\n        // { a: \"foo\" b { c: \"bar\" } }\r\n        if (skip(\"{\", true)) {\r\n            var objectResult = {};\r\n\r\n            while (!skip(\"}\", true)) {\r\n                /* istanbul ignore if */\r\n                if (!nameRe.test(token = next())) {\r\n                    throw illegal(token, \"name\");\r\n                }\r\n                if (token === null) {\r\n                  throw illegal(token, \"end of input\");\r\n                }\r\n\r\n                var value;\r\n                var propName = token;\r\n\r\n                skip(\":\", true);\r\n\r\n                if (peek() === \"{\")\r\n                    value = parseOptionValue(parent, name + \".\" + token);\r\n                else if (peek() === \"[\") {\r\n                    // option (my_option) = {\r\n                    //     repeated_value: [ \"foo\", \"bar\" ]\r\n                    // };\r\n                    value = [];\r\n                    var lastValue;\r\n                    if (skip(\"[\", true)) {\r\n                        do {\r\n                            lastValue = readValue(true);\r\n                            value.push(lastValue);\r\n                        } while (skip(\",\", true));\r\n                        skip(\"]\");\r\n                        if (typeof lastValue !== \"undefined\") {\r\n                            setOption(parent, name + \".\" + token, lastValue);\r\n                        }\r\n                    }\r\n                } else {\r\n                    value = readValue(true);\r\n                    setOption(parent, name + \".\" + token, value);\r\n                }\r\n\r\n                var prevValue = objectResult[propName];\r\n\r\n                if (prevValue)\r\n                    value = [].concat(prevValue).concat(value);\r\n\r\n                objectResult[propName] = value;\r\n\r\n                // Semicolons and commas can be optional\r\n                skip(\",\", true);\r\n                skip(\";\", true);\r\n            }\r\n\r\n            return objectResult;\r\n        }\r\n\r\n        var simpleValue = readValue(true);\r\n        setOption(parent, name, simpleValue);\r\n        return simpleValue;\r\n        // Does not enforce a delimiter to be universal\r\n    }\r\n\r\n    function setOption(parent, name, value) {\r\n        if (parent.setOption)\r\n            parent.setOption(name, value);\r\n    }\r\n\r\n    function setParsedOption(parent, name, value, propName) {\r\n        if (parent.setParsedOption)\r\n            parent.setParsedOption(name, value, propName);\r\n    }\r\n\r\n    function parseInlineOptions(parent) {\r\n        if (skip(\"[\", true)) {\r\n            do {\r\n                parseOption(parent, \"option\");\r\n            } while (skip(\",\", true));\r\n            skip(\"]\");\r\n        }\r\n        return parent;\r\n    }\r\n\r\n    function parseService(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"service name\");\r\n\r\n        var service = new Service(token);\r\n        ifBlock(service, function parseService_block(token) {\r\n            if (parseCommon(service, token))\r\n                return;\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"rpc\")\r\n                parseMethod(service, token);\r\n            else\r\n                throw illegal(token);\r\n        });\r\n        parent.add(service);\r\n    }\r\n\r\n    function parseMethod(parent, token) {\r\n        // Get the comment of the preceding line now (if one exists) in case the\r\n        // method is defined across multiple lines.\r\n        var commentText = cmnt();\r\n\r\n        var type = token;\r\n\r\n        /* istanbul ignore if */\r\n        if (!nameRe.test(token = next()))\r\n            throw illegal(token, \"name\");\r\n\r\n        var name = token,\r\n            requestType, requestStream,\r\n            responseType, responseStream;\r\n\r\n        skip(\"(\");\r\n        if (skip(\"stream\", true))\r\n            requestStream = true;\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token);\r\n\r\n        requestType = token;\r\n        skip(\")\"); skip(\"returns\"); skip(\"(\");\r\n        if (skip(\"stream\", true))\r\n            responseStream = true;\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token);\r\n\r\n        responseType = token;\r\n        skip(\")\");\r\n\r\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\r\n        method.comment = commentText;\r\n        ifBlock(method, function parseMethod_block(token) {\r\n\r\n            /* istanbul ignore else */\r\n            if (token === \"option\") {\r\n                parseOption(method, token);\r\n                skip(\";\");\r\n            } else\r\n                throw illegal(token);\r\n\r\n        });\r\n        parent.add(method);\r\n    }\r\n\r\n    function parseExtension(parent, token) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!typeRefRe.test(token = next()))\r\n            throw illegal(token, \"reference\");\r\n\r\n        var reference = token;\r\n        ifBlock(null, function parseExtension_block(token) {\r\n            switch (token) {\r\n\r\n                case \"required\":\r\n                case \"repeated\":\r\n                    parseField(parent, token, reference);\r\n                    break;\r\n\r\n                case \"optional\":\r\n                    /* istanbul ignore if */\r\n                    if (isProto3) {\r\n                        parseField(parent, \"proto3_optional\", reference);\r\n                    } else {\r\n                        parseField(parent, \"optional\", reference);\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    /* istanbul ignore if */\r\n                    if (!isProto3 || !typeRefRe.test(token))\r\n                        throw illegal(token);\r\n                    push(token);\r\n                    parseField(parent, \"optional\", reference);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    var token;\r\n    while ((token = next()) !== null) {\r\n        switch (token) {\r\n\r\n            case \"package\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parsePackage();\r\n                break;\r\n\r\n            case \"import\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseImport();\r\n                break;\r\n\r\n            case \"syntax\":\r\n\r\n                /* istanbul ignore if */\r\n                if (!head)\r\n                    throw illegal(token);\r\n\r\n                parseSyntax();\r\n                break;\r\n\r\n            case \"option\":\r\n\r\n                parseOption(ptr, token);\r\n                skip(\";\");\r\n                break;\r\n\r\n            default:\r\n\r\n                /* istanbul ignore else */\r\n                if (parseCommon(ptr, token)) {\r\n                    head = false;\r\n                    continue;\r\n                }\r\n\r\n                /* istanbul ignore next */\r\n                throw illegal(token);\r\n        }\r\n    }\r\n\r\n    parse.filename = null;\r\n    return {\r\n        \"package\"     : pkg,\r\n        \"imports\"     : imports,\r\n         weakImports  : weakImports,\r\n         syntax       : syntax,\r\n         root         : root\r\n    };\r\n}\r\n\r\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @name parse\r\n * @function\r\n * @param {string} source Source contents\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n * @variation 2\r\n */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBWTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBUTtBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBUTtBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBWTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBUTtBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlLHNDQUFzQyxzQkFBc0I7QUFDdEYsYUFBYSxlQUFlO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGVBQWUsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDBDQUEwQztBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsbUJBQW1CO0FBQ25CLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVCQUF1QjtBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx1Q0FBdUM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZSxzQ0FBc0Msc0JBQXNCO0FBQ3RGLGFBQWEsZUFBZTtBQUM1QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlLGtCQUFrQjtBQUMvQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3BhcnNlLmpzPzEwYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XHJcblxyXG5wYXJzZS5maWxlbmFtZSA9IG51bGw7XHJcbnBhcnNlLmRlZmF1bHRzID0geyBrZWVwQ2FzZTogZmFsc2UgfTtcclxuXHJcbnZhciB0b2tlbml6ZSAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKSxcclxuICAgIFJvb3QgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIiksXHJcbiAgICBUeXBlICAgICAgPSByZXF1aXJlKFwiLi90eXBlXCIpLFxyXG4gICAgRmllbGQgICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXHJcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcclxuICAgIE9uZU9mICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxyXG4gICAgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcclxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXHJcbiAgICBNZXRob2QgICAgPSByZXF1aXJlKFwiLi9tZXRob2RcIiksXHJcbiAgICB0eXBlcyAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcclxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcblxyXG52YXIgYmFzZTEwUmUgICAgPSAvXlsxLTldWzAtOV0qJC8sXHJcbiAgICBiYXNlMTBOZWdSZSA9IC9eLT9bMS05XVswLTldKiQvLFxyXG4gICAgYmFzZTE2UmUgICAgPSAvXjBbeF1bMC05YS1mQS1GXSskLyxcclxuICAgIGJhc2UxNk5lZ1JlID0gL14tPzBbeF1bMC05YS1mQS1GXSskLyxcclxuICAgIGJhc2U4UmUgICAgID0gL14wWzAtN10rJC8sXHJcbiAgICBiYXNlOE5lZ1JlICA9IC9eLT8wWzAtN10rJC8sXHJcbiAgICBudW1iZXJSZSAgICA9IC9eKD8hW2VFXSlbMC05XSooPzpcXC5bMC05XSopPyg/OltlRV1bKy1dP1swLTldKyk/JC8sXHJcbiAgICBuYW1lUmUgICAgICA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvLFxyXG4gICAgdHlwZVJlZlJlICAgPSAvXig/OlxcLj9bYS16QS1aX11bYS16QS1aXzAtOV0qKSg/OlxcLlthLXpBLVpfXVthLXpBLVpfMC05XSopKiQvLFxyXG4gICAgZnFUeXBlUmVmUmUgPSAvXig/OlxcLlthLXpBLVpfXVthLXpBLVpfMC05XSopKyQvO1xyXG5cclxuLyoqXHJcbiAqIFJlc3VsdCBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgcGFyc2V9LlxyXG4gKiBAaW50ZXJmYWNlIElQYXJzZXJSZXN1bHRcclxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYWNrYWdlIFBhY2thZ2UgbmFtZSwgaWYgZGVjbGFyZWRcclxuICogQHByb3BlcnR5IHtzdHJpbmdbXXx1bmRlZmluZWR9IGltcG9ydHMgSW1wb3J0cywgaWYgYW55XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW118dW5kZWZpbmVkfSB3ZWFrSW1wb3J0cyBXZWFrIGltcG9ydHMsIGlmIGFueVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHN5bnRheCBTeW50YXgsIGlmIHNwZWNpZmllZCAoZWl0aGVyIGBcInByb3RvMlwiYCBvciBgXCJwcm90bzNcImApXHJcbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBQb3B1bGF0ZWQgcm9vdCBpbnN0YW5jZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb2Yge0BsaW5rIHBhcnNlfS5cclxuICogQGludGVyZmFjZSBJUGFyc2VPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlZXBDYXNlPWZhbHNlXSBLZWVwcyBmaWVsZCBjYXNpbmcgaW5zdGVhZCBvZiBjb252ZXJ0aW5nIHRvIGNhbWVsIGNhc2VcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWx0ZXJuYXRlQ29tbWVudE1vZGU9ZmFsc2VdIFJlY29nbml6ZSBkb3VibGUtc2xhc2ggY29tbWVudHMgaW4gYWRkaXRpb24gdG8gZG9jLWJsb2NrIGNvbW1lbnRzLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmVmZXJUcmFpbGluZ0NvbW1lbnQ9ZmFsc2VdIFVzZSB0cmFpbGluZyBjb21tZW50IHdoZW4gYm90aCBsZWFkaW5nIGNvbW1lbnQgYW5kIHRyYWlsaW5nIGNvbW1lbnQgZXhpc3QuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiBKU09OIHNlcmlhbGl6YXRpb24uXHJcbiAqIEBpbnRlcmZhY2UgSVRvSlNPTk9wdGlvbnNcclxuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcENvbW1lbnRzPWZhbHNlXSBTZXJpYWxpemVzIGNvbW1lbnRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgY29udGVudHNcclxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgdG8gcG9wdWxhdGVcclxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHtJUGFyc2VyUmVzdWx0fSBQYXJzZXIgcmVzdWx0XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlbmFtZT1udWxsIEN1cnJlbnRseSBwcm9jZXNzaW5nIGZpbGUgbmFtZSBmb3IgZXJyb3IgcmVwb3J0aW5nLCBpZiBrbm93blxyXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZShzb3VyY2UsIHJvb3QsIG9wdGlvbnMpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbGxiYWNrLXJldHVybiAqL1xyXG4gICAgaWYgKCEocm9vdCBpbnN0YW5jZW9mIFJvb3QpKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHJvb3Q7XHJcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlLmRlZmF1bHRzO1xyXG5cclxuICAgIHZhciBwcmVmZXJUcmFpbGluZ0NvbW1lbnQgPSBvcHRpb25zLnByZWZlclRyYWlsaW5nQ29tbWVudCB8fCBmYWxzZTtcclxuICAgIHZhciB0biA9IHRva2VuaXplKHNvdXJjZSwgb3B0aW9ucy5hbHRlcm5hdGVDb21tZW50TW9kZSB8fCBmYWxzZSksXHJcbiAgICAgICAgbmV4dCA9IHRuLm5leHQsXHJcbiAgICAgICAgcHVzaCA9IHRuLnB1c2gsXHJcbiAgICAgICAgcGVlayA9IHRuLnBlZWssXHJcbiAgICAgICAgc2tpcCA9IHRuLnNraXAsXHJcbiAgICAgICAgY21udCA9IHRuLmNtbnQ7XHJcblxyXG4gICAgdmFyIGhlYWQgPSB0cnVlLFxyXG4gICAgICAgIHBrZyxcclxuICAgICAgICBpbXBvcnRzLFxyXG4gICAgICAgIHdlYWtJbXBvcnRzLFxyXG4gICAgICAgIHN5bnRheCxcclxuICAgICAgICBpc1Byb3RvMyA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBwdHIgPSByb290O1xyXG5cclxuICAgIHZhciBhcHBseUNhc2UgPSBvcHRpb25zLmtlZXBDYXNlID8gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gbmFtZTsgfSA6IHV0aWwuY2FtZWxDYXNlO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBmdW5jdGlvbiBpbGxlZ2FsKHRva2VuLCBuYW1lLCBpbnNpZGVUcnlDYXRjaCkge1xyXG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xyXG4gICAgICAgIGlmICghaW5zaWRlVHJ5Q2F0Y2gpXHJcbiAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gRXJyb3IoXCJpbGxlZ2FsIFwiICsgKG5hbWUgfHwgXCJ0b2tlblwiKSArIFwiICdcIiArIHRva2VuICsgXCInIChcIiArIChmaWxlbmFtZSA/IGZpbGVuYW1lICsgXCIsIFwiIDogXCJcIikgKyBcImxpbmUgXCIgKyB0bi5saW5lICsgXCIpXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdLFxyXG4gICAgICAgICAgICB0b2tlbjtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHRva2VuID0gbmV4dCgpKSAhPT0gXCJcXFwiXCIgJiYgdG9rZW4gIT09IFwiJ1wiKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XHJcblxyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuZXh0KCkpO1xyXG4gICAgICAgICAgICBza2lwKHRva2VuKTtcclxuICAgICAgICAgICAgdG9rZW4gPSBwZWVrKCk7XHJcbiAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIik7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWRWYWx1ZShhY2NlcHRUeXBlUmVmKSB7XHJcbiAgICAgICAgdmFyIHRva2VuID0gbmV4dCgpO1xyXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgY2FzZSBcIidcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlxcXCJcIjpcclxuICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgY2FzZSBcInRydWVcIjogY2FzZSBcIlRSVUVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogY2FzZSBcIkZBTFNFXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlcih0b2tlbiwgLyogaW5zaWRlVHJ5Q2F0Y2ggKi8gdHJ1ZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG5cclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKGFjY2VwdFR5cGVSZWYgJiYgdHlwZVJlZlJlLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJ2YWx1ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZFJhbmdlcyh0YXJnZXQsIGFjY2VwdFN0cmluZ3MpIHtcclxuICAgICAgICB2YXIgdG9rZW4sIHN0YXJ0O1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKGFjY2VwdFN0cmluZ3MgJiYgKCh0b2tlbiA9IHBlZWsoKSkgPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIikpXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChyZWFkU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChbIHN0YXJ0ID0gcGFyc2VJZChuZXh0KCkpLCBza2lwKFwidG9cIiwgdHJ1ZSkgPyBwYXJzZUlkKG5leHQoKSkgOiBzdGFydCBdKTtcclxuICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XHJcbiAgICAgICAgdmFyIGR1bW15ID0ge29wdGlvbnM6IHVuZGVmaW5lZH07XHJcbiAgICAgICAgZHVtbXkuc2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgPT09IHVuZGVmaW5lZCkgdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmQmxvY2soXHJcbiAgICAgICAgICAgIGR1bW15LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVJhbmdlX2Jsb2NrKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGR1bW15LCB0b2tlbik7ICAvLyBza2lwXHJcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVJhbmdlX2xpbmUoKSB7XHJcbiAgICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGR1bW15KTsgIC8vIHNraXBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VOdW1iZXIodG9rZW4sIGluc2lkZVRyeUNhdGNoKSB7XHJcbiAgICAgICAgdmFyIHNpZ24gPSAxO1xyXG4gICAgICAgIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgY2FzZSBcImluZlwiOiBjYXNlIFwiSU5GXCI6IGNhc2UgXCJJbmZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJuYW5cIjogY2FzZSBcIk5BTlwiOiBjYXNlIFwiTmFuXCI6IGNhc2UgXCJOYU5cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UxMFJlLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCAxMCk7XHJcbiAgICAgICAgaWYgKGJhc2UxNlJlLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCAxNik7XHJcbiAgICAgICAgaWYgKGJhc2U4UmUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDgpO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgIGlmIChudW1iZXJSZS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHRva2VuKTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm51bWJlclwiLCBpbnNpZGVUcnlDYXRjaCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VJZCh0b2tlbiwgYWNjZXB0TmVnYXRpdmUpIHtcclxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjogY2FzZSBcIk1BWFwiOiBjYXNlIFwiTWF4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNTM2ODcwOTExO1xyXG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIWFjY2VwdE5lZ2F0aXZlICYmIHRva2VuLmNoYXJBdCgwKSA9PT0gXCItXCIpXHJcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiaWRcIik7XHJcblxyXG4gICAgICAgIGlmIChiYXNlMTBOZWdSZS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCAxMCk7XHJcbiAgICAgICAgaWYgKGJhc2UxNk5lZ1JlLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDE2KTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICBpZiAoYmFzZThOZWdSZS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCA4KTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcImlkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlUGFja2FnZSgpIHtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHBrZyAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwicGFja2FnZVwiKTtcclxuXHJcbiAgICAgICAgcGtnID0gbmV4dCgpO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHBrZykpXHJcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwocGtnLCBcIm5hbWVcIik7XHJcblxyXG4gICAgICAgIHB0ciA9IHB0ci5kZWZpbmUocGtnKTtcclxuICAgICAgICBza2lwKFwiO1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydCgpIHtcclxuICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XHJcbiAgICAgICAgdmFyIHdoaWNoSW1wb3J0cztcclxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWFrXCI6XHJcbiAgICAgICAgICAgICAgICB3aGljaEltcG9ydHMgPSB3ZWFrSW1wb3J0cyB8fCAod2Vha0ltcG9ydHMgPSBbXSk7XHJcbiAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxyXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB3aGljaEltcG9ydHMgPSBpbXBvcnRzIHx8IChpbXBvcnRzID0gW10pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuID0gcmVhZFN0cmluZygpO1xyXG4gICAgICAgIHNraXAoXCI7XCIpO1xyXG4gICAgICAgIHdoaWNoSW1wb3J0cy5wdXNoKHRva2VuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVN5bnRheCgpIHtcclxuICAgICAgICBza2lwKFwiPVwiKTtcclxuICAgICAgICBzeW50YXggPSByZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgaXNQcm90bzMgPSBzeW50YXggPT09IFwicHJvdG8zXCI7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghaXNQcm90bzMgJiYgc3ludGF4ICE9PSBcInByb3RvMlwiKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHN5bnRheCwgXCJzeW50YXhcIik7XHJcblxyXG4gICAgICAgIHNraXAoXCI7XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tbW9uKHBhcmVudCwgdG9rZW4pIHtcclxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwYXJlbnQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VUeXBlKHBhcmVudCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwic2VydmljZVwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiZXh0ZW5kXCI6XHJcbiAgICAgICAgICAgICAgICBwYXJzZUV4dGVuc2lvbihwYXJlbnQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaWZCbG9jayhvYmosIGZuSWYsIGZuRWxzZSkge1xyXG4gICAgICAgIHZhciB0cmFpbGluZ0xpbmUgPSB0bi5saW5lO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgaWYodHlwZW9mIG9iai5jb21tZW50ICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KCk7IC8vIHRyeSBibG9jay10eXBlIGNvbW1lbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmouZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNraXAoXCJ7XCIsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IFwifVwiKVxyXG4gICAgICAgICAgICAgICAgZm5JZih0b2tlbik7XHJcbiAgICAgICAgICAgIHNraXAoXCI7XCIsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChmbkVsc2UpXHJcbiAgICAgICAgICAgICAgICBmbkVsc2UoKTtcclxuICAgICAgICAgICAgc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgIGlmIChvYmogJiYgKHR5cGVvZiBvYmouY29tbWVudCAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmZXJUcmFpbGluZ0NvbW1lbnQpKVxyXG4gICAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KHRyYWlsaW5nTGluZSkgfHwgb2JqLmNvbW1lbnQ7IC8vIHRyeSBsaW5lLXR5cGUgY29tbWVudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVR5cGUocGFyZW50LCB0b2tlbikge1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJ0eXBlIG5hbWVcIik7XHJcblxyXG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUodG9rZW4pO1xyXG4gICAgICAgIGlmQmxvY2sodHlwZSwgZnVuY3Rpb24gcGFyc2VUeXBlX2Jsb2NrKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbih0eXBlLCB0b2tlbikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTWFwRmllbGQodHlwZSwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvdG8zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJwcm90bzNfb3B0aW9uYWxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZU9uZU9mKHR5cGUsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXh0ZW5zaW9uc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5leHRlbnNpb25zIHx8ICh0eXBlLmV4dGVuc2lvbnMgPSBbXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5yZXNlcnZlZCB8fCAodHlwZS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvdG8zIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXJlbnQuYWRkKHR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlRmllbGQocGFyZW50LCBydWxlLCBleHRlbmQpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IG5leHQoKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gXCJncm91cFwiKSB7XHJcbiAgICAgICAgICAgIHBhcnNlR3JvdXAocGFyZW50LCBydWxlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUeXBlIG5hbWVzIGNhbiBjb25zdW1lIG11bHRpcGxlIHRva2VucywgaW4gbXVsdGlwbGUgdmFyaWFudHM6XHJcbiAgICAgICAgLy8gICAgcGFja2FnZS5zdWJwYWNrYWdlICAgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2Uuc3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcclxuICAgICAgICAvLyAgICBwYWNrYWdlIC4gc3VicGFja2FnZSBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZVwiIFwiLlwiIFwic3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcclxuICAgICAgICAvLyAgICBwYWNrYWdlLiAgc3VicGFja2FnZSBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZS5cIiBcInN1YnBhY2thZ2VcIiBbVFlQRSBOQU1FIEVORFMgSEVSRV0gXCJmaWVsZFwiXHJcbiAgICAgICAgLy8gICAgcGFja2FnZSAgLnN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2VcIiBcIi5zdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxyXG4gICAgICAgIC8vIEtlZXAgcmVhZGluZyB0b2tlbnMgdW50aWwgd2UgZ2V0IGEgdHlwZSBuYW1lIHdpdGggbm8gcGVyaW9kIGF0IHRoZSBlbmQsXHJcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHRva2VuIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBwZXJpb2QuXHJcbiAgICAgICAgd2hpbGUgKHR5cGUuZW5kc1dpdGgoXCIuXCIpIHx8IHBlZWsoKS5zdGFydHNXaXRoKFwiLlwiKSkge1xyXG4gICAgICAgICAgICB0eXBlICs9IG5leHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodHlwZSkpXHJcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodHlwZSwgXCJ0eXBlXCIpO1xyXG5cclxuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XHJcblxyXG4gICAgICAgIG5hbWUgPSBhcHBseUNhc2UobmFtZSk7XHJcbiAgICAgICAgc2tpcChcIj1cIik7XHJcblxyXG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChuYW1lLCBwYXJzZUlkKG5leHQoKSksIHR5cGUsIHJ1bGUsIGV4dGVuZCk7XHJcbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VGaWVsZF9ibG9jayh0b2tlbikge1xyXG5cclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihmaWVsZCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XHJcblxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRmllbGRfbGluZSgpIHtcclxuICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGZpZWxkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJ1bGUgPT09IFwicHJvdG8zX29wdGlvbmFsXCIpIHtcclxuICAgICAgICAgICAgLy8gZm9yIHByb3RvMyBvcHRpb25hbCBmaWVsZHMsIHdlIGNyZWF0ZSBhIHNpbmdsZS1tZW1iZXIgT25lb2YgdG8gbWltaWMgXCJvcHRpb25hbFwiIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIHZhciBvbmVvZiA9IG5ldyBPbmVPZihcIl9cIiArIG5hbWUpO1xyXG4gICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwcm90bzNfb3B0aW9uYWxcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG9uZW9mLmFkZChmaWVsZCk7XHJcbiAgICAgICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5hZGQoZmllbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSlNPTiBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSBpZiBub3Qgc2V0IHNvIHdlIGhhdmUgdG8gc2V0IHBhY2tlZD1mYWxzZSBleHBsaWNpdHkgd2hlblxyXG4gICAgICAgIC8vIHBhcnNpbmcgcHJvdG8yIGRlc2NyaXB0b3JzIHdpdGhvdXQgdGhlIG9wdGlvbiwgd2hlcmUgYXBwbGljYWJsZS4gVGhpcyBtdXN0IGJlIGRvbmUgZm9yXHJcbiAgICAgICAgLy8gYWxsIGtub3duIHBhY2thYmxlIHR5cGVzIGFuZCBhbnl0aGluZyB0aGF0IGNvdWxkIGJlIGFuIGVudW0gKD0gaXMgbm90IGEgYmFzaWMgdHlwZSkuXHJcbiAgICAgICAgaWYgKCFpc1Byb3RvMyAmJiBmaWVsZC5yZXBlYXRlZCAmJiAodHlwZXMucGFja2VkW3R5cGVdICE9PSB1bmRlZmluZWQgfHwgdHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkpXHJcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInBhY2tlZFwiLCBmYWxzZSwgLyogaWZOb3RTZXQgKi8gdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XHJcblxyXG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSB1dGlsLmxjRmlyc3QobmFtZSk7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IGZpZWxkTmFtZSlcclxuICAgICAgICAgICAgbmFtZSA9IHV0aWwudWNGaXJzdChuYW1lKTtcclxuICAgICAgICBza2lwKFwiPVwiKTtcclxuICAgICAgICB2YXIgaWQgPSBwYXJzZUlkKG5leHQoKSk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lKTtcclxuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQoZmllbGROYW1lLCBpZCwgbmFtZSwgcnVsZSk7XHJcbiAgICAgICAgZmllbGQuZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcclxuICAgICAgICBpZkJsb2NrKHR5cGUsIGZ1bmN0aW9uIHBhcnNlR3JvdXBfYmxvY2sodG9rZW4pIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbih0eXBlLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcclxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm90bzMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcInByb3RvM19vcHRpb25hbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VUeXBlKHR5cGUsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW51bSh0eXBlLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7IC8vIHRoZXJlIGFyZSBubyBncm91cHMgd2l0aCBwcm90bzMgc2VtYW50aWNzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXJlbnQuYWRkKHR5cGUpXHJcbiAgICAgICAgICAgICAgLmFkZChmaWVsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZChwYXJlbnQpIHtcclxuICAgICAgICBza2lwKFwiPFwiKTtcclxuICAgICAgICB2YXIga2V5VHlwZSA9IG5leHQoKTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHR5cGVzLm1hcEtleVtrZXlUeXBlXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKGtleVR5cGUsIFwidHlwZVwiKTtcclxuXHJcbiAgICAgICAgc2tpcChcIixcIik7XHJcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IG5leHQoKTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh2YWx1ZVR5cGUpKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHZhbHVlVHlwZSwgXCJ0eXBlXCIpO1xyXG5cclxuICAgICAgICBza2lwKFwiPlwiKTtcclxuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XHJcblxyXG4gICAgICAgIHNraXAoXCI9XCIpO1xyXG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBNYXBGaWVsZChhcHBseUNhc2UobmFtZSksIHBhcnNlSWQobmV4dCgpKSwga2V5VHlwZSwgdmFsdWVUeXBlKTtcclxuICAgICAgICBpZkJsb2NrKGZpZWxkLCBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkX2Jsb2NrKHRva2VuKSB7XHJcblxyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcclxuXHJcbiAgICAgICAgfSwgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZF9saW5lKCkge1xyXG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhcmVudC5hZGQoZmllbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlT25lT2YocGFyZW50LCB0b2tlbikge1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xyXG5cclxuICAgICAgICB2YXIgb25lb2YgPSBuZXcgT25lT2YoYXBwbHlDYXNlKHRva2VuKSk7XHJcbiAgICAgICAgaWZCbG9jayhvbmVvZiwgZnVuY3Rpb24gcGFyc2VPbmVPZl9ibG9jayh0b2tlbikge1xyXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKG9uZW9mLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VGaWVsZChvbmVvZiwgXCJvcHRpb25hbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bShwYXJlbnQsIHRva2VuKSB7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XHJcblxyXG4gICAgICAgIHZhciBlbm0gPSBuZXcgRW51bSh0b2tlbik7XHJcbiAgICAgICAgaWZCbG9jayhlbm0sIGZ1bmN0aW9uIHBhcnNlRW51bV9ibG9jayh0b2tlbikge1xyXG4gICAgICAgICAgc3dpdGNoKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcclxuICAgICAgICAgICAgICBwYXJzZU9wdGlvbihlbm0sIHRva2VuKTtcclxuICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxyXG4gICAgICAgICAgICAgIHJlYWRSYW5nZXMoZW5tLnJlc2VydmVkIHx8IChlbm0ucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBwYXJzZUVudW1WYWx1ZShlbm0sIHRva2VuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXJlbnQuYWRkKGVubSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWUocGFyZW50LCB0b2tlbikge1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xyXG5cclxuICAgICAgICBza2lwKFwiPVwiKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUlkKG5leHQoKSwgdHJ1ZSksXHJcbiAgICAgICAgICAgIGR1bW15ID0ge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgZHVtbXkuc2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWZCbG9jayhkdW1teSwgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVfYmxvY2sodG9rZW4pIHtcclxuXHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZHVtbXksIHRva2VuKTsgLy8gc2tpcFxyXG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XHJcblxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlX2xpbmUoKSB7XHJcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhkdW1teSk7IC8vIHNraXBcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXJlbnQuYWRkKHRva2VuLCB2YWx1ZSwgZHVtbXkuY29tbWVudCwgZHVtbXkub3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb24ocGFyZW50LCB0b2tlbikge1xyXG4gICAgICAgIHZhciBpc0N1c3RvbSA9IHNraXAoXCIoXCIsIHRydWUpO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xyXG5cclxuICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgIHZhciBvcHRpb24gPSBuYW1lO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGlzQ3VzdG9tKSB7XHJcbiAgICAgICAgICAgIHNraXAoXCIpXCIpO1xyXG4gICAgICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpXCI7XHJcbiAgICAgICAgICAgIG9wdGlvbiA9IG5hbWU7XHJcbiAgICAgICAgICAgIHRva2VuID0gcGVlaygpO1xyXG4gICAgICAgICAgICBpZiAoZnFUeXBlUmVmUmUudGVzdCh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIHByb3BOYW1lID0gdG9rZW4uc2xpY2UoMSk7IC8vcmVtb3ZlICcuJyBiZWZvcmUgcHJvcGVydHkgbmFtZVxyXG4gICAgICAgICAgICAgICAgbmFtZSArPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBza2lwKFwiPVwiKTtcclxuICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSk7XHJcbiAgICAgICAgc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgb3B0aW9uLCBvcHRpb25WYWx1ZSwgcHJvcE5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKSB7XHJcbiAgICAgICAgLy8geyBhOiBcImZvb1wiIGIgeyBjOiBcImJhclwiIH0gfVxyXG4gICAgICAgIGlmIChza2lwKFwie1wiLCB0cnVlKSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0UmVzdWx0ID0ge307XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoIXNraXAoXCJ9XCIsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiZW5kIG9mIGlucHV0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHRva2VuO1xyXG5cclxuICAgICAgICAgICAgICAgIHNraXAoXCI6XCIsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwie1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gXCJbXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb24gKG15X29wdGlvbikgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJlcGVhdGVkX3ZhbHVlOiBbIFwiZm9vXCIsIFwiYmFyXCIgXVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwKFwiW1wiLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGxhc3RWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcChcIl1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24ocGFyZW50LCBuYW1lICsgXCIuXCIgKyB0b2tlbiwgbGFzdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gb2JqZWN0UmVzdWx0W3Byb3BOYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KHByZXZWYWx1ZSkuY29uY2F0KHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvYmplY3RSZXN1bHRbcHJvcE5hbWVdID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VtaWNvbG9ucyBhbmQgY29tbWFzIGNhbiBiZSBvcHRpb25hbFxyXG4gICAgICAgICAgICAgICAgc2tpcChcIixcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaW1wbGVWYWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcclxuICAgICAgICBzZXRPcHRpb24ocGFyZW50LCBuYW1lLCBzaW1wbGVWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHNpbXBsZVZhbHVlO1xyXG4gICAgICAgIC8vIERvZXMgbm90IGVuZm9yY2UgYSBkZWxpbWl0ZXIgdG8gYmUgdW5pdmVyc2FsXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAocGFyZW50LnNldE9wdGlvbilcclxuICAgICAgICAgICAgcGFyZW50LnNldE9wdGlvbihuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudC5zZXRQYXJzZWRPcHRpb24pXHJcbiAgICAgICAgICAgIHBhcmVudC5zZXRQYXJzZWRPcHRpb24obmFtZSwgdmFsdWUsIHByb3BOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUlubGluZU9wdGlvbnMocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHNraXAoXCJbXCIsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHBhcmVudCwgXCJvcHRpb25cIik7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcclxuICAgICAgICAgICAgc2tpcChcIl1cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pIHtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXHJcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwic2VydmljZSBuYW1lXCIpO1xyXG5cclxuICAgICAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKHRva2VuKTtcclxuICAgICAgICBpZkJsb2NrKHNlcnZpY2UsIGZ1bmN0aW9uIHBhcnNlU2VydmljZV9ibG9jayh0b2tlbikge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VDb21tb24oc2VydmljZSwgdG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcInJwY1wiKVxyXG4gICAgICAgICAgICAgICAgcGFyc2VNZXRob2Qoc2VydmljZSwgdG9rZW4pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXJlbnQuYWRkKHNlcnZpY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTWV0aG9kKHBhcmVudCwgdG9rZW4pIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGNvbW1lbnQgb2YgdGhlIHByZWNlZGluZyBsaW5lIG5vdyAoaWYgb25lIGV4aXN0cykgaW4gY2FzZSB0aGVcclxuICAgICAgICAvLyBtZXRob2QgaXMgZGVmaW5lZCBhY3Jvc3MgbXVsdGlwbGUgbGluZXMuXHJcbiAgICAgICAgdmFyIGNvbW1lbnRUZXh0ID0gY21udCgpO1xyXG5cclxuICAgICAgICB2YXIgdHlwZSA9IHRva2VuO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xyXG5cclxuICAgICAgICB2YXIgbmFtZSA9IHRva2VuLFxyXG4gICAgICAgICAgICByZXF1ZXN0VHlwZSwgcmVxdWVzdFN0cmVhbSxcclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlLCByZXNwb25zZVN0cmVhbTtcclxuXHJcbiAgICAgICAgc2tpcChcIihcIik7XHJcbiAgICAgICAgaWYgKHNraXAoXCJzdHJlYW1cIiwgdHJ1ZSkpXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0gPSB0cnVlO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XHJcblxyXG4gICAgICAgIHJlcXVlc3RUeXBlID0gdG9rZW47XHJcbiAgICAgICAgc2tpcChcIilcIik7IHNraXAoXCJyZXR1cm5zXCIpOyBza2lwKFwiKFwiKTtcclxuICAgICAgICBpZiAoc2tpcChcInN0cmVhbVwiLCB0cnVlKSlcclxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSB0cnVlO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcclxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XHJcblxyXG4gICAgICAgIHJlc3BvbnNlVHlwZSA9IHRva2VuO1xyXG4gICAgICAgIHNraXAoXCIpXCIpO1xyXG5cclxuICAgICAgICB2YXIgbWV0aG9kID0gbmV3IE1ldGhvZChuYW1lLCB0eXBlLCByZXF1ZXN0VHlwZSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0U3RyZWFtLCByZXNwb25zZVN0cmVhbSk7XHJcbiAgICAgICAgbWV0aG9kLmNvbW1lbnQgPSBjb21tZW50VGV4dDtcclxuICAgICAgICBpZkJsb2NrKG1ldGhvZCwgZnVuY3Rpb24gcGFyc2VNZXRob2RfYmxvY2sodG9rZW4pIHtcclxuXHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24obWV0aG9kLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGFyZW50LmFkZChtZXRob2QpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pIHtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXHJcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwicmVmZXJlbmNlXCIpO1xyXG5cclxuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdG9rZW47XHJcbiAgICAgICAgaWZCbG9jayhudWxsLCBmdW5jdGlvbiBwYXJzZUV4dGVuc2lvbl9ibG9jayh0b2tlbikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgdG9rZW4sIHJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvdG8zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcInByb3RvM19vcHRpb25hbFwiLCByZWZlcmVuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcIm9wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb3RvMyB8fCAhdHlwZVJlZlJlLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgXCJvcHRpb25hbFwiLCByZWZlcmVuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IG51bGwpIHtcclxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwicGFja2FnZVwiOlxyXG5cclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlUGFja2FnZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XHJcblxyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgcGFyc2VJbXBvcnQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxyXG5cclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlU3ludGF4KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwdHIsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VDb21tb24ocHRyLCB0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwYXJzZS5maWxlbmFtZSA9IG51bGw7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFwicGFja2FnZVwiICAgICA6IHBrZyxcclxuICAgICAgICBcImltcG9ydHNcIiAgICAgOiBpbXBvcnRzLFxyXG4gICAgICAgICB3ZWFrSW1wb3J0cyAgOiB3ZWFrSW1wb3J0cyxcclxuICAgICAgICAgc3ludGF4ICAgICAgIDogc3ludGF4LFxyXG4gICAgICAgICByb290ICAgICAgICAgOiByb290XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgY29udGVudHMuXHJcbiAqIEBuYW1lIHBhcnNlXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xyXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cclxuICogQHJldHVybnMge0lQYXJzZXJSZXN1bHR9IFBhcnNlciByZXN1bHRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXHJcbiAqIEBwcm9wZXJ0eSB7SVBhcnNlT3B0aW9uc30gZGVmYXVsdHMgRGVmYXVsdCB7QGxpbmsgSVBhcnNlT3B0aW9uc31cclxuICogQHZhcmlhdGlvbiAyXHJcbiAqL1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Reader;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferReader; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    utf8      = util.utf8;\r\n\r\n/* istanbul ignore next */\r\nfunction indexOutOfRange(reader, writeLength) {\r\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\r\n}\r\n\r\n/**\r\n * Constructs a new reader instance using the specified buffer.\r\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n * @param {Uint8Array} buffer Buffer to read from\r\n */\r\nfunction Reader(buffer) {\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @type {Uint8Array}\r\n     */\r\n    this.buf = buffer;\r\n\r\n    /**\r\n     * Read buffer position.\r\n     * @type {number}\r\n     */\r\n    this.pos = 0;\r\n\r\n    /**\r\n     * Read buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = buffer.length;\r\n}\r\n\r\nvar create_array = typeof Uint8Array !== \"undefined\"\r\n    ? function create_typed_array(buffer) {\r\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array(buffer) {\r\n        if (Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    };\r\n\r\nvar create = function create() {\r\n    return util.Buffer\r\n        ? function create_buffer_setup(buffer) {\r\n            return (Reader.create = function create_buffer(buffer) {\r\n                return util.Buffer.isBuffer(buffer)\r\n                    ? new BufferReader(buffer)\r\n                    /* istanbul ignore next */\r\n                    : create_array(buffer);\r\n            })(buffer);\r\n        }\r\n        /* istanbul ignore next */\r\n        : create_array;\r\n};\r\n\r\n/**\r\n * Creates a new reader using the specified buffer.\r\n * @function\r\n * @param {Uint8Array|Buffer} buffer Buffer to read from\r\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\r\n * @throws {Error} If `buffer` is not a valid buffer\r\n */\r\nReader.create = create();\r\n\r\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\r\n\r\n/**\r\n * Reads a varint as an unsigned 32 bit value.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.uint32 = (function read_uint32_setup() {\r\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\r\n    return function read_uint32() {\r\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n\r\n        /* istanbul ignore if */\r\n        if ((this.pos += 5) > this.len) {\r\n            this.pos = this.len;\r\n            throw indexOutOfRange(this, 10);\r\n        }\r\n        return value;\r\n    };\r\n})();\r\n\r\n/**\r\n * Reads a varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.int32 = function read_int32() {\r\n    return this.uint32() | 0;\r\n};\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sint32 = function read_sint32() {\r\n    var value = this.uint32();\r\n    return value >>> 1 ^ -(value & 1) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readLongVarint() {\r\n    // tends to deopt with local vars for octet etc.\r\n    var bits = new LongBits(0, 0);\r\n    var i = 0;\r\n    if (this.len - this.pos > 4) { // fast route (lo)\r\n        for (; i < 4; ++i) {\r\n            // 1st..4th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 5th\r\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\r\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\r\n        if (this.buf[this.pos++] < 128)\r\n            return bits;\r\n        i = 0;\r\n    } else {\r\n        for (; i < 3; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 1st..3th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 4th\r\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\r\n        return bits;\r\n    }\r\n    if (this.len - this.pos > 4) { // fast route (hi)\r\n        for (; i < 5; ++i) {\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    } else {\r\n        for (; i < 5; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    }\r\n    /* istanbul ignore next */\r\n    throw Error(\"invalid varint encoding\");\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads a varint as a signed 64 bit value.\r\n * @name Reader#int64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as an unsigned 64 bit value.\r\n * @name Reader#uint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 64 bit value.\r\n * @name Reader#sint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as a boolean.\r\n * @returns {boolean} Value read\r\n */\r\nReader.prototype.bool = function read_bool() {\r\n    return this.uint32() !== 0;\r\n};\r\n\r\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\r\n    return (buf[end - 4]\r\n          | buf[end - 3] << 8\r\n          | buf[end - 2] << 16\r\n          | buf[end - 1] << 24) >>> 0;\r\n}\r\n\r\n/**\r\n * Reads fixed 32 bits as an unsigned 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.fixed32 = function read_fixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4);\r\n};\r\n\r\n/**\r\n * Reads fixed 32 bits as a signed 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sfixed32 = function read_sfixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readFixed64(/* this: Reader */) {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 8);\r\n\r\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads fixed 64 bits.\r\n * @name Reader#fixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads zig-zag encoded fixed 64 bits.\r\n * @name Reader#sfixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a float (32 bit) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.float = function read_float() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readFloatLE(this.buf, this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a double (64 bit float) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.double = function read_double() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readDoubleLE(this.buf, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @returns {Uint8Array} Value read\r\n */\r\nReader.prototype.bytes = function read_bytes() {\r\n    var length = this.uint32(),\r\n        start  = this.pos,\r\n        end    = this.pos + length;\r\n\r\n    /* istanbul ignore if */\r\n    if (end > this.len)\r\n        throw indexOutOfRange(this, length);\r\n\r\n    this.pos += length;\r\n    if (Array.isArray(this.buf)) // plain array\r\n        return this.buf.slice(start, end);\r\n\r\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\r\n        var nativeBuffer = util.Buffer;\r\n        return nativeBuffer\r\n            ? nativeBuffer.alloc(0)\r\n            : new this.buf.constructor(0);\r\n    }\r\n    return this._slice.call(this.buf, start, end);\r\n};\r\n\r\n/**\r\n * Reads a string preceeded by its byte length as a varint.\r\n * @returns {string} Value read\r\n */\r\nReader.prototype.string = function read_string() {\r\n    var bytes = this.bytes();\r\n    return utf8.read(bytes, 0, bytes.length);\r\n};\r\n\r\n/**\r\n * Skips the specified number of bytes if specified, otherwise skips a varint.\r\n * @param {number} [length] Length if known, otherwise a varint is assumed\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skip = function skip(length) {\r\n    if (typeof length === \"number\") {\r\n        /* istanbul ignore if */\r\n        if (this.pos + length > this.len)\r\n            throw indexOutOfRange(this, length);\r\n        this.pos += length;\r\n    } else {\r\n        do {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n        } while (this.buf[this.pos++] & 128);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Skips the next element of the specified wire type.\r\n * @param {number} wireType Wire type received\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skipType = function(wireType) {\r\n    switch (wireType) {\r\n        case 0:\r\n            this.skip();\r\n            break;\r\n        case 1:\r\n            this.skip(8);\r\n            break;\r\n        case 2:\r\n            this.skip(this.uint32());\r\n            break;\r\n        case 3:\r\n            while ((wireType = this.uint32() & 7) !== 4) {\r\n                this.skipType(wireType);\r\n            }\r\n            break;\r\n        case 5:\r\n            this.skip(4);\r\n            break;\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\r\n    }\r\n    return this;\r\n};\r\n\r\nReader._configure = function(BufferReader_) {\r\n    BufferReader = BufferReader_;\r\n    Reader.create = create();\r\n    BufferReader._configure();\r\n\r\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\r\n    util.merge(Reader.prototype, {\r\n\r\n        int64: function read_int64() {\r\n            return readLongVarint.call(this)[fn](false);\r\n        },\r\n\r\n        uint64: function read_uint64() {\r\n            return readLongVarint.call(this)[fn](true);\r\n        },\r\n\r\n        sint64: function read_sint64() {\r\n            return readLongVarint.call(this).zzDecode()[fn](false);\r\n        },\r\n\r\n        fixed64: function read_fixed64() {\r\n            return readFixed64.call(this)[fn](true);\r\n        },\r\n\r\n        sfixed64: function read_sfixed64() {\r\n            return readFixed64.call(this)[fn](false);\r\n        }\r\n\r\n    });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNHQUFnQjtBQUN4QztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxxQkFBcUIsR0FBRyxvQkFBb0Isc0NBQXNDO0FBQy9GLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzPzNlMDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xyXG5cclxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xyXG5cclxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXHJcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xyXG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlci5cclxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3MgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xyXG59XHJcblxyXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcclxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcclxuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcclxuICAgIH07XHJcblxyXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXHJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcclxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgfSkoYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXHJcbiAqL1xyXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XHJcblxyXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xyXG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcclxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcclxuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcclxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xyXG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcclxufTtcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XHJcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cclxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxyXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXHJcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDV0aFxyXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcclxuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICBpID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcclxuICAgICAgICAgICAgLy8gMXN0Li4zdGhcclxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNHRoXHJcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXHJcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcclxuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXHJcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcclxuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXHJcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xyXG59XHJcblxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cclxuICogQG5hbWUgUmVhZGVyI2ludDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXHJcbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXHJcbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxyXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cclxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xyXG5cclxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XHJcbn07XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xyXG59XHJcblxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cclxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xyXG5cclxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcclxuICAgIHRoaXMucG9zICs9IDQ7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xyXG4gICAgdGhpcy5wb3MgKz0gODtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcclxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcclxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcclxuXHJcbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7IC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXHJcbiAgICAgICAgdmFyIG5hdGl2ZUJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xyXG4gICAgICAgIHJldHVybiBuYXRpdmVCdWZmZXJcclxuICAgICAgICAgICAgPyBuYXRpdmVCdWZmZXIuYWxsb2MoMClcclxuICAgICAgICAgICAgOiBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcclxuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcclxuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXHJcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcclxuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xyXG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcclxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcclxuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XHJcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xyXG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xyXG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcclxuXHJcbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xyXG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = BufferReader;\r\n\r\n// extends Reader\r\nvar Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\");\r\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs a new buffer reader instance.\r\n * @classdesc Wire format reader using node buffers.\r\n * @extends Reader\r\n * @constructor\r\n * @param {Buffer} buffer Buffer to read from\r\n */\r\nfunction BufferReader(buffer) {\r\n    Reader.call(this, buffer);\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @name BufferReader#buf\r\n     * @type {Buffer}\r\n     */\r\n}\r\n\r\nBufferReader._configure = function () {\r\n    /* istanbul ignore else */\r\n    if (util.Buffer)\r\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nBufferReader.prototype.string = function read_string_buffer() {\r\n    var len = this.uint32(); // modifies pos\r\n    return this.buf.utf8Slice\r\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\r\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @name BufferReader#bytes\r\n * @function\r\n * @returns {Buffer} Value read\r\n */\r\n\r\nBufferReader._configure();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywwRkFBVTtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNHQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanM/ODM4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XHJcblxyXG4vLyBleHRlbmRzIFJlYWRlclxyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xyXG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXHJcbiAqIEBleHRlbmRzIFJlYWRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqL1xyXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XHJcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIuXHJcbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXHJcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxyXG4gICAgICovXHJcbn1cclxuXHJcbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmICh1dGlsLkJ1ZmZlcilcclxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcclxuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcclxuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcclxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxyXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Root;\r\n\r\n// extends Namespace\r\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\r\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\r\n\r\nvar Field   = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"),\r\n    Enum    = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    OneOf   = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\"),\r\n    util    = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nvar Type,   // cyclic\r\n    parse,  // might be excluded\r\n    common; // \"\r\n\r\n/**\r\n * Constructs a new root namespace instance.\r\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {Object.<string,*>} [options] Top level options\r\n */\r\nfunction Root(options) {\r\n    Namespace.call(this, \"\", options);\r\n\r\n    /**\r\n     * Deferred extension fields.\r\n     * @type {Field[]}\r\n     */\r\n    this.deferred = [];\r\n\r\n    /**\r\n     * Resolved file names of loaded files.\r\n     * @type {string[]}\r\n     */\r\n    this.files = [];\r\n}\r\n\r\n/**\r\n * Loads a namespace descriptor into a root namespace.\r\n * @param {INamespace} json Nameespace descriptor\r\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\r\n * @returns {Root} Root namespace\r\n */\r\nRoot.fromJSON = function fromJSON(json, root) {\r\n    if (!root)\r\n        root = new Root();\r\n    if (json.options)\r\n        root.setOptions(json.options);\r\n    return root.addJSON(json.nested);\r\n};\r\n\r\n/**\r\n * Resolves the path of an imported file, relative to the importing origin.\r\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\r\n * @function\r\n * @param {string} origin The file name of the importing file\r\n * @param {string} target The file name being imported\r\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\r\n */\r\nRoot.prototype.resolvePath = util.path.resolve;\r\n\r\n/**\r\n * Fetch content from file path or url\r\n * This method exists so you can override it with your own logic.\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nRoot.prototype.fetch = util.fetch;\r\n\r\n// A symbol-like function to safely signal synchronous loading\r\n/* istanbul ignore next */\r\nfunction SYNC() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\r\n * @param {string|string[]} filename Names of one or multiple files to load\r\n * @param {IParseOptions} options Parse options\r\n * @param {LoadCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nRoot.prototype.load = function load(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = undefined;\r\n    }\r\n    var self = this;\r\n    if (!callback)\r\n        return util.asPromise(load, self, filename, options);\r\n\r\n    var sync = callback === SYNC; // undocumented\r\n\r\n    // Finishes loading by calling the callback (exactly once)\r\n    function finish(err, root) {\r\n        /* istanbul ignore if */\r\n        if (!callback)\r\n            return;\r\n        if (sync)\r\n            throw err;\r\n        var cb = callback;\r\n        callback = null;\r\n        cb(err, root);\r\n    }\r\n\r\n    // Bundled definition existence checking\r\n    function getBundledFileName(filename) {\r\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\r\n        if (idx > -1) {\r\n            var altname = filename.substring(idx);\r\n            if (altname in common) return altname;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Processes a single file\r\n    function process(filename, source) {\r\n        try {\r\n            if (util.isString(source) && source.charAt(0) === \"{\")\r\n                source = JSON.parse(source);\r\n            if (!util.isString(source))\r\n                self.setOptions(source.options).addJSON(source.nested);\r\n            else {\r\n                parse.filename = filename;\r\n                var parsed = parse(source, self, options),\r\n                    resolved,\r\n                    i = 0;\r\n                if (parsed.imports)\r\n                    for (; i < parsed.imports.length; ++i)\r\n                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))\r\n                            fetch(resolved);\r\n                if (parsed.weakImports)\r\n                    for (i = 0; i < parsed.weakImports.length; ++i)\r\n                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))\r\n                            fetch(resolved, true);\r\n            }\r\n        } catch (err) {\r\n            finish(err);\r\n        }\r\n        if (!sync && !queued)\r\n            finish(null, self); // only once anyway\r\n    }\r\n\r\n    // Fetches a single file\r\n    function fetch(filename, weak) {\r\n        filename = getBundledFileName(filename) || filename;\r\n\r\n        // Skip if already loaded / attempted\r\n        if (self.files.indexOf(filename) > -1)\r\n            return;\r\n        self.files.push(filename);\r\n\r\n        // Shortcut bundled definitions\r\n        if (filename in common) {\r\n            if (sync)\r\n                process(filename, common[filename]);\r\n            else {\r\n                ++queued;\r\n                setTimeout(function() {\r\n                    --queued;\r\n                    process(filename, common[filename]);\r\n                });\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Otherwise fetch from disk or network\r\n        if (sync) {\r\n            var source;\r\n            try {\r\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\r\n            } catch (err) {\r\n                if (!weak)\r\n                    finish(err);\r\n                return;\r\n            }\r\n            process(filename, source);\r\n        } else {\r\n            ++queued;\r\n            self.fetch(filename, function(err, source) {\r\n                --queued;\r\n                /* istanbul ignore if */\r\n                if (!callback)\r\n                    return; // terminated meanwhile\r\n                if (err) {\r\n                    /* istanbul ignore else */\r\n                    if (!weak)\r\n                        finish(err);\r\n                    else if (!queued) // can't be covered reliably\r\n                        finish(null, self);\r\n                    return;\r\n                }\r\n                process(filename, source);\r\n            });\r\n        }\r\n    }\r\n    var queued = 0;\r\n\r\n    // Assembling the root namespace doesn't require working type\r\n    // references anymore, so we can load everything in parallel\r\n    if (util.isString(filename))\r\n        filename = [ filename ];\r\n    for (var i = 0, resolved; i < filename.length; ++i)\r\n        if (resolved = self.resolvePath(\"\", filename[i]))\r\n            fetch(resolved);\r\n\r\n    if (sync)\r\n        return self;\r\n    if (!queued)\r\n        finish(null, self);\r\n    return undefined;\r\n};\r\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\r\n\r\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\r\n * @function Root#load\r\n * @param {string|string[]} filename Names of one or multiple files to load\r\n * @param {LoadCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n// function load(filename:string, callback:LoadCallback):undefined\r\n\r\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\r\n * @function Root#load\r\n * @param {string|string[]} filename Names of one or multiple files to load\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {Promise<Root>} Promise\r\n * @variation 3\r\n */\r\n// function load(filename:string, [options:IParseOptions]):Promise<Root>\r\n\r\n/**\r\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\r\n * @function Root#loadSync\r\n * @param {string|string[]} filename Names of one or multiple files to load\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {Root} Root namespace\r\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\r\n */\r\nRoot.prototype.loadSync = function loadSync(filename, options) {\r\n    if (!util.isNode)\r\n        throw Error(\"not supported\");\r\n    return this.load(filename, options, SYNC);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nRoot.prototype.resolveAll = function resolveAll() {\r\n    if (this.deferred.length)\r\n        throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\r\n            return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\r\n        }).join(\", \"));\r\n    return Namespace.prototype.resolveAll.call(this);\r\n};\r\n\r\n// only uppercased (and thus conflict-free) children are exposed, see below\r\nvar exposeRe = /^[A-Z]/;\r\n\r\n/**\r\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\r\n * @param {Root} root Root instance\r\n * @param {Field} field Declaring extension field witin the declaring type\r\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\r\n * @inner\r\n * @ignore\r\n */\r\nfunction tryHandleExtension(root, field) {\r\n    var extendedType = field.parent.lookup(field.extend);\r\n    if (extendedType) {\r\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\r\n        //do not allow to extend same field twice to prevent the error\r\n        if (extendedType.get(sisterField.name)) {\r\n            return true;\r\n        }\r\n        sisterField.declaringField = field;\r\n        field.extensionField = sisterField;\r\n        extendedType.add(sisterField);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Called when any object is added to this root or its sub-namespaces.\r\n * @param {ReflectionObject} object Object added\r\n * @returns {undefined}\r\n * @private\r\n */\r\nRoot.prototype._handleAdd = function _handleAdd(object) {\r\n    if (object instanceof Field) {\r\n\r\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)\r\n            if (!tryHandleExtension(this, object))\r\n                this.deferred.push(object);\r\n\r\n    } else if (object instanceof Enum) {\r\n\r\n        if (exposeRe.test(object.name))\r\n            object.parent[object.name] = object.values; // expose enum values as property of its parent\r\n\r\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\r\n\r\n        if (object instanceof Type) // Try to handle any deferred extensions\r\n            for (var i = 0; i < this.deferred.length;)\r\n                if (tryHandleExtension(this, this.deferred[i]))\r\n                    this.deferred.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace\r\n            this._handleAdd(object._nestedArray[j]);\r\n        if (exposeRe.test(object.name))\r\n            object.parent[object.name] = object; // expose namespace as property of its parent\r\n    }\r\n\r\n    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as\r\n    // properties of namespaces just like static code does. This allows using a .d.ts generated for\r\n    // a static module with reflection-based solutions where the condition is met.\r\n};\r\n\r\n/**\r\n * Called when any object is removed from this root or its sub-namespaces.\r\n * @param {ReflectionObject} object Object removed\r\n * @returns {undefined}\r\n * @private\r\n */\r\nRoot.prototype._handleRemove = function _handleRemove(object) {\r\n    if (object instanceof Field) {\r\n\r\n        if (/* an extension field */ object.extend !== undefined) {\r\n            if (/* already handled */ object.extensionField) { // remove its sister field\r\n                object.extensionField.parent.remove(object.extensionField);\r\n                object.extensionField = null;\r\n            } else { // cancel the extension\r\n                var index = this.deferred.indexOf(object);\r\n                /* istanbul ignore else */\r\n                if (index > -1)\r\n                    this.deferred.splice(index, 1);\r\n            }\r\n        }\r\n\r\n    } else if (object instanceof Enum) {\r\n\r\n        if (exposeRe.test(object.name))\r\n            delete object.parent[object.name]; // unexpose enum values\r\n\r\n    } else if (object instanceof Namespace) {\r\n\r\n        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace\r\n            this._handleRemove(object._nestedArray[i]);\r\n\r\n        if (exposeRe.test(object.name))\r\n            delete object.parent[object.name]; // unexpose namespaces\r\n\r\n    }\r\n};\r\n\r\n// Sets up cyclic dependencies (called in index-light)\r\nRoot._configure = function(Type_, parse_, common_) {\r\n    Type   = Type_;\r\n    parse  = parse_;\r\n    common = common_;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdHQUFhO0FBQ3JDO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsd0ZBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHNGQUFRO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyx3RkFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsc0ZBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0JBQStCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsZUFBZSxzQ0FBc0Msc0JBQXNCO0FBQ3RGLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsZUFBZSxzQ0FBc0Msc0JBQXNCO0FBQ3RGLGFBQWEsTUFBTTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdC5qcz8wZmMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFJvb3Q7XHJcblxyXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxyXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xyXG4oKFJvb3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBSb290KS5jbGFzc05hbWUgPSBcIlJvb3RcIjtcclxuXHJcbnZhciBGaWVsZCAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXHJcbiAgICBFbnVtICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcclxuICAgIE9uZU9mICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcclxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG5cclxudmFyIFR5cGUsICAgLy8gY3ljbGljXHJcbiAgICBwYXJzZSwgIC8vIG1pZ2h0IGJlIGV4Y2x1ZGVkXHJcbiAgICBjb21tb247IC8vIFwiXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyByb290IG5hbWVzcGFjZSBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBSb290IG5hbWVzcGFjZSB3cmFwcGluZyBhbGwgdHlwZXMsIGVudW1zLCBzZXJ2aWNlcywgc3ViLW5hbWVzcGFjZXMgZXRjLiB0aGF0IGJlbG9uZyB0b2dldGhlci5cclxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFRvcCBsZXZlbCBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBSb290KG9wdGlvbnMpIHtcclxuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIFwiXCIsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmZXJyZWQgZXh0ZW5zaW9uIGZpZWxkcy5cclxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlZmVycmVkID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlZCBmaWxlIG5hbWVzIG9mIGxvYWRlZCBmaWxlcy5cclxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxlcyA9IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgYSBuYW1lc3BhY2UgZGVzY3JpcHRvciBpbnRvIGEgcm9vdCBuYW1lc3BhY2UuXHJcbiAqIEBwYXJhbSB7SU5hbWVzcGFjZX0ganNvbiBOYW1lZXNwYWNlIGRlc2NyaXB0b3JcclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZFxyXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcclxuICovXHJcblJvb3QuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihqc29uLCByb290KSB7XHJcbiAgICBpZiAoIXJvb3QpXHJcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XHJcbiAgICBpZiAoanNvbi5vcHRpb25zKVxyXG4gICAgICAgIHJvb3Quc2V0T3B0aW9ucyhqc29uLm9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIHJvb3QuYWRkSlNPTihqc29uLm5lc3RlZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzb2x2ZXMgdGhlIHBhdGggb2YgYW4gaW1wb3J0ZWQgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIGltcG9ydGluZyBvcmlnaW4uXHJcbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMgaW4gY2FzZSB5b3VyIGltcG9ydHMgYXJlIHNjYXR0ZXJlZCBvdmVyIG11bHRpcGxlIGRpcmVjdG9yaWVzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiBUaGUgZmlsZSBuYW1lIG9mIHRoZSBpbXBvcnRpbmcgZmlsZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRoZSBmaWxlIG5hbWUgYmVpbmcgaW1wb3J0ZWRcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBSZXNvbHZlZCBwYXRoIHRvIGB0YXJnZXRgIG9yIGBudWxsYCB0byBza2lwIHRoZSBmaWxlXHJcbiAqL1xyXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IHV0aWwucGF0aC5yZXNvbHZlO1xyXG5cclxuLyoqXHJcbiAqIEZldGNoIGNvbnRlbnQgZnJvbSBmaWxlIHBhdGggb3IgdXJsXHJcbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlIHBhdGggb3IgdXJsXHJcbiAqIEBwYXJhbSB7RmV0Y2hDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblJvb3QucHJvdG90eXBlLmZldGNoID0gdXRpbC5mZXRjaDtcclxuXHJcbi8vIEEgc3ltYm9sLWxpa2UgZnVuY3Rpb24gdG8gc2FmZWx5IHNpZ25hbCBzeW5jaHJvbm91cyBsb2FkaW5nXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIFNZTkMoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXHJcblxyXG4vKipcclxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxyXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IG9wdGlvbnMgUGFyc2Ugb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblJvb3QucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIGlmICghY2FsbGJhY2spXHJcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKGxvYWQsIHNlbGYsIGZpbGVuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICB2YXIgc3luYyA9IGNhbGxiYWNrID09PSBTWU5DOyAvLyB1bmRvY3VtZW50ZWRcclxuXHJcbiAgICAvLyBGaW5pc2hlcyBsb2FkaW5nIGJ5IGNhbGxpbmcgdGhlIGNhbGxiYWNrIChleGFjdGx5IG9uY2UpXHJcbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyLCByb290KSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjYWxsYmFjaylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChzeW5jKVxyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgdmFyIGNiID0gY2FsbGJhY2s7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGNiKGVyciwgcm9vdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQnVuZGxlZCBkZWZpbml0aW9uIGV4aXN0ZW5jZSBjaGVja2luZ1xyXG4gICAgZnVuY3Rpb24gZ2V0QnVuZGxlZEZpbGVOYW1lKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKFwiZ29vZ2xlL3Byb3RvYnVmL1wiKTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgdmFyIGFsdG5hbWUgPSBmaWxlbmFtZS5zdWJzdHJpbmcoaWR4KTtcclxuICAgICAgICAgICAgaWYgKGFsdG5hbWUgaW4gY29tbW9uKSByZXR1cm4gYWx0bmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2Vzc2VzIGEgc2luZ2xlIGZpbGVcclxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHNvdXJjZSkgJiYgc291cmNlLmNoYXJBdCgwKSA9PT0gXCJ7XCIpXHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhzb3VyY2UpKVxyXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRPcHRpb25zKHNvdXJjZS5vcHRpb25zKS5hZGRKU09OKHNvdXJjZS5uZXN0ZWQpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBzZWxmLCBvcHRpb25zKSxcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuaW1wb3J0cylcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHBhcnNlZC5pbXBvcnRzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPSBnZXRCdW5kbGVkRmlsZU5hbWUocGFyc2VkLmltcG9ydHNbaV0pIHx8IHNlbGYucmVzb2x2ZVBhdGgoZmlsZW5hbWUsIHBhcnNlZC5pbXBvcnRzW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQud2Vha0ltcG9ydHMpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnNlZC53ZWFrSW1wb3J0cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC53ZWFrSW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLndlYWtJbXBvcnRzW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBmaW5pc2goZXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzeW5jICYmICFxdWV1ZWQpXHJcbiAgICAgICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTsgLy8gb25seSBvbmNlIGFueXdheVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZldGNoZXMgYSBzaW5nbGUgZmlsZVxyXG4gICAgZnVuY3Rpb24gZmV0Y2goZmlsZW5hbWUsIHdlYWspIHtcclxuICAgICAgICBmaWxlbmFtZSA9IGdldEJ1bmRsZWRGaWxlTmFtZShmaWxlbmFtZSkgfHwgZmlsZW5hbWU7XHJcblxyXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBsb2FkZWQgLyBhdHRlbXB0ZWRcclxuICAgICAgICBpZiAoc2VsZi5maWxlcy5pbmRleE9mKGZpbGVuYW1lKSA+IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgc2VsZi5maWxlcy5wdXNoKGZpbGVuYW1lKTtcclxuXHJcbiAgICAgICAgLy8gU2hvcnRjdXQgYnVuZGxlZCBkZWZpbml0aW9uc1xyXG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiBjb21tb24pIHtcclxuICAgICAgICAgICAgaWYgKHN5bmMpXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICArK3F1ZXVlZDtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLS1xdWV1ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgY29tbW9uW2ZpbGVuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UgZmV0Y2ggZnJvbSBkaXNrIG9yIG5ldHdvcmtcclxuICAgICAgICBpZiAoc3luYykge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlID0gdXRpbC5mcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUpLnRvU3RyaW5nKFwidXRmOFwiKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdlYWspXHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICArK3F1ZXVlZDtcclxuICAgICAgICAgICAgc2VsZi5mZXRjaChmaWxlbmFtZSwgZnVuY3Rpb24oZXJyLCBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIC0tcXVldWVkO1xyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGVybWluYXRlZCBtZWFud2hpbGVcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2VhaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXF1ZXVlZCkgLy8gY2FuJ3QgYmUgY292ZXJlZCByZWxpYWJseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHF1ZXVlZCA9IDA7XHJcblxyXG4gICAgLy8gQXNzZW1ibGluZyB0aGUgcm9vdCBuYW1lc3BhY2UgZG9lc24ndCByZXF1aXJlIHdvcmtpbmcgdHlwZVxyXG4gICAgLy8gcmVmZXJlbmNlcyBhbnltb3JlLCBzbyB3ZSBjYW4gbG9hZCBldmVyeXRoaW5nIGluIHBhcmFsbGVsXHJcbiAgICBpZiAodXRpbC5pc1N0cmluZyhmaWxlbmFtZSkpXHJcbiAgICAgICAgZmlsZW5hbWUgPSBbIGZpbGVuYW1lIF07XHJcbiAgICBmb3IgKHZhciBpID0gMCwgcmVzb2x2ZWQ7IGkgPCBmaWxlbmFtZS5sZW5ndGg7ICsraSlcclxuICAgICAgICBpZiAocmVzb2x2ZWQgPSBzZWxmLnJlc29sdmVQYXRoKFwiXCIsIGZpbGVuYW1lW2ldKSlcclxuICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xyXG5cclxuICAgIGlmIChzeW5jKVxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgaWYgKCFxdWV1ZWQpXHJcbiAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIG9wdGlvbnM6SVBhcnNlT3B0aW9ucywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cclxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcclxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEB2YXJpYXRpb24gMlxyXG4gKi9cclxuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXHJcblxyXG4vKipcclxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cclxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcclxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJvb3Q+fSBQcm9taXNlXHJcbiAqIEB2YXJpYXRpb24gM1xyXG4gKi9cclxuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIFtvcHRpb25zOklQYXJzZU9wdGlvbnNdKTpQcm9taXNlPFJvb3Q+XHJcblxyXG4vKipcclxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXHJcbiAqIEBmdW5jdGlvbiBSb290I2xvYWRTeW5jXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxyXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cclxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxyXG4gKi9cclxuUm9vdC5wcm90b3R5cGUubG9hZFN5bmMgPSBmdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKCF1dGlsLmlzTm9kZSlcclxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICByZXR1cm4gdGhpcy5sb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBTWU5DKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcblJvb3QucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xyXG4gICAgaWYgKHRoaXMuZGVmZXJyZWQubGVuZ3RoKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIGV4dGVuc2lvbnM6IFwiICsgdGhpcy5kZWZlcnJlZC5tYXAoZnVuY3Rpb24oZmllbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiJ2V4dGVuZCBcIiArIGZpZWxkLmV4dGVuZCArIFwiJyBpbiBcIiArIGZpZWxkLnBhcmVudC5mdWxsTmFtZTtcclxuICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xyXG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xyXG59O1xyXG5cclxuLy8gb25seSB1cHBlcmNhc2VkIChhbmQgdGh1cyBjb25mbGljdC1mcmVlKSBjaGlsZHJlbiBhcmUgZXhwb3NlZCwgc2VlIGJlbG93XHJcbnZhciBleHBvc2VSZSA9IC9eW0EtWl0vO1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgYSBkZWZlcnJlZCBkZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkIGJ5IGNyZWF0aW5nIGEgc2lzdGVyIGZpZWxkIHRvIHJlcHJlc2VudCBpdCB3aXRoaW4gaXRzIGV4dGVuZGVkIHR5cGUuXHJcbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIERlY2xhcmluZyBleHRlbnNpb24gZmllbGQgd2l0aW4gdGhlIGRlY2xhcmluZyB0eXBlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgc3VjY2Vzc2Z1bGx5IGFkZGVkIHRvIHRoZSBleHRlbmRlZCB0eXBlLCBgZmFsc2VgIG90aGVyd2lzZVxyXG4gKiBAaW5uZXJcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gdHJ5SGFuZGxlRXh0ZW5zaW9uKHJvb3QsIGZpZWxkKSB7XHJcbiAgICB2YXIgZXh0ZW5kZWRUeXBlID0gZmllbGQucGFyZW50Lmxvb2t1cChmaWVsZC5leHRlbmQpO1xyXG4gICAgaWYgKGV4dGVuZGVkVHlwZSkge1xyXG4gICAgICAgIHZhciBzaXN0ZXJGaWVsZCA9IG5ldyBGaWVsZChmaWVsZC5mdWxsTmFtZSwgZmllbGQuaWQsIGZpZWxkLnR5cGUsIGZpZWxkLnJ1bGUsIHVuZGVmaW5lZCwgZmllbGQub3B0aW9ucyk7XHJcbiAgICAgICAgLy9kbyBub3QgYWxsb3cgdG8gZXh0ZW5kIHNhbWUgZmllbGQgdHdpY2UgdG8gcHJldmVudCB0aGUgZXJyb3JcclxuICAgICAgICBpZiAoZXh0ZW5kZWRUeXBlLmdldChzaXN0ZXJGaWVsZC5uYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2lzdGVyRmllbGQuZGVjbGFyaW5nRmllbGQgPSBmaWVsZDtcclxuICAgICAgICBmaWVsZC5leHRlbnNpb25GaWVsZCA9IHNpc3RlckZpZWxkO1xyXG4gICAgICAgIGV4dGVuZGVkVHlwZS5hZGQoc2lzdGVyRmllbGQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyBhZGRlZCB0byB0aGlzIHJvb3Qgb3IgaXRzIHN1Yi1uYW1lc3BhY2VzLlxyXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBPYmplY3QgYWRkZWRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQHByaXZhdGVcclxuICovXHJcblJvb3QucHJvdG90eXBlLl9oYW5kbGVBZGQgPSBmdW5jdGlvbiBfaGFuZGxlQWRkKG9iamVjdCkge1xyXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XHJcblxyXG4gICAgICAgIGlmICgvKiBhbiBleHRlbnNpb24gZmllbGQgKGltcGxpZXMgbm90IHBhcnQgb2YgYSBvbmVvZikgKi8gb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkICYmIC8qIG5vdCBhbHJlYWR5IGhhbmRsZWQgKi8gIW9iamVjdC5leHRlbnNpb25GaWVsZClcclxuICAgICAgICAgICAgaWYgKCF0cnlIYW5kbGVFeHRlbnNpb24odGhpcywgb2JqZWN0KSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucHVzaChvYmplY3QpO1xyXG5cclxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xyXG5cclxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXHJcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0LnZhbHVlczsgLy8gZXhwb3NlIGVudW0gdmFsdWVzIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcclxuXHJcbiAgICB9IGVsc2UgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpKSAvKiBldmVyeXRoaW5nIGVsc2UgaXMgYSBuYW1lc3BhY2UgKi8ge1xyXG5cclxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVHlwZSkgLy8gVHJ5IHRvIGhhbmRsZSBhbnkgZGVmZXJyZWQgZXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVmZXJyZWQubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmICh0cnlIYW5kbGVFeHRlbnNpb24odGhpcywgdGhpcy5kZWZlcnJlZFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgLyogaW5pdGlhbGl6ZXMgKi8gb2JqZWN0Lm5lc3RlZEFycmF5Lmxlbmd0aDsgKytqKSAvLyByZWN1cnNlIGludG8gdGhlIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBZGQob2JqZWN0Ll9uZXN0ZWRBcnJheVtqXSk7XHJcbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxyXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdDsgLy8gZXhwb3NlIG5hbWVzcGFjZSBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGFib3ZlIGFsc28gYWRkcyB1cHBlcmNhc2VkIChhbmQgdGh1cyBjb25mbGljdC1mcmVlKSBuZXN0ZWQgdHlwZXMsIHNlcnZpY2VzIGFuZCBlbnVtcyBhc1xyXG4gICAgLy8gcHJvcGVydGllcyBvZiBuYW1lc3BhY2VzIGp1c3QgbGlrZSBzdGF0aWMgY29kZSBkb2VzLiBUaGlzIGFsbG93cyB1c2luZyBhIC5kLnRzIGdlbmVyYXRlZCBmb3JcclxuICAgIC8vIGEgc3RhdGljIG1vZHVsZSB3aXRoIHJlZmxlY3Rpb24tYmFzZWQgc29sdXRpb25zIHdoZXJlIHRoZSBjb25kaXRpb24gaXMgbWV0LlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCB3aGVuIGFueSBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgcm9vdCBvciBpdHMgc3ViLW5hbWVzcGFjZXMuXHJcbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCByZW1vdmVkXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Sb290LnByb3RvdHlwZS5faGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gX2hhbmRsZVJlbW92ZShvYmplY3QpIHtcclxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xyXG5cclxuICAgICAgICBpZiAoLyogYW4gZXh0ZW5zaW9uIGZpZWxkICovIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoLyogYWxyZWFkeSBoYW5kbGVkICovIG9iamVjdC5leHRlbnNpb25GaWVsZCkgeyAvLyByZW1vdmUgaXRzIHNpc3RlciBmaWVsZFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVuc2lvbkZpZWxkLnBhcmVudC5yZW1vdmUob2JqZWN0LmV4dGVuc2lvbkZpZWxkKTtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlbnNpb25GaWVsZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNhbmNlbCB0aGUgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmRlZmVycmVkLmluZGV4T2Yob2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnVtKSB7XHJcblxyXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcclxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBlbnVtIHZhbHVlc1xyXG5cclxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gb2JqZWN0Lm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKSAvLyByZWN1cnNlIGludG8gdGhlIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVSZW1vdmUob2JqZWN0Ll9uZXN0ZWRBcnJheVtpXSk7XHJcblxyXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcclxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBuYW1lc3BhY2VzXHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXHJcblJvb3QuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBwYXJzZV8sIGNvbW1vbl8pIHtcclxuICAgIFR5cGUgICA9IFR5cGVfO1xyXG4gICAgcGFyc2UgID0gcGFyc2VfO1xyXG4gICAgY29tbW9uID0gY29tbW9uXztcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = {};\r\n\r\n/**\r\n * Named roots.\r\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\r\n * Can also be used manually to make roots available across modules.\r\n * @name roots\r\n * @type {Object.<string,Root>}\r\n * @example\r\n * // pbjs -r myroot -o compiled.js ...\r\n *\r\n * // in another module:\r\n * require(\"./compiled.js\");\r\n *\r\n * // in any subsequent module:\r\n * var root = protobuf.roots[\"myroot\"];\r\n */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanM/MDgyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBOYW1lZCByb290cy5cclxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXHJcbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNyb3NzIG1vZHVsZXMuXHJcbiAqIEBuYW1lIHJvb3RzXHJcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cclxuICogQGV4YW1wbGVcclxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXHJcbiAqXHJcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxyXG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcclxuICpcclxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxyXG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xyXG4gKi9cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\n/**\r\n * Streaming RPC helpers.\r\n * @namespace\r\n */\r\nvar rpc = exports;\r\n\r\n/**\r\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\r\n * @typedef RPCImpl\r\n * @type {function}\r\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\r\n * @param {Uint8Array} requestData Request data\r\n * @param {RPCImplCallback} callback Callback function\r\n * @returns {undefined}\r\n * @example\r\n * function rpcImpl(method, requestData, callback) {\r\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\r\n *         throw Error(\"no such method\");\r\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\r\n *         callback(err, responseData);\r\n *     });\r\n * }\r\n */\r\n\r\n/**\r\n * Node-style callback as used by {@link RPCImpl}.\r\n * @typedef RPCImplCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxtQ0FBbUMsWUFBWSxJQUFJO0FBQzlELFdBQVcsWUFBWTtBQUN2QixXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9HQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcz9jYzg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHJwYyA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxyXG4gKiBAdHlwZWRlZiBSUENJbXBsXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXHJcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XHJcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcclxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xyXG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XHJcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xyXG4gKiAgICAgfSk7XHJcbiAqIH1cclxuICovXHJcblxyXG4vKipcclxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cclxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Service;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n// Extends EventEmitter\r\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\r\n\r\n/**\r\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\r\n *\r\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\r\n * @typedef rpc.ServiceMethodCallback\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {TRes} [response] Response message\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\r\n * @typedef rpc.ServiceMethod\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\r\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\r\n */\r\n\r\n/**\r\n * Constructs a new RPC service instance.\r\n * @classdesc An RPC service as returned by {@link Service#create}.\r\n * @exports rpc.Service\r\n * @extends util.EventEmitter\r\n * @constructor\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n */\r\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\r\n\r\n    if (typeof rpcImpl !== \"function\")\r\n        throw TypeError(\"rpcImpl must be a function\");\r\n\r\n    util.EventEmitter.call(this);\r\n\r\n    /**\r\n     * RPC implementation. Becomes `null` once the service is ended.\r\n     * @type {RPCImpl|null}\r\n     */\r\n    this.rpcImpl = rpcImpl;\r\n\r\n    /**\r\n     * Whether requests are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.requestDelimited = Boolean(requestDelimited);\r\n\r\n    /**\r\n     * Whether responses are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.responseDelimited = Boolean(responseDelimited);\r\n}\r\n\r\n/**\r\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\r\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\r\n * @param {Constructor<TReq>} requestCtor Request constructor\r\n * @param {Constructor<TRes>} responseCtor Response constructor\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\r\n * @returns {undefined}\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n */\r\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\r\n\r\n    if (!request)\r\n        throw TypeError(\"request must be specified\");\r\n\r\n    var self = this;\r\n    if (!callback)\r\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\r\n\r\n    if (!self.rpcImpl) {\r\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        return self.rpcImpl(\r\n            method,\r\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\r\n            function rpcCallback(err, response) {\r\n\r\n                if (err) {\r\n                    self.emit(\"error\", err, method);\r\n                    return callback(err);\r\n                }\r\n\r\n                if (response === null) {\r\n                    self.end(/* endedByRPC */ true);\r\n                    return undefined;\r\n                }\r\n\r\n                if (!(response instanceof responseCtor)) {\r\n                    try {\r\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\r\n                    } catch (err) {\r\n                        self.emit(\"error\", err, method);\r\n                        return callback(err);\r\n                    }\r\n                }\r\n\r\n                self.emit(\"data\", response, method);\r\n                return callback(null, response);\r\n            }\r\n        );\r\n    } catch (err) {\r\n        self.emit(\"error\", err, method);\r\n        setTimeout(function() { callback(err); }, 0);\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Ends this service and emits the `end` event.\r\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\r\n * @returns {rpc.Service} `this`\r\n */\r\nService.prototype.end = function end(endedByRPC) {\r\n    if (this.rpcImpl) {\r\n        if (!endedByRPC) // signal end to rpcImpl\r\n            this.rpcImpl(null, null, null);\r\n        this.rpcImpl = null;\r\n        this.emit(\"end\").off();\r\n    }\r\n    return this;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHVHQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNDQUFzQztBQUMvRTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFlBQVk7QUFDdkIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CLGVBQWUscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGlDQUFpQztBQUM1QyxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0NBQWtDO0FBQ3JFLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzP2NiZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXHJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xyXG5cclxuLyoqXHJcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXHJcbiAqXHJcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxyXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXHJcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cclxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcclxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XHJcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcclxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXHJcbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXHJcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcclxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcblxyXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cclxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXHJcbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxyXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XHJcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgaWYgKCFyZXF1ZXN0KVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFjYWxsYmFjaylcclxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcclxuXHJcbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xyXG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xyXG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXHJcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Service;\r\n\r\n// extends Namespace\r\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\r\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\r\n\r\nvar Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\"),\r\n    util   = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\"),\r\n    rpc    = __webpack_require__(/*! ./rpc */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js\");\r\n\r\n/**\r\n * Constructs a new service instance.\r\n * @classdesc Reflected service.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Service name\r\n * @param {Object.<string,*>} [options] Service options\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nfunction Service(name, options) {\r\n    Namespace.call(this, name, options);\r\n\r\n    /**\r\n     * Service methods.\r\n     * @type {Object.<string,Method>}\r\n     */\r\n    this.methods = {}; // toJSON, marker\r\n\r\n    /**\r\n     * Cached methods as an array.\r\n     * @type {Method[]|null}\r\n     * @private\r\n     */\r\n    this._methodsArray = null;\r\n}\r\n\r\n/**\r\n * Service descriptor.\r\n * @interface IService\r\n * @extends INamespace\r\n * @property {Object.<string,IMethod>} methods Method descriptors\r\n */\r\n\r\n/**\r\n * Constructs a service from a service descriptor.\r\n * @param {string} name Service name\r\n * @param {IService} json Service descriptor\r\n * @returns {Service} Created service\r\n * @throws {TypeError} If arguments are invalid\r\n */\r\nService.fromJSON = function fromJSON(name, json) {\r\n    var service = new Service(name, json.options);\r\n    /* istanbul ignore else */\r\n    if (json.methods)\r\n        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)\r\n            service.add(Method.fromJSON(names[i], json.methods[names[i]]));\r\n    if (json.nested)\r\n        service.addJSON(json.nested);\r\n    service.comment = json.comment;\r\n    return service;\r\n};\r\n\r\n/**\r\n * Converts this service to a service descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IService} Service descriptor\r\n */\r\nService.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"options\" , inherited && inherited.options || undefined,\r\n        \"methods\" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\r\n        \"nested\"  , inherited && inherited.nested || undefined,\r\n        \"comment\" , keepComments ? this.comment : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * Methods of this service as an array for iteration.\r\n * @name Service#methodsArray\r\n * @type {Method[]}\r\n * @readonly\r\n */\r\nObject.defineProperty(Service.prototype, \"methodsArray\", {\r\n    get: function() {\r\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\r\n    }\r\n});\r\n\r\nfunction clearCache(service) {\r\n    service._methodsArray = null;\r\n    return service;\r\n}\r\n\r\n/**\r\n * @override\r\n */\r\nService.prototype.get = function get(name) {\r\n    return this.methods[name]\r\n        || Namespace.prototype.get.call(this, name);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nService.prototype.resolveAll = function resolveAll() {\r\n    var methods = this.methodsArray;\r\n    for (var i = 0; i < methods.length; ++i)\r\n        methods[i].resolve();\r\n    return Namespace.prototype.resolve.call(this);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nService.prototype.add = function add(object) {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.get(object.name))\r\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\r\n\r\n    if (object instanceof Method) {\r\n        this.methods[object.name] = object;\r\n        object.parent = this;\r\n        return clearCache(this);\r\n    }\r\n    return Namespace.prototype.add.call(this, object);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nService.prototype.remove = function remove(object) {\r\n    if (object instanceof Method) {\r\n\r\n        /* istanbul ignore if */\r\n        if (this.methods[object.name] !== object)\r\n            throw Error(object + \" is not a member of \" + this);\r\n\r\n        delete this.methods[object.name];\r\n        object.parent = null;\r\n        return clearCache(this);\r\n    }\r\n    return Namespace.prototype.remove.call(this, object);\r\n};\r\n\r\n/**\r\n * Creates a runtime service using the specified rpc implementation.\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\r\n */\r\nService.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\r\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\r\n    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {\r\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\r\n        rpcService[methodName] = util.codegen([\"r\",\"c\"], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\r\n            m: method,\r\n            q: method.resolvedRequestType.ctor,\r\n            s: method.resolvedResponseType.ctor\r\n        });\r\n    }\r\n    return rpcService;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvc2VydmljZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdHQUFhO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMEZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHNGQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxvRkFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFnRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9zZXJ2aWNlLmpzP2E4MDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcclxuXHJcbi8vIGV4dGVuZHMgTmFtZXNwYWNlXHJcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XHJcbigoU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2UpLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xyXG5cclxudmFyIE1ldGhvZCA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKSxcclxuICAgIHV0aWwgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXHJcbiAgICBycGMgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBzZXJ2aWNlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBzZXJ2aWNlLlxyXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFNlcnZpY2Ugb3B0aW9uc1xyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxyXG4gKi9cclxuZnVuY3Rpb24gU2VydmljZShuYW1lLCBvcHRpb25zKSB7XHJcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcnZpY2UgbWV0aG9kcy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxNZXRob2Q+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1ldGhvZHMgPSB7fTsgLy8gdG9KU09OLCBtYXJrZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBtZXRob2RzIGFzIGFuIGFycmF5LlxyXG4gICAgICogQHR5cGUge01ldGhvZFtdfG51bGx9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9tZXRob2RzQXJyYXkgPSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogU2VydmljZSBkZXNjcmlwdG9yLlxyXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlXHJcbiAqIEBleHRlbmRzIElOYW1lc3BhY2VcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJTWV0aG9kPn0gbWV0aG9kcyBNZXRob2QgZGVzY3JpcHRvcnNcclxuICovXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIHNlcnZpY2UgZnJvbSBhIHNlcnZpY2UgZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSB7SVNlcnZpY2V9IGpzb24gU2VydmljZSBkZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBDcmVhdGVkIHNlcnZpY2VcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICovXHJcblNlcnZpY2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XHJcbiAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKG5hbWUsIGpzb24ub3B0aW9ucyk7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKGpzb24ubWV0aG9kcylcclxuICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ubWV0aG9kcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHNlcnZpY2UuYWRkKE1ldGhvZC5mcm9tSlNPTihuYW1lc1tpXSwganNvbi5tZXRob2RzW25hbWVzW2ldXSkpO1xyXG4gICAgaWYgKGpzb24ubmVzdGVkKVxyXG4gICAgICAgIHNlcnZpY2UuYWRkSlNPTihqc29uLm5lc3RlZCk7XHJcbiAgICBzZXJ2aWNlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XHJcbiAgICByZXR1cm4gc2VydmljZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIHNlcnZpY2UgdG8gYSBzZXJ2aWNlIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7SVNlcnZpY2V9IFNlcnZpY2UgZGVzY3JpcHRvclxyXG4gKi9cclxuU2VydmljZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcclxuICAgIHZhciBpbmhlcml0ZWQgPSBOYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMsIHRvSlNPTk9wdGlvbnMpO1xyXG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xyXG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xyXG4gICAgICAgIFwib3B0aW9uc1wiICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICBcIm1ldGhvZHNcIiAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLm1ldGhvZHNBcnJheSwgdG9KU09OT3B0aW9ucykgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge30sXHJcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcclxuICAgIF0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ldGhvZHMgb2YgdGhpcyBzZXJ2aWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXHJcbiAqIEBuYW1lIFNlcnZpY2UjbWV0aG9kc0FycmF5XHJcbiAqIEB0eXBlIHtNZXRob2RbXX1cclxuICogQHJlYWRvbmx5XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGUsIFwibWV0aG9kc0FycmF5XCIsIHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHNBcnJheSB8fCAodGhpcy5fbWV0aG9kc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubWV0aG9kcykpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFyQ2FjaGUoc2VydmljZSkge1xyXG4gICAgc2VydmljZS5fbWV0aG9kc0FycmF5ID0gbnVsbDtcclxuICAgIHJldHVybiBzZXJ2aWNlO1xyXG59XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubWV0aG9kc1tuYW1lXVxyXG4gICAgICAgIHx8IE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbmFtZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcclxuICAgIHZhciBtZXRob2RzID0gdGhpcy5tZXRob2RzQXJyYXk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgbWV0aG9kc1tpXS5yZXNvbHZlKCk7XHJcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcclxuXHJcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2RzW29iamVjdC5uYW1lXSA9IG9iamVjdDtcclxuICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XHJcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xyXG5cclxuICAgICAgICBkZWxldGUgdGhpcy5tZXRob2RzW29iamVjdC5uYW1lXTtcclxuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIG9iamVjdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJ1bnRpbWUgc2VydmljZSB1c2luZyB0aGUgc3BlY2lmaWVkIHJwYyBpbXBsZW1lbnRhdGlvbi5cclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxyXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IFJQQyBzZXJ2aWNlLiBVc2VmdWwgd2hlcmUgcmVxdWVzdHMgYW5kL29yIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWQuXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcclxuICAgIHZhciBycGNTZXJ2aWNlID0gbmV3IHJwYy5TZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBtZXRob2Q7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLm1ldGhvZHNBcnJheS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gdXRpbC5sY0ZpcnN0KChtZXRob2QgPSB0aGlzLl9tZXRob2RzQXJyYXlbaV0pLnJlc29sdmUoKS5uYW1lKS5yZXBsYWNlKC9bXiRcXHdfXS9nLCBcIlwiKTtcclxuICAgICAgICBycGNTZXJ2aWNlW21ldGhvZE5hbWVdID0gdXRpbC5jb2RlZ2VuKFtcInJcIixcImNcIl0sIHV0aWwuaXNSZXNlcnZlZChtZXRob2ROYW1lKSA/IG1ldGhvZE5hbWUgKyBcIl9cIiA6IG1ldGhvZE5hbWUpKFwicmV0dXJuIHRoaXMucnBjQ2FsbChtLHEscyxyLGMpXCIpKHtcclxuICAgICAgICAgICAgbTogbWV0aG9kLFxyXG4gICAgICAgICAgICBxOiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jdG9yLFxyXG4gICAgICAgICAgICBzOiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY3RvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJwY1NlcnZpY2U7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = tokenize;\r\n\r\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\r\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\r\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\r\n\r\nvar setCommentRe = /^ *[*/]+ */,\r\n    setCommentAltRe = /^\\s*\\*?\\/*/,\r\n    setCommentSplitRe = /\\n/g,\r\n    whitespaceRe = /\\s/,\r\n    unescapeRe = /\\\\(.?)/g;\r\n\r\nvar unescapeMap = {\r\n    \"0\": \"\\0\",\r\n    \"r\": \"\\r\",\r\n    \"n\": \"\\n\",\r\n    \"t\": \"\\t\"\r\n};\r\n\r\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\r\nfunction unescape(str) {\r\n    return str.replace(unescapeRe, function($0, $1) {\r\n        switch ($1) {\r\n            case \"\\\\\":\r\n            case \"\":\r\n                return $1;\r\n            default:\r\n                return unescapeMap[$1] || \"\";\r\n        }\r\n    });\r\n}\r\n\r\ntokenize.unescape = unescape;\r\n\r\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\r\n\r\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\r\n\r\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\r\n\r\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\r\nfunction tokenize(source, alternateCommentMode) {\r\n    /* eslint-disable callback-return */\r\n    source = source.toString();\r\n\r\n    var offset = 0,\r\n        length = source.length,\r\n        line = 1,\r\n        lastCommentLine = 0,\r\n        comments = {};\r\n\r\n    var stack = [];\r\n\r\n    var stringDelim = null;\r\n\r\n    /* istanbul ignore next */\r\n    /**\r\n     * Creates an error for illegal syntax.\r\n     * @param {string} subject Subject\r\n     * @returns {Error} Error created\r\n     * @inner\r\n     */\r\n    function illegal(subject) {\r\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\r\n    }\r\n\r\n    /**\r\n     * Reads a string till its end.\r\n     * @returns {string} String read\r\n     * @inner\r\n     */\r\n    function readString() {\r\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\r\n        re.lastIndex = offset - 1;\r\n        var match = re.exec(source);\r\n        if (!match)\r\n            throw illegal(\"string\");\r\n        offset = re.lastIndex;\r\n        push(stringDelim);\r\n        stringDelim = null;\r\n        return unescape(match[1]);\r\n    }\r\n\r\n    /**\r\n     * Gets the character at `pos` within the source.\r\n     * @param {number} pos Position\r\n     * @returns {string} Character\r\n     * @inner\r\n     */\r\n    function charAt(pos) {\r\n        return source.charAt(pos);\r\n    }\r\n\r\n    /**\r\n     * Sets the current comment text.\r\n     * @param {number} start Start offset\r\n     * @param {number} end End offset\r\n     * @param {boolean} isLeading set if a leading comment\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function setComment(start, end, isLeading) {\r\n        var comment = {\r\n            type: source.charAt(start++),\r\n            lineEmpty: false,\r\n            leading: isLeading,\r\n        };\r\n        var lookback;\r\n        if (alternateCommentMode) {\r\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\r\n        } else {\r\n            lookback = 3;  // \"///\" or \"/**\"\r\n        }\r\n        var commentOffset = start - lookback,\r\n            c;\r\n        do {\r\n            if (--commentOffset < 0 ||\r\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\r\n                comment.lineEmpty = true;\r\n                break;\r\n            }\r\n        } while (c === \" \" || c === \"\\t\");\r\n        var lines = source\r\n            .substring(start, end)\r\n            .split(setCommentSplitRe);\r\n        for (var i = 0; i < lines.length; ++i)\r\n            lines[i] = lines[i]\r\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\r\n                .trim();\r\n        comment.text = lines\r\n            .join(\"\\n\")\r\n            .trim();\r\n\r\n        comments[line] = comment;\r\n        lastCommentLine = line;\r\n    }\r\n\r\n    function isDoubleSlashCommentLine(startOffset) {\r\n        var endOffset = findEndOfLine(startOffset);\r\n\r\n        // see if remaining line matches comment pattern\r\n        var lineText = source.substring(startOffset, endOffset);\r\n        var isComment = /^\\s*\\/\\//.test(lineText);\r\n        return isComment;\r\n    }\r\n\r\n    function findEndOfLine(cursor) {\r\n        // find end of cursor's line\r\n        var endOffset = cursor;\r\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\r\n            endOffset++;\r\n        }\r\n        return endOffset;\r\n    }\r\n\r\n    /**\r\n     * Obtains the next token.\r\n     * @returns {string|null} Next token or `null` on eof\r\n     * @inner\r\n     */\r\n    function next() {\r\n        if (stack.length > 0)\r\n            return stack.shift();\r\n        if (stringDelim)\r\n            return readString();\r\n        var repeat,\r\n            prev,\r\n            curr,\r\n            start,\r\n            isDoc,\r\n            isLeadingComment = offset === 0;\r\n        do {\r\n            if (offset === length)\r\n                return null;\r\n            repeat = false;\r\n            while (whitespaceRe.test(curr = charAt(offset))) {\r\n                if (curr === \"\\n\") {\r\n                    isLeadingComment = true;\r\n                    ++line;\r\n                }\r\n                if (++offset === length)\r\n                    return null;\r\n            }\r\n\r\n            if (charAt(offset) === \"/\") {\r\n                if (++offset === length) {\r\n                    throw illegal(\"comment\");\r\n                }\r\n                if (charAt(offset) === \"/\") { // Line\r\n                    if (!alternateCommentMode) {\r\n                        // check for triple-slash comment\r\n                        isDoc = charAt(start = offset + 1) === \"/\";\r\n\r\n                        while (charAt(++offset) !== \"\\n\") {\r\n                            if (offset === length) {\r\n                                return null;\r\n                            }\r\n                        }\r\n                        ++offset;\r\n                        if (isDoc) {\r\n                            setComment(start, offset - 1, isLeadingComment);\r\n                            // Trailing comment cannot not be multi-line,\r\n                            // so leading comment state should be reset to handle potential next comments\r\n                            isLeadingComment = true;\r\n                        }\r\n                        ++line;\r\n                        repeat = true;\r\n                    } else {\r\n                        // check for double-slash comments, consolidating consecutive lines\r\n                        start = offset;\r\n                        isDoc = false;\r\n                        if (isDoubleSlashCommentLine(offset - 1)) {\r\n                            isDoc = true;\r\n                            do {\r\n                                offset = findEndOfLine(offset);\r\n                                if (offset === length) {\r\n                                    break;\r\n                                }\r\n                                offset++;\r\n                                if (!isLeadingComment) {\r\n                                    // Trailing comment cannot not be multi-line\r\n                                    break;\r\n                                }\r\n                            } while (isDoubleSlashCommentLine(offset));\r\n                        } else {\r\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\r\n                        }\r\n                        if (isDoc) {\r\n                            setComment(start, offset, isLeadingComment);\r\n                            isLeadingComment = true;\r\n                        }\r\n                        line++;\r\n                        repeat = true;\r\n                    }\r\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\r\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\r\n                    start = offset + 1;\r\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\r\n                    do {\r\n                        if (curr === \"\\n\") {\r\n                            ++line;\r\n                        }\r\n                        if (++offset === length) {\r\n                            throw illegal(\"comment\");\r\n                        }\r\n                        prev = curr;\r\n                        curr = charAt(offset);\r\n                    } while (prev !== \"*\" || curr !== \"/\");\r\n                    ++offset;\r\n                    if (isDoc) {\r\n                        setComment(start, offset - 2, isLeadingComment);\r\n                        isLeadingComment = true;\r\n                    }\r\n                    repeat = true;\r\n                } else {\r\n                    return \"/\";\r\n                }\r\n            }\r\n        } while (repeat);\r\n\r\n        // offset !== length if we got here\r\n\r\n        var end = offset;\r\n        delimRe.lastIndex = 0;\r\n        var delim = delimRe.test(charAt(end++));\r\n        if (!delim)\r\n            while (end < length && !delimRe.test(charAt(end)))\r\n                ++end;\r\n        var token = source.substring(offset, offset = end);\r\n        if (token === \"\\\"\" || token === \"'\")\r\n            stringDelim = token;\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Pushes a token back to the stack.\r\n     * @param {string} token Token\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function push(token) {\r\n        stack.push(token);\r\n    }\r\n\r\n    /**\r\n     * Peeks for the next token.\r\n     * @returns {string|null} Token or `null` on eof\r\n     * @inner\r\n     */\r\n    function peek() {\r\n        if (!stack.length) {\r\n            var token = next();\r\n            if (token === null)\r\n                return null;\r\n            push(token);\r\n        }\r\n        return stack[0];\r\n    }\r\n\r\n    /**\r\n     * Skips a token.\r\n     * @param {string} expected Expected token\r\n     * @param {boolean} [optional=false] Whether the token is optional\r\n     * @returns {boolean} `true` when skipped, `false` if not\r\n     * @throws {Error} When a required token is not present\r\n     * @inner\r\n     */\r\n    function skip(expected, optional) {\r\n        var actual = peek(),\r\n            equals = actual === expected;\r\n        if (equals) {\r\n            next();\r\n            return true;\r\n        }\r\n        if (!optional)\r\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a comment.\r\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n     * @returns {string|null} Comment text\r\n     * @inner\r\n     */\r\n    function cmnt(trailingLine) {\r\n        var ret = null;\r\n        var comment;\r\n        if (trailingLine === undefined) {\r\n            comment = comments[line - 1];\r\n            delete comments[line - 1];\r\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\r\n                ret = comment.leading ? comment.text : null;\r\n            }\r\n        } else {\r\n            /* istanbul ignore else */\r\n            if (lastCommentLine < trailingLine) {\r\n                peek();\r\n            }\r\n            comment = comments[trailingLine];\r\n            delete comments[trailingLine];\r\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\r\n                ret = comment.leading ? null : comment.text;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    return Object.defineProperty({\r\n        next: next,\r\n        peek: peek,\r\n        push: push,\r\n        skip: skip,\r\n        cmnt: cmnt\r\n    }, \"line\", {\r\n        get: function() { return line; }\r\n    });\r\n    /* eslint-enable callback-return */\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdG9rZW5pemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90b2tlbml6ZS5qcz9mY2NlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHRva2VuaXplO1xyXG5cclxudmFyIGRlbGltUmUgICAgICAgID0gL1tcXHN7fT07OltcXF0sJ1wiKCk8Pl0vZyxcclxuICAgIHN0cmluZ0RvdWJsZVJlID0gLyg/OlwiKFteXCJcXFxcXSooPzpcXFxcLlteXCJcXFxcXSopKilcIikvZyxcclxuICAgIHN0cmluZ1NpbmdsZVJlID0gLyg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nO1xyXG5cclxudmFyIHNldENvbW1lbnRSZSA9IC9eICpbKi9dKyAqLyxcclxuICAgIHNldENvbW1lbnRBbHRSZSA9IC9eXFxzKlxcKj9cXC8qLyxcclxuICAgIHNldENvbW1lbnRTcGxpdFJlID0gL1xcbi9nLFxyXG4gICAgd2hpdGVzcGFjZVJlID0gL1xccy8sXHJcbiAgICB1bmVzY2FwZVJlID0gL1xcXFwoLj8pL2c7XHJcblxyXG52YXIgdW5lc2NhcGVNYXAgPSB7XHJcbiAgICBcIjBcIjogXCJcXDBcIixcclxuICAgIFwiclwiOiBcIlxcclwiLFxyXG4gICAgXCJuXCI6IFwiXFxuXCIsXHJcbiAgICBcInRcIjogXCJcXHRcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVuZXNjYXBlcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gdW5lc2NhcGVcclxuICogQHJldHVybnMge3N0cmluZ30gVW5lc2NhcGVkIHN0cmluZ1xyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLHN0cmluZz59IG1hcCBTcGVjaWFsIGNoYXJhY3RlcnMgbWFwXHJcbiAqIEBtZW1iZXJvZiB0b2tlbml6ZVxyXG4gKi9cclxuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UodW5lc2NhcGVSZSwgZnVuY3Rpb24oJDAsICQxKSB7XHJcbiAgICAgICAgc3dpdGNoICgkMSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJDE7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5lc2NhcGVNYXBbJDFdIHx8IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbnRva2VuaXplLnVuZXNjYXBlID0gdW5lc2NhcGU7XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMuXHJcbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZU5leHRcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXHJcbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVBlZWtcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFjay5cclxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUHVzaFxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlblxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBTa2lwcyB0aGUgbmV4dCB0b2tlbi5cclxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlU2tpcFxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCB0b2tlblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbD1mYWxzZV0gSWYgb3B0aW9uYWxcclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRva2VuIG1hdGNoZWRcclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0b2tlbiBkaWRuJ3QgbWF0Y2ggYW5kIGlzIG5vdCBvcHRpb25hbFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBjb21tZW50IG9uIHRoZSBwcmV2aW91cyBsaW5lIG9yLCBhbHRlcm5hdGl2ZWx5LCB0aGUgbGluZSBjb21tZW50IG9uIHRoZSBzcGVjaWZpZWQgbGluZS5cclxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlQ21udFxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZV0gTGluZSBudW1iZXJcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBDb21tZW50IHRleHQgb3IgYG51bGxgIGlmIG5vbmVcclxuICovXHJcblxyXG4vKipcclxuICogSGFuZGxlIG9iamVjdCByZXR1cm5lZCBmcm9tIHtAbGluayB0b2tlbml6ZX0uXHJcbiAqIEBpbnRlcmZhY2UgSVRva2VuaXplckhhbmRsZVxyXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZU5leHR9IG5leHQgR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgKGBudWxsYCBvbiBlb2YpXHJcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlUGVla30gcGVlayBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4gKGBudWxsYCBvbiBlb2YpXHJcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlUHVzaH0gcHVzaCBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFja1xyXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVNraXB9IHNraXAgU2tpcHMgYSB0b2tlbiwgcmV0dXJucyBpdHMgcHJlc2VuY2UgYW5kIGFkdmFuY2VzIG9yLCBpZiBub24tb3B0aW9uYWwgYW5kIG5vdCBwcmVzZW50LCB0aHJvd3NcclxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVDbW50fSBjbW50IEdldHMgdGhlIGNvbW1lbnQgb24gdGhlIHByZXZpb3VzIGxpbmUgb3IgdGhlIGxpbmUgY29tbWVudCBvbiB0aGUgc3BlY2lmaWVkIGxpbmUsIGlmIGFueVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZSBDdXJyZW50IGxpbmUgbnVtYmVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgdXRpbGl0eSBmdW5jdGlvbnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWx0ZXJuYXRlQ29tbWVudE1vZGUgV2hldGhlciB3ZSBzaG91bGQgYWN0aXZhdGUgYWx0ZXJuYXRlIGNvbW1lbnQgcGFyc2luZyBtb2RlLlxyXG4gKiBAcmV0dXJucyB7SVRva2VuaXplckhhbmRsZX0gVG9rZW5pemVyIGhhbmRsZVxyXG4gKi9cclxuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCBhbHRlcm5hdGVDb21tZW50TW9kZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FsbGJhY2stcmV0dXJuICovXHJcbiAgICBzb3VyY2UgPSBzb3VyY2UudG9TdHJpbmcoKTtcclxuXHJcbiAgICB2YXIgb2Zmc2V0ID0gMCxcclxuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLFxyXG4gICAgICAgIGxpbmUgPSAxLFxyXG4gICAgICAgIGxhc3RDb21tZW50TGluZSA9IDAsXHJcbiAgICAgICAgY29tbWVudHMgPSB7fTtcclxuXHJcbiAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHJcbiAgICB2YXIgc3RyaW5nRGVsaW0gPSBudWxsO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgZm9yIGlsbGVnYWwgc3ludGF4LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmplY3QgU3ViamVjdFxyXG4gICAgICogQHJldHVybnMge0Vycm9yfSBFcnJvciBjcmVhdGVkXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaWxsZWdhbChzdWJqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIEVycm9yKFwiaWxsZWdhbCBcIiArIHN1YmplY3QgKyBcIiAobGluZSBcIiArIGxpbmUgKyBcIilcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIHN0cmluZyB0aWxsIGl0cyBlbmQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XHJcbiAgICAgICAgdmFyIHJlID0gc3RyaW5nRGVsaW0gPT09IFwiJ1wiID8gc3RyaW5nU2luZ2xlUmUgOiBzdHJpbmdEb3VibGVSZTtcclxuICAgICAgICByZS5sYXN0SW5kZXggPSBvZmZzZXQgLSAxO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoc291cmNlKTtcclxuICAgICAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwic3RyaW5nXCIpO1xyXG4gICAgICAgIG9mZnNldCA9IHJlLmxhc3RJbmRleDtcclxuICAgICAgICBwdXNoKHN0cmluZ0RlbGltKTtcclxuICAgICAgICBzdHJpbmdEZWxpbSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlKG1hdGNoWzFdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciBhdCBgcG9zYCB3aXRoaW4gdGhlIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb25cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IENoYXJhY3RlclxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoYXJBdChwb3MpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlLmNoYXJBdChwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBjb21tZW50IHRleHQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFkaW5nIHNldCBpZiBhIGxlYWRpbmcgY29tbWVudFxyXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRDb21tZW50KHN0YXJ0LCBlbmQsIGlzTGVhZGluZykge1xyXG4gICAgICAgIHZhciBjb21tZW50ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBzb3VyY2UuY2hhckF0KHN0YXJ0KyspLFxyXG4gICAgICAgICAgICBsaW5lRW1wdHk6IGZhbHNlLFxyXG4gICAgICAgICAgICBsZWFkaW5nOiBpc0xlYWRpbmcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbG9va2JhY2s7XHJcbiAgICAgICAgaWYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XHJcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMjsgIC8vIGFsdGVybmF0ZSBjb21tZW50IHBhcnNpbmc6IFwiLy9cIiBvciBcIi8qXCJcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsb29rYmFjayA9IDM7ICAvLyBcIi8vL1wiIG9yIFwiLyoqXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbW1lbnRPZmZzZXQgPSBzdGFydCAtIGxvb2tiYWNrLFxyXG4gICAgICAgICAgICBjO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKC0tY29tbWVudE9mZnNldCA8IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICAoYyA9IHNvdXJjZS5jaGFyQXQoY29tbWVudE9mZnNldCkpID09PSBcIlxcblwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50LmxpbmVFbXB0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIpO1xyXG4gICAgICAgIHZhciBsaW5lcyA9IHNvdXJjZVxyXG4gICAgICAgICAgICAuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpXHJcbiAgICAgICAgICAgIC5zcGxpdChzZXRDb21tZW50U3BsaXRSZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYWx0ZXJuYXRlQ29tbWVudE1vZGUgPyBzZXRDb21tZW50QWx0UmUgOiBzZXRDb21tZW50UmUsIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAudHJpbSgpO1xyXG4gICAgICAgIGNvbW1lbnQudGV4dCA9IGxpbmVzXHJcbiAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpXHJcbiAgICAgICAgICAgIC50cmltKCk7XHJcblxyXG4gICAgICAgIGNvbW1lbnRzW2xpbmVdID0gY29tbWVudDtcclxuICAgICAgICBsYXN0Q29tbWVudExpbmUgPSBsaW5lO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRG91YmxlU2xhc2hDb21tZW50TGluZShzdGFydE9mZnNldCkge1xyXG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBmaW5kRW5kT2ZMaW5lKHN0YXJ0T2Zmc2V0KTtcclxuXHJcbiAgICAgICAgLy8gc2VlIGlmIHJlbWFpbmluZyBsaW5lIG1hdGNoZXMgY29tbWVudCBwYXR0ZXJuXHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gc291cmNlLnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcclxuICAgICAgICB2YXIgaXNDb21tZW50ID0gL15cXHMqXFwvXFwvLy50ZXN0KGxpbmVUZXh0KTtcclxuICAgICAgICByZXR1cm4gaXNDb21tZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRFbmRPZkxpbmUoY3Vyc29yKSB7XHJcbiAgICAgICAgLy8gZmluZCBlbmQgb2YgY3Vyc29yJ3MgbGluZVxyXG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBjdXJzb3I7XHJcbiAgICAgICAgd2hpbGUgKGVuZE9mZnNldCA8IGxlbmd0aCAmJiBjaGFyQXQoZW5kT2Zmc2V0KSAhPT0gXCJcXG5cIikge1xyXG4gICAgICAgICAgICBlbmRPZmZzZXQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVuZE9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG5leHQgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChzdHJpbmdEZWxpbSlcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoKTtcclxuICAgICAgICB2YXIgcmVwZWF0LFxyXG4gICAgICAgICAgICBwcmV2LFxyXG4gICAgICAgICAgICBjdXJyLFxyXG4gICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgaXNEb2MsXHJcbiAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSBvZmZzZXQgPT09IDA7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlICh3aGl0ZXNwYWNlUmUudGVzdChjdXJyID0gY2hhckF0KG9mZnNldCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyciA9PT0gXCJcXG5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbGluZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hhckF0KG9mZnNldCkgPT09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJjb21tZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJBdChvZmZzZXQpID09PSBcIi9cIikgeyAvLyBMaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGVDb21tZW50TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdHJpcGxlLXNsYXNoIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBjaGFyQXQoc3RhcnQgPSBvZmZzZXQgKyAxKSA9PT0gXCIvXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckF0KCsrb2Zmc2V0KSAhPT0gXCJcXG5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKytvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0IC0gMSwgaXNMZWFkaW5nQ29tbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFpbGluZyBjb21tZW50IGNhbm5vdCBub3QgYmUgbXVsdGktbGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGxlYWRpbmcgY29tbWVudCBzdGF0ZSBzaG91bGQgYmUgcmVzZXQgdG8gaGFuZGxlIHBvdGVudGlhbCBuZXh0IGNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRvdWJsZS1zbGFzaCBjb21tZW50cywgY29uc29saWRhdGluZyBjb25zZWN1dGl2ZSBsaW5lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGZpbmRFbmRPZkxpbmUob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNMZWFkaW5nQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFpbGluZyBjb21tZW50IGNhbm5vdCBub3QgYmUgbXVsdGktbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIGZpbmRFbmRPZkxpbmUob2Zmc2V0KSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0LCBpc0xlYWRpbmdDb21tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjdXJyID0gY2hhckF0KG9mZnNldCkpID09PSBcIipcIikgeyAvKiBCbG9jayAqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciAvKiogKHJlZ3VsYXIgY29tbWVudCBtb2RlKSBvciAvKiAoYWx0ZXJuYXRlIGNvbW1lbnQgbW9kZSlcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9mZnNldCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjaGFyQXQoc3RhcnQpID09PSBcIipcIjtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyID09PSBcIlxcblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJjb21tZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjdXJyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY2hhckF0KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiAhPT0gXCIqXCIgfHwgY3VyciAhPT0gXCIvXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICsrb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQgLSAyLCBpc0xlYWRpbmdDb21tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XHJcblxyXG4gICAgICAgIC8vIG9mZnNldCAhPT0gbGVuZ3RoIGlmIHdlIGdvdCBoZXJlXHJcblxyXG4gICAgICAgIHZhciBlbmQgPSBvZmZzZXQ7XHJcbiAgICAgICAgZGVsaW1SZS5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBkZWxpbSA9IGRlbGltUmUudGVzdChjaGFyQXQoZW5kKyspKTtcclxuICAgICAgICBpZiAoIWRlbGltKVxyXG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoICYmICFkZWxpbVJlLnRlc3QoY2hhckF0KGVuZCkpKVxyXG4gICAgICAgICAgICAgICAgKytlbmQ7XHJcbiAgICAgICAgdmFyIHRva2VuID0gc291cmNlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCA9IGVuZCk7XHJcbiAgICAgICAgaWYgKHRva2VuID09PSBcIlxcXCJcIiB8fCB0b2tlbiA9PT0gXCInXCIpXHJcbiAgICAgICAgICAgIHN0cmluZ0RlbGltID0gdG9rZW47XHJcbiAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2suXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW5cclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHVzaCh0b2tlbikge1xyXG4gICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUb2tlbiBvciBgbnVsbGAgb24gZW9mXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGVlaygpIHtcclxuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBwdXNoKHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgYSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCB0b2tlblxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHRva2VuIGlzIG9wdGlvbmFsXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gc2tpcHBlZCwgYGZhbHNlYCBpZiBub3RcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIGEgcmVxdWlyZWQgdG9rZW4gaXMgbm90IHByZXNlbnRcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBza2lwKGV4cGVjdGVkLCBvcHRpb25hbCkge1xyXG4gICAgICAgIHZhciBhY3R1YWwgPSBwZWVrKCksXHJcbiAgICAgICAgICAgIGVxdWFscyA9IGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XHJcbiAgICAgICAgaWYgKGVxdWFscykge1xyXG4gICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdGlvbmFsKVxyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwidG9rZW4gJ1wiICsgYWN0dWFsICsgXCInLCAnXCIgKyBleHBlY3RlZCArIFwiJyBleHBlY3RlZFwiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgY29tbWVudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdHJhaWxpbmdMaW5lXSBMaW5lIG51bWJlciBpZiBsb29raW5nIGZvciBhIHRyYWlsaW5nIGNvbW1lbnRcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gQ29tbWVudCB0ZXh0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY21udCh0cmFpbGluZ0xpbmUpIHtcclxuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcclxuICAgICAgICB2YXIgY29tbWVudDtcclxuICAgICAgICBpZiAodHJhaWxpbmdMaW5lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2xpbmUgLSAxXTtcclxuICAgICAgICAgICAgZGVsZXRlIGNvbW1lbnRzW2xpbmUgLSAxXTtcclxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgJiYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNvbW1lbnQudHlwZSA9PT0gXCIqXCIgfHwgY29tbWVudC5saW5lRW1wdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXQgPSBjb21tZW50LmxlYWRpbmcgPyBjb21tZW50LnRleHQgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKGxhc3RDb21tZW50TGluZSA8IHRyYWlsaW5nTGluZSkge1xyXG4gICAgICAgICAgICAgICAgcGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1t0cmFpbGluZ0xpbmVdO1xyXG4gICAgICAgICAgICBkZWxldGUgY29tbWVudHNbdHJhaWxpbmdMaW5lXTtcclxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgJiYgIWNvbW1lbnQubGluZUVtcHR5ICYmIChhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjb21tZW50LnR5cGUgPT09IFwiL1wiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gY29tbWVudC5sZWFkaW5nID8gbnVsbCA6IGNvbW1lbnQudGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xyXG4gICAgICAgIG5leHQ6IG5leHQsXHJcbiAgICAgICAgcGVlazogcGVlayxcclxuICAgICAgICBwdXNoOiBwdXNoLFxyXG4gICAgICAgIHNraXA6IHNraXAsXHJcbiAgICAgICAgY21udDogY21udFxyXG4gICAgfSwgXCJsaW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZTsgfVxyXG4gICAgfSk7XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbGxiYWNrLXJldHVybiAqL1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Type;\r\n\r\n// extends Namespace\r\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\r\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\r\n\r\nvar Enum      = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    OneOf     = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\"),\r\n    Field     = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"),\r\n    MapField  = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\"),\r\n    Service   = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\"),\r\n    Message   = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\"),\r\n    Reader    = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\"),\r\n    Writer    = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\"),\r\n    util      = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\"),\r\n    encoder   = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js\"),\r\n    decoder   = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js\"),\r\n    verifier  = __webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js\"),\r\n    converter = __webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js\"),\r\n    wrappers  = __webpack_require__(/*! ./wrappers */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js\");\r\n\r\n/**\r\n * Constructs a new reflected message type instance.\r\n * @classdesc Reflected message type.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Message name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\r\nfunction Type(name, options) {\r\n    Namespace.call(this, name, options);\r\n\r\n    /**\r\n     * Message fields.\r\n     * @type {Object.<string,Field>}\r\n     */\r\n    this.fields = {};  // toJSON, marker\r\n\r\n    /**\r\n     * Oneofs declared within this namespace, if any.\r\n     * @type {Object.<string,OneOf>}\r\n     */\r\n    this.oneofs = undefined; // toJSON\r\n\r\n    /**\r\n     * Extension ranges, if any.\r\n     * @type {number[][]}\r\n     */\r\n    this.extensions = undefined; // toJSON\r\n\r\n    /**\r\n     * Reserved ranges, if any.\r\n     * @type {Array.<number[]|string>}\r\n     */\r\n    this.reserved = undefined; // toJSON\r\n\r\n    /*?\r\n     * Whether this type is a legacy group.\r\n     * @type {boolean|undefined}\r\n     */\r\n    this.group = undefined; // toJSON\r\n\r\n    /**\r\n     * Cached fields by id.\r\n     * @type {Object.<number,Field>|null}\r\n     * @private\r\n     */\r\n    this._fieldsById = null;\r\n\r\n    /**\r\n     * Cached fields as an array.\r\n     * @type {Field[]|null}\r\n     * @private\r\n     */\r\n    this._fieldsArray = null;\r\n\r\n    /**\r\n     * Cached oneofs as an array.\r\n     * @type {OneOf[]|null}\r\n     * @private\r\n     */\r\n    this._oneofsArray = null;\r\n\r\n    /**\r\n     * Cached constructor.\r\n     * @type {Constructor<{}>}\r\n     * @private\r\n     */\r\n    this._ctor = null;\r\n}\r\n\r\nObject.defineProperties(Type.prototype, {\r\n\r\n    /**\r\n     * Message fields by id.\r\n     * @name Type#fieldsById\r\n     * @type {Object.<number,Field>}\r\n     * @readonly\r\n     */\r\n    fieldsById: {\r\n        get: function() {\r\n\r\n            /* istanbul ignore if */\r\n            if (this._fieldsById)\r\n                return this._fieldsById;\r\n\r\n            this._fieldsById = {};\r\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\r\n                var field = this.fields[names[i]],\r\n                    id = field.id;\r\n\r\n                /* istanbul ignore if */\r\n                if (this._fieldsById[id])\r\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\r\n\r\n                this._fieldsById[id] = field;\r\n            }\r\n            return this._fieldsById;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Fields of this message as an array for iteration.\r\n     * @name Type#fieldsArray\r\n     * @type {Field[]}\r\n     * @readonly\r\n     */\r\n    fieldsArray: {\r\n        get: function() {\r\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Oneofs of this message as an array for iteration.\r\n     * @name Type#oneofsArray\r\n     * @type {OneOf[]}\r\n     * @readonly\r\n     */\r\n    oneofsArray: {\r\n        get: function() {\r\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The registered constructor, if any registered, otherwise a generic constructor.\r\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\r\n     * @name Type#ctor\r\n     * @type {Constructor<{}>}\r\n     */\r\n    ctor: {\r\n        get: function() {\r\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\r\n        },\r\n        set: function(ctor) {\r\n\r\n            // Ensure proper prototype\r\n            var prototype = ctor.prototype;\r\n            if (!(prototype instanceof Message)) {\r\n                (ctor.prototype = new Message()).constructor = ctor;\r\n                util.merge(ctor.prototype, prototype);\r\n            }\r\n\r\n            // Classes and messages reference their reflected type\r\n            ctor.$type = ctor.prototype.$type = this;\r\n\r\n            // Mix in static methods\r\n            util.merge(ctor, Message, true);\r\n\r\n            this._ctor = ctor;\r\n\r\n            // Messages have non-enumerable default values on their prototype\r\n            var i = 0;\r\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\r\n                this._fieldsArray[i].resolve(); // ensures a proper value\r\n\r\n            // Messages have non-enumerable getters and setters for each virtual oneof field\r\n            var ctorProperties = {};\r\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\r\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\r\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\r\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\r\n                };\r\n            if (i)\r\n                Object.defineProperties(ctor.prototype, ctorProperties);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Generates a constructor function for the specified type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nType.generateConstructor = function generateConstructor(mtype) {\r\n    /* eslint-disable no-unexpected-multiline */\r\n    var gen = util.codegen([\"p\"], mtype.name);\r\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\r\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\r\n        if ((field = mtype._fieldsArray[i]).map) gen\r\n            (\"this%s={}\", util.safeProp(field.name));\r\n        else if (field.repeated) gen\r\n            (\"this%s=[]\", util.safeProp(field.name));\r\n    return gen\r\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\r\n        (\"this[ks[i]]=p[ks[i]]\");\r\n    /* eslint-enable no-unexpected-multiline */\r\n};\r\n\r\nfunction clearCache(type) {\r\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\r\n    delete type.encode;\r\n    delete type.decode;\r\n    delete type.verify;\r\n    return type;\r\n}\r\n\r\n/**\r\n * Message type descriptor.\r\n * @interface IType\r\n * @extends INamespace\r\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\r\n * @property {Object.<string,IField>} fields Field descriptors\r\n * @property {number[][]} [extensions] Extension ranges\r\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\r\n * @property {boolean} [group=false] Whether a legacy group or not\r\n */\r\n\r\n/**\r\n * Creates a message type from a message type descriptor.\r\n * @param {string} name Message name\r\n * @param {IType} json Message type descriptor\r\n * @returns {Type} Created message type\r\n */\r\nType.fromJSON = function fromJSON(name, json) {\r\n    var type = new Type(name, json.options);\r\n    type.extensions = json.extensions;\r\n    type.reserved = json.reserved;\r\n    var names = Object.keys(json.fields),\r\n        i = 0;\r\n    for (; i < names.length; ++i)\r\n        type.add(\r\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\r\n            ? MapField.fromJSON\r\n            : Field.fromJSON )(names[i], json.fields[names[i]])\r\n        );\r\n    if (json.oneofs)\r\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\r\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\r\n    if (json.nested)\r\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\r\n            var nested = json.nested[names[i]];\r\n            type.add( // most to least likely\r\n                ( nested.id !== undefined\r\n                ? Field.fromJSON\r\n                : nested.fields !== undefined\r\n                ? Type.fromJSON\r\n                : nested.values !== undefined\r\n                ? Enum.fromJSON\r\n                : nested.methods !== undefined\r\n                ? Service.fromJSON\r\n                : Namespace.fromJSON )(names[i], nested)\r\n            );\r\n        }\r\n    if (json.extensions && json.extensions.length)\r\n        type.extensions = json.extensions;\r\n    if (json.reserved && json.reserved.length)\r\n        type.reserved = json.reserved;\r\n    if (json.group)\r\n        type.group = true;\r\n    if (json.comment)\r\n        type.comment = json.comment;\r\n    return type;\r\n};\r\n\r\n/**\r\n * Converts this message type to a message type descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IType} Message type descriptor\r\n */\r\nType.prototype.toJSON = function toJSON(toJSONOptions) {\r\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\r\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\r\n    return util.toObject([\r\n        \"options\"    , inherited && inherited.options || undefined,\r\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\r\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\r\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\r\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\r\n        \"group\"      , this.group || undefined,\r\n        \"nested\"     , inherited && inherited.nested || undefined,\r\n        \"comment\"    , keepComments ? this.comment : undefined\r\n    ]);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nType.prototype.resolveAll = function resolveAll() {\r\n    var fields = this.fieldsArray, i = 0;\r\n    while (i < fields.length)\r\n        fields[i++].resolve();\r\n    var oneofs = this.oneofsArray; i = 0;\r\n    while (i < oneofs.length)\r\n        oneofs[i++].resolve();\r\n    return Namespace.prototype.resolveAll.call(this);\r\n};\r\n\r\n/**\r\n * @override\r\n */\r\nType.prototype.get = function get(name) {\r\n    return this.fields[name]\r\n        || this.oneofs && this.oneofs[name]\r\n        || this.nested && this.nested[name]\r\n        || null;\r\n};\r\n\r\n/**\r\n * Adds a nested object to this type.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Type} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\r\n */\r\nType.prototype.add = function add(object) {\r\n\r\n    if (this.get(object.name))\r\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\r\n\r\n    if (object instanceof Field && object.extend === undefined) {\r\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\r\n        // The root object takes care of adding distinct sister-fields to the respective extended\r\n        // type instead.\r\n\r\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\r\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\r\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\r\n        if (this.isReservedId(object.id))\r\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\r\n        if (this.isReservedName(object.name))\r\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\r\n\r\n        if (object.parent)\r\n            object.parent.remove(object);\r\n        this.fields[object.name] = object;\r\n        object.message = this;\r\n        object.onAdd(this);\r\n        return clearCache(this);\r\n    }\r\n    if (object instanceof OneOf) {\r\n        if (!this.oneofs)\r\n            this.oneofs = {};\r\n        this.oneofs[object.name] = object;\r\n        object.onAdd(this);\r\n        return clearCache(this);\r\n    }\r\n    return Namespace.prototype.add.call(this, object);\r\n};\r\n\r\n/**\r\n * Removes a nested object from this type.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Type} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this type\r\n */\r\nType.prototype.remove = function remove(object) {\r\n    if (object instanceof Field && object.extend === undefined) {\r\n        // See Type#add for the reason why extension fields are excluded here.\r\n\r\n        /* istanbul ignore if */\r\n        if (!this.fields || this.fields[object.name] !== object)\r\n            throw Error(object + \" is not a member of \" + this);\r\n\r\n        delete this.fields[object.name];\r\n        object.parent = null;\r\n        object.onRemove(this);\r\n        return clearCache(this);\r\n    }\r\n    if (object instanceof OneOf) {\r\n\r\n        /* istanbul ignore if */\r\n        if (!this.oneofs || this.oneofs[object.name] !== object)\r\n            throw Error(object + \" is not a member of \" + this);\r\n\r\n        delete this.oneofs[object.name];\r\n        object.parent = null;\r\n        object.onRemove(this);\r\n        return clearCache(this);\r\n    }\r\n    return Namespace.prototype.remove.call(this, object);\r\n};\r\n\r\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nType.prototype.isReservedId = function isReservedId(id) {\r\n    return Namespace.isReservedId(this.reserved, id);\r\n};\r\n\r\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nType.prototype.isReservedName = function isReservedName(name) {\r\n    return Namespace.isReservedName(this.reserved, name);\r\n};\r\n\r\n/**\r\n * Creates a new message of this type using the specified properties.\r\n * @param {Object.<string,*>} [properties] Properties to set\r\n * @returns {Message<{}>} Message instance\r\n */\r\nType.prototype.create = function create(properties) {\r\n    return new this.ctor(properties);\r\n};\r\n\r\n/**\r\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\r\n * @returns {Type} `this`\r\n */\r\nType.prototype.setup = function setup() {\r\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\r\n    // multiple times (V8, soft-deopt prototype-check).\r\n\r\n    var fullName = this.fullName,\r\n        types    = [];\r\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\r\n        types.push(this._fieldsArray[i].resolve().resolvedType);\r\n\r\n    // Replace setup methods with type-specific generated functions\r\n    this.encode = encoder(this)({\r\n        Writer : Writer,\r\n        types  : types,\r\n        util   : util\r\n    });\r\n    this.decode = decoder(this)({\r\n        Reader : Reader,\r\n        types  : types,\r\n        util   : util\r\n    });\r\n    this.verify = verifier(this)({\r\n        types : types,\r\n        util  : util\r\n    });\r\n    this.fromObject = converter.fromObject(this)({\r\n        types : types,\r\n        util  : util\r\n    });\r\n    this.toObject = converter.toObject(this)({\r\n        types : types,\r\n        util  : util\r\n    });\r\n\r\n    // Inject custom wrappers for common types\r\n    var wrapper = wrappers[fullName];\r\n    if (wrapper) {\r\n        var originalThis = Object.create(this);\r\n        // if (wrapper.fromObject) {\r\n            originalThis.fromObject = this.fromObject;\r\n            this.fromObject = wrapper.fromObject.bind(originalThis);\r\n        // }\r\n        // if (wrapper.toObject) {\r\n            originalThis.toObject = this.toObject;\r\n            this.toObject = wrapper.toObject.bind(originalThis);\r\n        // }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\r\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\r\n * @param {Writer} [writer] Writer to encode to\r\n * @returns {Writer} writer\r\n */\r\nType.prototype.encode = function encode_setup(message, writer) {\r\n    return this.setup().encode(message, writer); // overrides this method\r\n};\r\n\r\n/**\r\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\r\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\r\n * @param {Writer} [writer] Writer to encode to\r\n * @returns {Writer} writer\r\n */\r\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\r\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\r\n};\r\n\r\n/**\r\n * Decodes a message of this type.\r\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\r\n * @param {number} [length] Length of the message, if known beforehand\r\n * @returns {Message<{}>} Decoded message\r\n * @throws {Error} If the payload is not a reader or valid buffer\r\n * @throws {util.ProtocolError<{}>} If required fields are missing\r\n */\r\nType.prototype.decode = function decode_setup(reader, length) {\r\n    return this.setup().decode(reader, length); // overrides this method\r\n};\r\n\r\n/**\r\n * Decodes a message of this type preceeded by its byte length as a varint.\r\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\r\n * @returns {Message<{}>} Decoded message\r\n * @throws {Error} If the payload is not a reader or valid buffer\r\n * @throws {util.ProtocolError} If required fields are missing\r\n */\r\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\r\n    if (!(reader instanceof Reader))\r\n        reader = Reader.create(reader);\r\n    return this.decode(reader, reader.uint32());\r\n};\r\n\r\n/**\r\n * Verifies that field values are valid and that required fields are present.\r\n * @param {Object.<string,*>} message Plain object to verify\r\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\r\n */\r\nType.prototype.verify = function verify_setup(message) {\r\n    return this.setup().verify(message); // overrides this method\r\n};\r\n\r\n/**\r\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\r\n * @param {Object.<string,*>} object Plain object to convert\r\n * @returns {Message<{}>} Message instance\r\n */\r\nType.prototype.fromObject = function fromObject(object) {\r\n    return this.setup().fromObject(object);\r\n};\r\n\r\n/**\r\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\r\n * @interface IConversionOptions\r\n * @property {Function} [longs] Long conversion type.\r\n * Valid values are `String` and `Number` (the global types).\r\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\r\n * @property {Function} [enums] Enum value conversion type.\r\n * Only valid value is `String` (the global type).\r\n * Defaults to copy the present value, which is the numeric id.\r\n * @property {Function} [bytes] Bytes value conversion type.\r\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\r\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\r\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\r\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\r\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\r\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\r\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\r\n */\r\n\r\n/**\r\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\r\n * @param {Message<{}>} message Message instance\r\n * @param {IConversionOptions} [options] Conversion options\r\n * @returns {Object.<string,*>} Plain object\r\n */\r\nType.prototype.toObject = function toObject(message, options) {\r\n    return this.setup().toObject(message, options);\r\n};\r\n\r\n/**\r\n * Decorator function as returned by {@link Type.d} (TypeScript).\r\n * @typedef TypeDecorator\r\n * @type {function}\r\n * @param {Constructor<T>} target Target constructor\r\n * @returns {undefined}\r\n * @template T extends Message<T>\r\n */\r\n\r\n/**\r\n * Type decorator (TypeScript).\r\n * @param {string} [typeName] Type name, defaults to the constructor's name\r\n * @returns {TypeDecorator<T>} Decorator function\r\n * @template T extends Message<T>\r\n */\r\nType.d = function decorateType(typeName) {\r\n    return function typeDecorator(target) {\r\n        util.decorateType(target, typeName);\r\n    };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdHQUFhO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBUTtBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBWTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBUTtBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBWTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csZUFBZSwwR0FBMEcsY0FBYztBQUN2TztBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBK0M7QUFDbEUsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYyxZQUFZO0FBQzFCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDZCQUE2Qix1QkFBdUI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixhQUFhLE1BQU07QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYSxNQUFNO0FBQ25CLFlBQVksV0FBVztBQUN2QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLFVBQVUsR0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QixHQUFHLDBCQUEwQixLQUFLLHlCQUF5QjtBQUNoRyxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQStDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBCQUEwQjtBQUNsRixXQUFXLFVBQVUscUJBQXFCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsMEJBQTBCO0FBQzNILFdBQVcsVUFBVSxxQkFBcUI7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFVBQVUsR0FBRztBQUMxQixZQUFZLE9BQU87QUFDbkIsWUFBWSxxQkFBcUIsR0FBRztBQUNwQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxVQUFVLEdBQUc7QUFDMUIsWUFBWSxPQUFPO0FBQ25CLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxVQUFVLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQixLQUFLLHVCQUF1QjtBQUNuRjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLHdGQUF3RixZQUFZO0FBQ3BHLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLEdBQUc7QUFDeEIsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcz8wNjU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XHJcblxyXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxyXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xyXG4oKFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBUeXBlKS5jbGFzc05hbWUgPSBcIlR5cGVcIjtcclxuXHJcbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxyXG4gICAgT25lT2YgICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXHJcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcclxuICAgIE1hcEZpZWxkICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpLFxyXG4gICAgU2VydmljZSAgID0gcmVxdWlyZShcIi4vc2VydmljZVwiKSxcclxuICAgIE1lc3NhZ2UgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIiksXHJcbiAgICBSZWFkZXIgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIiksXHJcbiAgICBXcml0ZXIgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIiksXHJcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxyXG4gICAgZW5jb2RlciAgID0gcmVxdWlyZShcIi4vZW5jb2RlclwiKSxcclxuICAgIGRlY29kZXIgICA9IHJlcXVpcmUoXCIuL2RlY29kZXJcIiksXHJcbiAgICB2ZXJpZmllciAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKSxcclxuICAgIGNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlclwiKSxcclxuICAgIHdyYXBwZXJzICA9IHJlcXVpcmUoXCIuL3dyYXBwZXJzXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVmbGVjdGVkIG1lc3NhZ2UgdHlwZSBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSB0eXBlLlxyXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIFR5cGUobmFtZSwgb3B0aW9ucykge1xyXG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXNzYWdlIGZpZWxkcy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxGaWVsZD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmllbGRzID0ge307ICAvLyB0b0pTT04sIG1hcmtlclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT25lb2ZzIGRlY2xhcmVkIHdpdGhpbiB0aGlzIG5hbWVzcGFjZSwgaWYgYW55LlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLE9uZU9mPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vbmVvZnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5zaW9uIHJhbmdlcywgaWYgYW55LlxyXG4gICAgICogQHR5cGUge251bWJlcltdW119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cclxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyW118c3RyaW5nPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXHJcblxyXG4gICAgLyo/XHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgdHlwZSBpcyBhIGxlZ2FjeSBncm91cC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IGlkLlxyXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLEZpZWxkPnxudWxsfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZmllbGRzQnlJZCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgZmllbGRzIGFzIGFuIGFycmF5LlxyXG4gICAgICogQHR5cGUge0ZpZWxkW118bnVsbH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2ZpZWxkc0FycmF5ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBvbmVvZnMgYXMgYW4gYXJyYXkuXHJcbiAgICAgKiBAdHlwZSB7T25lT2ZbXXxudWxsfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fb25lb2ZzQXJyYXkgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2N0b3IgPSBudWxsO1xyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUeXBlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVzc2FnZSBmaWVsZHMgYnkgaWQuXHJcbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0J5SWRcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZmllbGRzQnlJZDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW25hbWVzW2ldXSxcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IGZpZWxkLmlkO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWRbaWRdKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWRbaWRdID0gZmllbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0J5SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpZWxkcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cclxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQXJyYXlcclxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGZpZWxkc0FycmF5OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0FycmF5IHx8ICh0aGlzLl9maWVsZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLmZpZWxkcykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmVvZnMgb2YgdGhpcyBtZXNzYWdlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXHJcbiAgICAgKiBAbmFtZSBUeXBlI29uZW9mc0FycmF5XHJcbiAgICAgKiBAdHlwZSB7T25lT2ZbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBvbmVvZnNBcnJheToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmVvZnNBcnJheSB8fCAodGhpcy5fb25lb2ZzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5vbmVvZnMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgY29uc3RydWN0b3IsIGlmIGFueSByZWdpc3RlcmVkLCBvdGhlcndpc2UgYSBnZW5lcmljIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQXNzaWduaW5nIGEgZnVuY3Rpb24gcmVwbGFjZXMgdGhlIGludGVybmFsIGNvbnN0cnVjdG9yLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgZXh0ZW5kIHtAbGluayBNZXNzYWdlfSB5ZXQsIGl0cyBwcm90b3R5cGUgd2lsbCBiZSBzZXR1cCBhY2NvcmRpbmdseSBhbmQgc3RhdGljIG1ldGhvZHMgd2lsbCBiZSBwb3B1bGF0ZWQuIElmIGl0IGFscmVhZHkgZXh0ZW5kcyB7QGxpbmsgTWVzc2FnZX0sIGl0IHdpbGwganVzdCByZXBsYWNlIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci5cclxuICAgICAqIEBuYW1lIFR5cGUjY3RvclxyXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cclxuICAgICAqL1xyXG4gICAgY3Rvcjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdG9yIHx8ICh0aGlzLmN0b3IgPSBUeXBlLmdlbmVyYXRlQ29uc3RydWN0b3IodGhpcykoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9wZXIgcHJvdG90eXBlXHJcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjdG9yLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgaWYgKCEocHJvdG90eXBlIGluc3RhbmNlb2YgTWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIChjdG9yLnByb3RvdHlwZSA9IG5ldyBNZXNzYWdlKCkpLmNvbnN0cnVjdG9yID0gY3RvcjtcclxuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UoY3Rvci5wcm90b3R5cGUsIHByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENsYXNzZXMgYW5kIG1lc3NhZ2VzIHJlZmVyZW5jZSB0aGVpciByZWZsZWN0ZWQgdHlwZVxyXG4gICAgICAgICAgICBjdG9yLiR0eXBlID0gY3Rvci5wcm90b3R5cGUuJHR5cGUgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gTWl4IGluIHN0YXRpYyBtZXRob2RzXHJcbiAgICAgICAgICAgIHV0aWwubWVyZ2UoY3RvciwgTWVzc2FnZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdG9yID0gY3RvcjtcclxuXHJcbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIGhhdmUgbm9uLWVudW1lcmFibGUgZGVmYXVsdCB2YWx1ZXMgb24gdGhlaXIgcHJvdG90eXBlXHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpOyAvLyBlbnN1cmVzIGEgcHJvcGVyIHZhbHVlXHJcblxyXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGVhY2ggdmlydHVhbCBvbmVvZiBmaWVsZFxyXG4gICAgICAgICAgICB2YXIgY3RvclByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBjdG9yUHJvcGVydGllc1t0aGlzLl9vbmVvZnNBcnJheVtpXS5yZXNvbHZlKCkubmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiB1dGlsLm9uZU9mR2V0dGVyKHRoaXMuX29uZW9mc0FycmF5W2ldLm9uZW9mKSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN0b3IucHJvdG90eXBlLCBjdG9yUHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLlxyXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxyXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxyXG4gKi9cclxuVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvcihtdHlwZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cclxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wicFwiXSwgbXR5cGUubmFtZSk7XHJcbiAgICAvLyBleHBsaWNpdGx5IGluaXRpYWxpemUgbXV0YWJsZSBvYmplY3QvYXJyYXkgZmllbGRzIHNvIHRoYXQgdGhlc2UgYXJlbid0IGp1c3QgaW5oZXJpdGVkIGZyb20gdGhlIHByb3RvdHlwZVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgaWYgKChmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXSkubWFwKSBnZW5cclxuICAgICAgICAgICAgKFwidGhpcyVzPXt9XCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xyXG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSBnZW5cclxuICAgICAgICAgICAgKFwidGhpcyVzPVtdXCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xyXG4gICAgcmV0dXJuIGdlblxyXG4gICAgKFwiaWYocClmb3IodmFyIGtzPU9iamVjdC5rZXlzKHApLGk9MDtpPGtzLmxlbmd0aDsrK2kpaWYocFtrc1tpXV0hPW51bGwpXCIpIC8vIG9taXQgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAoXCJ0aGlzW2tzW2ldXT1wW2tzW2ldXVwiKTtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cclxufTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFyQ2FjaGUodHlwZSkge1xyXG4gICAgdHlwZS5fZmllbGRzQnlJZCA9IHR5cGUuX2ZpZWxkc0FycmF5ID0gdHlwZS5fb25lb2ZzQXJyYXkgPSBudWxsO1xyXG4gICAgZGVsZXRlIHR5cGUuZW5jb2RlO1xyXG4gICAgZGVsZXRlIHR5cGUuZGVjb2RlO1xyXG4gICAgZGVsZXRlIHR5cGUudmVyaWZ5O1xyXG4gICAgcmV0dXJuIHR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cclxuICogQGludGVyZmFjZSBJVHlwZVxyXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSU9uZU9mPn0gW29uZW9mc10gT25lb2YgZGVzY3JpcHRvcnNcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJRmllbGQ+fSBmaWVsZHMgRmllbGQgZGVzY3JpcHRvcnNcclxuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbZXh0ZW5zaW9uc10gRXh0ZW5zaW9uIHJhbmdlc1xyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fSBbcmVzZXJ2ZWRdIFJlc2VydmVkIHJhbmdlc1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cD1mYWxzZV0gV2hldGhlciBhIGxlZ2FjeSBncm91cCBvciBub3RcclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG1lc3NhZ2UgdHlwZSBmcm9tIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxyXG4gKiBAcGFyYW0ge0lUeXBlfSBqc29uIE1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yXHJcbiAqIEByZXR1cm5zIHtUeXBlfSBDcmVhdGVkIG1lc3NhZ2UgdHlwZVxyXG4gKi9cclxuVHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcclxuICAgIHZhciB0eXBlID0gbmV3IFR5cGUobmFtZSwganNvbi5vcHRpb25zKTtcclxuICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcclxuICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xyXG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5maWVsZHMpLFxyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcclxuICAgICAgICB0eXBlLmFkZChcclxuICAgICAgICAgICAgKCB0eXBlb2YganNvbi5maWVsZHNbbmFtZXNbaV1dLmtleVR5cGUgIT09IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgICAgPyBNYXBGaWVsZC5mcm9tSlNPTlxyXG4gICAgICAgICAgICA6IEZpZWxkLmZyb21KU09OICkobmFtZXNbaV0sIGpzb24uZmllbGRzW25hbWVzW2ldXSlcclxuICAgICAgICApO1xyXG4gICAgaWYgKGpzb24ub25lb2ZzKVxyXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm9uZW9mcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm9uZW9mc1tuYW1lc1tpXV0pKTtcclxuICAgIGlmIChqc29uLm5lc3RlZClcclxuICAgICAgICBmb3IgKG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5uZXN0ZWQpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBqc29uLm5lc3RlZFtuYW1lc1tpXV07XHJcbiAgICAgICAgICAgIHR5cGUuYWRkKCAvLyBtb3N0IHRvIGxlYXN0IGxpa2VseVxyXG4gICAgICAgICAgICAgICAgKCBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxyXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuZmllbGRzICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxyXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gRW51bS5mcm9tSlNPTlxyXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cclxuICAgICAgICAgICAgICAgIDogTmFtZXNwYWNlLmZyb21KU09OICkobmFtZXNbaV0sIG5lc3RlZClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICBpZiAoanNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9ucy5sZW5ndGgpXHJcbiAgICAgICAgdHlwZS5leHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zO1xyXG4gICAgaWYgKGpzb24ucmVzZXJ2ZWQgJiYganNvbi5yZXNlcnZlZC5sZW5ndGgpXHJcbiAgICAgICAgdHlwZS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XHJcbiAgICBpZiAoanNvbi5ncm91cClcclxuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcclxuICAgIGlmIChqc29uLmNvbW1lbnQpXHJcbiAgICAgICAgdHlwZS5jb21tZW50ID0ganNvbi5jb21tZW50O1xyXG4gICAgcmV0dXJuIHR5cGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBtZXNzYWdlIHR5cGUgdG8gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cclxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtJVHlwZX0gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcclxuICovXHJcblR5cGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XHJcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcclxuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcclxuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcclxuICAgICAgICBcIm9wdGlvbnNcIiAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJvbmVvZnNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5vbmVvZnNBcnJheSwgdG9KU09OT3B0aW9ucyksXHJcbiAgICAgICAgXCJmaWVsZHNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7IHJldHVybiAhb2JqLmRlY2xhcmluZ0ZpZWxkOyB9KSwgdG9KU09OT3B0aW9ucykgfHwge30sXHJcbiAgICAgICAgXCJleHRlbnNpb25zXCIgLCB0aGlzLmV4dGVuc2lvbnMgJiYgdGhpcy5leHRlbnNpb25zLmxlbmd0aCA/IHRoaXMuZXh0ZW5zaW9ucyA6IHVuZGVmaW5lZCxcclxuICAgICAgICBcInJlc2VydmVkXCIgICAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIFwiZ3JvdXBcIiAgICAgICwgdGhpcy5ncm91cCB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJuZXN0ZWRcIiAgICAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgXCJjb21tZW50XCIgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcclxuICAgIF0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuVHlwZS5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XHJcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHNBcnJheSwgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGgpXHJcbiAgICAgICAgZmllbGRzW2krK10ucmVzb2x2ZSgpO1xyXG4gICAgdmFyIG9uZW9mcyA9IHRoaXMub25lb2ZzQXJyYXk7IGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBvbmVvZnMubGVuZ3RoKVxyXG4gICAgICAgIG9uZW9mc1tpKytdLnJlc29sdmUoKTtcclxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcblR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maWVsZHNbbmFtZV1cclxuICAgICAgICB8fCB0aGlzLm9uZW9mcyAmJiB0aGlzLm9uZW9mc1tuYW1lXVxyXG4gICAgICAgIHx8IHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXHJcbiAgICAgICAgfHwgbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgbmVzdGVkIG9iamVjdCB0byB0aGlzIHR5cGUuXHJcbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXHJcbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lIG9yLCBpZiBhIGZpZWxkLCB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYSBmaWVsZCB3aXRoIHRoaXMgaWRcclxuICovXHJcblR5cGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcclxuXHJcbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcclxuXHJcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gTk9URTogRXh0ZW5zaW9uIGZpZWxkcyBhcmVuJ3QgYWN0dWFsIGZpZWxkcyBvbiB0aGUgZGVjbGFyaW5nIHR5cGUsIGJ1dCBuZXN0ZWQgb2JqZWN0cy5cclxuICAgICAgICAvLyBUaGUgcm9vdCBvYmplY3QgdGFrZXMgY2FyZSBvZiBhZGRpbmcgZGlzdGluY3Qgc2lzdGVyLWZpZWxkcyB0byB0aGUgcmVzcGVjdGl2ZSBleHRlbmRlZFxyXG4gICAgICAgIC8vIHR5cGUgaW5zdGVhZC5cclxuXHJcbiAgICAgICAgLy8gYXZvaWRzIGNhbGxpbmcgdGhlIGdldHRlciBpZiBub3QgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIGNhbGxlZCBxdWl0ZSBmcmVxdWVudGx5XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLl9maWVsZHNCeUlkW29iamVjdC5pZF0gOiB0aGlzLmZpZWxkc0J5SWRbb2JqZWN0LmlkXSlcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBvYmplY3QuaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChvYmplY3QuaWQpKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlkIFwiICsgb2JqZWN0LmlkICsgXCIgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5pc1Jlc2VydmVkTmFtZShvYmplY3QubmFtZSkpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAob2JqZWN0LnBhcmVudClcclxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcclxuICAgICAgICB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XHJcbiAgICAgICAgb2JqZWN0Lm1lc3NhZ2UgPSB0aGlzO1xyXG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcclxuICAgIH1cclxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xyXG4gICAgICAgIGlmICghdGhpcy5vbmVvZnMpXHJcbiAgICAgICAgICAgIHRoaXMub25lb2ZzID0ge307XHJcbiAgICAgICAgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xyXG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGlzIHR5cGUuXHJcbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXHJcbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcclxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIHR5cGVcclxuICovXHJcblR5cGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcclxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBTZWUgVHlwZSNhZGQgZm9yIHRoZSByZWFzb24gd2h5IGV4dGVuc2lvbiBmaWVsZHMgYXJlIGV4Y2x1ZGVkIGhlcmUuXHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghdGhpcy5maWVsZHMgfHwgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xyXG5cclxuICAgICAgICBkZWxldGUgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdO1xyXG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcclxuICAgIH1cclxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIXRoaXMub25lb2ZzIHx8IHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcclxuXHJcbiAgICAgICAgZGVsZXRlIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXTtcclxuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcclxuICAgICAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBvYmplY3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQoaWQpIHtcclxuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IocHJvcGVydGllcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyB1cCB7QGxpbmsgVHlwZSNlbmNvZGV8ZW5jb2RlfSwge0BsaW5rIFR5cGUjZGVjb2RlfGRlY29kZX0gYW5kIHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9LlxyXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKCkge1xyXG4gICAgLy8gU2V0cyB1cCBldmVyeXRoaW5nIGF0IG9uY2Ugc28gdGhhdCB0aGUgcHJvdG90eXBlIGNoYWluIGRvZXMgbm90IGhhdmUgdG8gYmUgcmUtZXZhbHVhdGVkXHJcbiAgICAvLyBtdWx0aXBsZSB0aW1lcyAoVjgsIHNvZnQtZGVvcHQgcHJvdG90eXBlLWNoZWNrKS5cclxuXHJcbiAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmZ1bGxOYW1lLFxyXG4gICAgICAgIHR5cGVzICAgID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgdHlwZXMucHVzaCh0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCkucmVzb2x2ZWRUeXBlKTtcclxuXHJcbiAgICAvLyBSZXBsYWNlIHNldHVwIG1ldGhvZHMgd2l0aCB0eXBlLXNwZWNpZmljIGdlbmVyYXRlZCBmdW5jdGlvbnNcclxuICAgIHRoaXMuZW5jb2RlID0gZW5jb2Rlcih0aGlzKSh7XHJcbiAgICAgICAgV3JpdGVyIDogV3JpdGVyLFxyXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxyXG4gICAgICAgIHV0aWwgICA6IHV0aWxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5kZWNvZGUgPSBkZWNvZGVyKHRoaXMpKHtcclxuICAgICAgICBSZWFkZXIgOiBSZWFkZXIsXHJcbiAgICAgICAgdHlwZXMgIDogdHlwZXMsXHJcbiAgICAgICAgdXRpbCAgIDogdXRpbFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnZlcmlmeSA9IHZlcmlmaWVyKHRoaXMpKHtcclxuICAgICAgICB0eXBlcyA6IHR5cGVzLFxyXG4gICAgICAgIHV0aWwgIDogdXRpbFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmZyb21PYmplY3QgPSBjb252ZXJ0ZXIuZnJvbU9iamVjdCh0aGlzKSh7XHJcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcclxuICAgICAgICB1dGlsICA6IHV0aWxcclxuICAgIH0pO1xyXG4gICAgdGhpcy50b09iamVjdCA9IGNvbnZlcnRlci50b09iamVjdCh0aGlzKSh7XHJcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcclxuICAgICAgICB1dGlsICA6IHV0aWxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluamVjdCBjdXN0b20gd3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlc1xyXG4gICAgdmFyIHdyYXBwZXIgPSB3cmFwcGVyc1tmdWxsTmFtZV07XHJcbiAgICBpZiAod3JhcHBlcikge1xyXG4gICAgICAgIHZhciBvcmlnaW5hbFRoaXMgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xyXG4gICAgICAgIC8vIGlmICh3cmFwcGVyLmZyb21PYmplY3QpIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxUaGlzLmZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3Q7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbU9iamVjdCA9IHdyYXBwZXIuZnJvbU9iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGlmICh3cmFwcGVyLnRvT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy50b09iamVjdCA9IHRoaXMudG9PYmplY3Q7XHJcbiAgICAgICAgICAgIHRoaXMudG9PYmplY3QgPSB3cmFwcGVyLnRvT2JqZWN0LmJpbmQob3JpZ2luYWxUaGlzKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2Ugb3IgcGxhaW4gb2JqZWN0XHJcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxyXG4gKi9cclxuVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlX3NldHVwKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXHJcbn07XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIFR5cGUjdmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT58T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZSBvciBwbGFpbiBvYmplY3RcclxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICogQHJldHVybnMge1dyaXRlcn0gd3JpdGVyXHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyICYmIHdyaXRlci5sZW4gPyB3cml0ZXIuZm9yaygpIDogd3JpdGVyKS5sZGVsaW0oKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXHJcbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIG1lc3NhZ2UsIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBEZWNvZGVkIG1lc3NhZ2VcclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICogQHRocm93cyB7dXRpbC5Qcm90b2NvbEVycm9yPHt9Pn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGVfc2V0dXAocmVhZGVyLCBsZW5ndGgpIHtcclxuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZGVjb2RlKHJlYWRlciwgbGVuZ3RoKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gRGVjb2RlZCBtZXNzYWdlXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiBSZWFkZXIpKVxyXG4gICAgICAgIHJlYWRlciA9IFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVmVyaWZpZXMgdGhhdCBmaWVsZCB2YWx1ZXMgYXJlIHZhbGlkIGFuZCB0aGF0IHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudC5cclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XHJcbiAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlfc2V0dXAobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS52ZXJpZnkobWVzc2FnZSk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdCB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxyXG4gKi9cclxuVHlwZS5wcm90b3R5cGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmZyb21PYmplY3Qob2JqZWN0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJzaW9uIG9wdGlvbnMgYXMgdXNlZCBieSB7QGxpbmsgVHlwZSN0b09iamVjdH0gYW5kIHtAbGluayBNZXNzYWdlLnRvT2JqZWN0fS5cclxuICogQGludGVyZmFjZSBJQ29udmVyc2lvbk9wdGlvbnNcclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xvbmdzXSBMb25nIGNvbnZlcnNpb24gdHlwZS5cclxuICogVmFsaWQgdmFsdWVzIGFyZSBgU3RyaW5nYCBhbmQgYE51bWJlcmAgKHRoZSBnbG9iYWwgdHlwZXMpLlxyXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCBpcyBhIHBvc3NpYmx5IHVuc2FmZSBudW1iZXIgd2l0aG91dCBhbmQgYSB7QGxpbmsgTG9uZ30gd2l0aCBhIGxvbmcgbGlicmFyeS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2VudW1zXSBFbnVtIHZhbHVlIGNvbnZlcnNpb24gdHlwZS5cclxuICogT25seSB2YWxpZCB2YWx1ZSBpcyBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlKS5cclxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgdGhlIG51bWVyaWMgaWQuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtieXRlc10gQnl0ZXMgdmFsdWUgY29udmVyc2lvbiB0eXBlLlxyXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBBcnJheWAgYW5kIChhIGJhc2U2NCBlbmNvZGVkKSBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlcykuXHJcbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIHVzdWFsbHkgaXMgYSBCdWZmZXIgdW5kZXIgbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiB0aGUgYnJvd3Nlci5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVmYXVsdHM9ZmFsc2VdIEFsc28gc2V0cyBkZWZhdWx0IHZhbHVlcyBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdFxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheXM9ZmFsc2VdIFNldHMgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIHJlcGVhdGVkIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbb2JqZWN0cz1mYWxzZV0gU2V0cyBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG1hcCBmaWVsZHMgZXZlbiBpZiBgZGVmYXVsdHM9ZmFsc2VgXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uZW9mcz1mYWxzZV0gSW5jbHVkZXMgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHNldCB0byB0aGUgcHJlc2VudCBmaWVsZCdzIG5hbWUsIGlmIGFueVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqc29uPWZhbHNlXSBQZXJmb3JtcyBhZGRpdGlvbmFsIEpTT04gY29tcGF0aWJpbGl0eSBjb252ZXJzaW9ucywgaS5lLiBOYU4gYW5kIEluZmluaXR5IHRvIHN0cmluZ3NcclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHtNZXNzYWdlPHt9Pn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XHJcbiAqL1xyXG5UeXBlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNldHVwKCkudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBUeXBlLmR9IChUeXBlU2NyaXB0KS5cclxuICogQHR5cGVkZWYgVHlwZURlY29yYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IHRhcmdldCBUYXJnZXQgY29uc3RydWN0b3JcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cclxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXHJcbiAqIEByZXR1cm5zIHtUeXBlRGVjb3JhdG9yPFQ+fSBEZWNvcmF0b3IgZnVuY3Rpb25cclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XHJcbiAqL1xyXG5UeXBlLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUodHlwZU5hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiB0eXBlRGVjb3JhdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHRhcmdldCwgdHlwZU5hbWUpO1xyXG4gICAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\n/**\r\n * Common type constants.\r\n * @namespace\r\n */\r\nvar types = exports;\r\n\r\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nvar s = [\r\n    \"double\",   // 0\r\n    \"float\",    // 1\r\n    \"int32\",    // 2\r\n    \"uint32\",   // 3\r\n    \"sint32\",   // 4\r\n    \"fixed32\",  // 5\r\n    \"sfixed32\", // 6\r\n    \"int64\",    // 7\r\n    \"uint64\",   // 8\r\n    \"sint64\",   // 9\r\n    \"fixed64\",  // 10\r\n    \"sfixed64\", // 11\r\n    \"bool\",     // 12\r\n    \"string\",   // 13\r\n    \"bytes\"     // 14\r\n];\r\n\r\nfunction bake(values, offset) {\r\n    var i = 0, o = {};\r\n    offset |= 0;\r\n    while (i < values.length) o[s[i + offset]] = values[i++];\r\n    return o;\r\n}\r\n\r\n/**\r\n * Basic type wire types.\r\n * @type {Object.<string,number>}\r\n * @const\r\n * @property {number} double=1 Fixed64 wire type\r\n * @property {number} float=5 Fixed32 wire type\r\n * @property {number} int32=0 Varint wire type\r\n * @property {number} uint32=0 Varint wire type\r\n * @property {number} sint32=0 Varint wire type\r\n * @property {number} fixed32=5 Fixed32 wire type\r\n * @property {number} sfixed32=5 Fixed32 wire type\r\n * @property {number} int64=0 Varint wire type\r\n * @property {number} uint64=0 Varint wire type\r\n * @property {number} sint64=0 Varint wire type\r\n * @property {number} fixed64=1 Fixed64 wire type\r\n * @property {number} sfixed64=1 Fixed64 wire type\r\n * @property {number} bool=0 Varint wire type\r\n * @property {number} string=2 Ldelim wire type\r\n * @property {number} bytes=2 Ldelim wire type\r\n */\r\ntypes.basic = bake([\r\n    /* double   */ 1,\r\n    /* float    */ 5,\r\n    /* int32    */ 0,\r\n    /* uint32   */ 0,\r\n    /* sint32   */ 0,\r\n    /* fixed32  */ 5,\r\n    /* sfixed32 */ 5,\r\n    /* int64    */ 0,\r\n    /* uint64   */ 0,\r\n    /* sint64   */ 0,\r\n    /* fixed64  */ 1,\r\n    /* sfixed64 */ 1,\r\n    /* bool     */ 0,\r\n    /* string   */ 2,\r\n    /* bytes    */ 2\r\n]);\r\n\r\n/**\r\n * Basic type defaults.\r\n * @type {Object.<string,*>}\r\n * @const\r\n * @property {number} double=0 Double default\r\n * @property {number} float=0 Float default\r\n * @property {number} int32=0 Int32 default\r\n * @property {number} uint32=0 Uint32 default\r\n * @property {number} sint32=0 Sint32 default\r\n * @property {number} fixed32=0 Fixed32 default\r\n * @property {number} sfixed32=0 Sfixed32 default\r\n * @property {number} int64=0 Int64 default\r\n * @property {number} uint64=0 Uint64 default\r\n * @property {number} sint64=0 Sint32 default\r\n * @property {number} fixed64=0 Fixed64 default\r\n * @property {number} sfixed64=0 Sfixed64 default\r\n * @property {boolean} bool=false Bool default\r\n * @property {string} string=\"\" String default\r\n * @property {Array.<number>} bytes=Array(0) Bytes default\r\n * @property {null} message=null Message default\r\n */\r\ntypes.defaults = bake([\r\n    /* double   */ 0,\r\n    /* float    */ 0,\r\n    /* int32    */ 0,\r\n    /* uint32   */ 0,\r\n    /* sint32   */ 0,\r\n    /* fixed32  */ 0,\r\n    /* sfixed32 */ 0,\r\n    /* int64    */ 0,\r\n    /* uint64   */ 0,\r\n    /* sint64   */ 0,\r\n    /* fixed64  */ 0,\r\n    /* sfixed64 */ 0,\r\n    /* bool     */ false,\r\n    /* string   */ \"\",\r\n    /* bytes    */ util.emptyArray,\r\n    /* message  */ null\r\n]);\r\n\r\n/**\r\n * Basic long type wire types.\r\n * @type {Object.<string,number>}\r\n * @const\r\n * @property {number} int64=0 Varint wire type\r\n * @property {number} uint64=0 Varint wire type\r\n * @property {number} sint64=0 Varint wire type\r\n * @property {number} fixed64=1 Fixed64 wire type\r\n * @property {number} sfixed64=1 Fixed64 wire type\r\n */\r\ntypes.long = bake([\r\n    /* int64    */ 0,\r\n    /* uint64   */ 0,\r\n    /* sint64   */ 0,\r\n    /* fixed64  */ 1,\r\n    /* sfixed64 */ 1\r\n], 7);\r\n\r\n/**\r\n * Allowed types for map keys with their associated wire type.\r\n * @type {Object.<string,number>}\r\n * @const\r\n * @property {number} int32=0 Varint wire type\r\n * @property {number} uint32=0 Varint wire type\r\n * @property {number} sint32=0 Varint wire type\r\n * @property {number} fixed32=5 Fixed32 wire type\r\n * @property {number} sfixed32=5 Fixed32 wire type\r\n * @property {number} int64=0 Varint wire type\r\n * @property {number} uint64=0 Varint wire type\r\n * @property {number} sint64=0 Varint wire type\r\n * @property {number} fixed64=1 Fixed64 wire type\r\n * @property {number} sfixed64=1 Fixed64 wire type\r\n * @property {number} bool=0 Varint wire type\r\n * @property {number} string=2 Ldelim wire type\r\n */\r\ntypes.mapKey = bake([\r\n    /* int32    */ 0,\r\n    /* uint32   */ 0,\r\n    /* sint32   */ 0,\r\n    /* fixed32  */ 5,\r\n    /* sfixed32 */ 5,\r\n    /* int64    */ 0,\r\n    /* uint64   */ 0,\r\n    /* sint64   */ 0,\r\n    /* fixed64  */ 1,\r\n    /* sfixed64 */ 1,\r\n    /* bool     */ 0,\r\n    /* string   */ 2\r\n], 2);\r\n\r\n/**\r\n * Allowed types for packed repeated fields with their associated wire type.\r\n * @type {Object.<string,number>}\r\n * @const\r\n * @property {number} double=1 Fixed64 wire type\r\n * @property {number} float=5 Fixed32 wire type\r\n * @property {number} int32=0 Varint wire type\r\n * @property {number} uint32=0 Varint wire type\r\n * @property {number} sint32=0 Varint wire type\r\n * @property {number} fixed32=5 Fixed32 wire type\r\n * @property {number} sfixed32=5 Fixed32 wire type\r\n * @property {number} int64=0 Varint wire type\r\n * @property {number} uint64=0 Varint wire type\r\n * @property {number} sint64=0 Varint wire type\r\n * @property {number} fixed64=1 Fixed64 wire type\r\n * @property {number} sfixed64=1 Fixed64 wire type\r\n * @property {number} bool=0 Varint wire type\r\n */\r\ntypes.packed = bake([\r\n    /* double   */ 1,\r\n    /* float    */ 5,\r\n    /* int32    */ 0,\r\n    /* uint32   */ 0,\r\n    /* sint32   */ 0,\r\n    /* fixed32  */ 5,\r\n    /* sfixed32 */ 5,\r\n    /* int64    */ 0,\r\n    /* uint64   */ 0,\r\n    /* sint64   */ 0,\r\n    /* fixed64  */ 1,\r\n    /* sfixed64 */ 1,\r\n    /* bool     */ 0\r\n]);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxzRkFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGVzLmpzP2NhNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQ29tbW9uIHR5cGUgY29uc3RhbnRzLlxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdHlwZXMgPSBleHBvcnRzO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG5cclxudmFyIHMgPSBbXHJcbiAgICBcImRvdWJsZVwiLCAgIC8vIDBcclxuICAgIFwiZmxvYXRcIiwgICAgLy8gMVxyXG4gICAgXCJpbnQzMlwiLCAgICAvLyAyXHJcbiAgICBcInVpbnQzMlwiLCAgIC8vIDNcclxuICAgIFwic2ludDMyXCIsICAgLy8gNFxyXG4gICAgXCJmaXhlZDMyXCIsICAvLyA1XHJcbiAgICBcInNmaXhlZDMyXCIsIC8vIDZcclxuICAgIFwiaW50NjRcIiwgICAgLy8gN1xyXG4gICAgXCJ1aW50NjRcIiwgICAvLyA4XHJcbiAgICBcInNpbnQ2NFwiLCAgIC8vIDlcclxuICAgIFwiZml4ZWQ2NFwiLCAgLy8gMTBcclxuICAgIFwic2ZpeGVkNjRcIiwgLy8gMTFcclxuICAgIFwiYm9vbFwiLCAgICAgLy8gMTJcclxuICAgIFwic3RyaW5nXCIsICAgLy8gMTNcclxuICAgIFwiYnl0ZXNcIiAgICAgLy8gMTRcclxuXTtcclxuXHJcbmZ1bmN0aW9uIGJha2UodmFsdWVzLCBvZmZzZXQpIHtcclxuICAgIHZhciBpID0gMCwgbyA9IHt9O1xyXG4gICAgb2Zmc2V0IHw9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHZhbHVlcy5sZW5ndGgpIG9bc1tpICsgb2Zmc2V0XV0gPSB2YWx1ZXNbaSsrXTtcclxuICAgIHJldHVybiBvO1xyXG59XHJcblxyXG4vKipcclxuICogQmFzaWMgdHlwZSB3aXJlIHR5cGVzLlxyXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cclxuICogQGNvbnN0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9NSBGaXhlZDMyIHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RyaW5nPTIgTGRlbGltIHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXM9MiBMZGVsaW0gd2lyZSB0eXBlXHJcbiAqL1xyXG50eXBlcy5iYXNpYyA9IGJha2UoW1xyXG4gICAgLyogZG91YmxlICAgKi8gMSxcclxuICAgIC8qIGZsb2F0ICAgICovIDUsXHJcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxyXG4gICAgLyogdWludDMyICAgKi8gMCxcclxuICAgIC8qIHNpbnQzMiAgICovIDAsXHJcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxyXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcclxuICAgIC8qIGludDY0ICAgICovIDAsXHJcbiAgICAvKiB1aW50NjQgICAqLyAwLFxyXG4gICAgLyogc2ludDY0ICAgKi8gMCxcclxuICAgIC8qIGZpeGVkNjQgICovIDEsXHJcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxyXG4gICAgLyogYm9vbCAgICAgKi8gMCxcclxuICAgIC8qIHN0cmluZyAgICovIDIsXHJcbiAgICAvKiBieXRlcyAgICAqLyAyXHJcbl0pO1xyXG5cclxuLyoqXHJcbiAqIEJhc2ljIHR5cGUgZGVmYXVsdHMuXHJcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICogQGNvbnN0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MCBEb3VibGUgZGVmYXVsdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9MCBGbG9hdCBkZWZhdWx0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIEludDMyIGRlZmF1bHRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFVpbnQzMiBkZWZhdWx0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBTaW50MzIgZGVmYXVsdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj0wIEZpeGVkMzIgZGVmYXVsdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9MCBTZml4ZWQzMiBkZWZhdWx0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIEludDY0IGRlZmF1bHRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFVpbnQ2NCBkZWZhdWx0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBTaW50MzIgZGVmYXVsdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0wIEZpeGVkNjQgZGVmYXVsdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MCBTZml4ZWQ2NCBkZWZhdWx0XHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYm9vbD1mYWxzZSBCb29sIGRlZmF1bHRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0cmluZz1cIlwiIFN0cmluZyBkZWZhdWx0XHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IGJ5dGVzPUFycmF5KDApIEJ5dGVzIGRlZmF1bHRcclxuICogQHByb3BlcnR5IHtudWxsfSBtZXNzYWdlPW51bGwgTWVzc2FnZSBkZWZhdWx0XHJcbiAqL1xyXG50eXBlcy5kZWZhdWx0cyA9IGJha2UoW1xyXG4gICAgLyogZG91YmxlICAgKi8gMCxcclxuICAgIC8qIGZsb2F0ICAgICovIDAsXHJcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxyXG4gICAgLyogdWludDMyICAgKi8gMCxcclxuICAgIC8qIHNpbnQzMiAgICovIDAsXHJcbiAgICAvKiBmaXhlZDMyICAqLyAwLFxyXG4gICAgLyogc2ZpeGVkMzIgKi8gMCxcclxuICAgIC8qIGludDY0ICAgICovIDAsXHJcbiAgICAvKiB1aW50NjQgICAqLyAwLFxyXG4gICAgLyogc2ludDY0ICAgKi8gMCxcclxuICAgIC8qIGZpeGVkNjQgICovIDAsXHJcbiAgICAvKiBzZml4ZWQ2NCAqLyAwLFxyXG4gICAgLyogYm9vbCAgICAgKi8gZmFsc2UsXHJcbiAgICAvKiBzdHJpbmcgICAqLyBcIlwiLFxyXG4gICAgLyogYnl0ZXMgICAgKi8gdXRpbC5lbXB0eUFycmF5LFxyXG4gICAgLyogbWVzc2FnZSAgKi8gbnVsbFxyXG5dKTtcclxuXHJcbi8qKlxyXG4gKiBCYXNpYyBsb25nIHR5cGUgd2lyZSB0eXBlcy5cclxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcclxuICovXHJcbnR5cGVzLmxvbmcgPSBiYWtlKFtcclxuICAgIC8qIGludDY0ICAgICovIDAsXHJcbiAgICAvKiB1aW50NjQgICAqLyAwLFxyXG4gICAgLyogc2ludDY0ICAgKi8gMCxcclxuICAgIC8qIGZpeGVkNjQgICovIDEsXHJcbiAgICAvKiBzZml4ZWQ2NCAqLyAxXHJcbl0sIDcpO1xyXG5cclxuLyoqXHJcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIG1hcCBrZXlzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3aXJlIHR5cGUuXHJcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxyXG4gKiBAY29uc3RcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcclxuICovXHJcbnR5cGVzLm1hcEtleSA9IGJha2UoW1xyXG4gICAgLyogaW50MzIgICAgKi8gMCxcclxuICAgIC8qIHVpbnQzMiAgICovIDAsXHJcbiAgICAvKiBzaW50MzIgICAqLyAwLFxyXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcclxuICAgIC8qIHNmaXhlZDMyICovIDUsXHJcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxyXG4gICAgLyogdWludDY0ICAgKi8gMCxcclxuICAgIC8qIHNpbnQ2NCAgICovIDAsXHJcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxyXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcclxuICAgIC8qIGJvb2wgICAgICovIDAsXHJcbiAgICAvKiBzdHJpbmcgICAqLyAyXHJcbl0sIDIpO1xyXG5cclxuLyoqXHJcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdpcmUgdHlwZS5cclxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcclxuICovXHJcbnR5cGVzLnBhY2tlZCA9IGJha2UoW1xyXG4gICAgLyogZG91YmxlICAgKi8gMSxcclxuICAgIC8qIGZsb2F0ICAgICovIDUsXHJcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxyXG4gICAgLyogdWludDMyICAgKi8gMCxcclxuICAgIC8qIHNpbnQzMiAgICovIDAsXHJcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxyXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcclxuICAgIC8qIGludDY0ICAgICovIDAsXHJcbiAgICAvKiB1aW50NjQgICAqLyAwLFxyXG4gICAgLyogc2ludDY0ICAgKi8gMCxcclxuICAgIC8qIGZpeGVkNjQgICovIDEsXHJcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxyXG4gICAgLyogYm9vbCAgICAgKi8gMFxyXG5dKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\n/**\r\n * Various utility functions.\r\n * @namespace\r\n */\r\nvar util = module.exports = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar roots = __webpack_require__(/*! ./roots */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js\");\r\n\r\nvar Type, // cyclic\r\n    Enum;\r\n\r\nutil.codegen = __webpack_require__(/*! @protobufjs/codegen */ \"(ssr)/./node_modules/@protobufjs/codegen/index.js\");\r\nutil.fetch   = __webpack_require__(/*! @protobufjs/fetch */ \"(ssr)/./node_modules/@protobufjs/fetch/index.js\");\r\nutil.path    = __webpack_require__(/*! @protobufjs/path */ \"(ssr)/./node_modules/@protobufjs/path/index.js\");\r\n\r\n/**\r\n * Node's fs module if available.\r\n * @type {Object.<string,*>}\r\n */\r\nutil.fs = util.inquire(\"fs\");\r\n\r\n/**\r\n * Converts an object's values to an array.\r\n * @param {Object.<string,*>} object Object to convert\r\n * @returns {Array.<*>} Converted array\r\n */\r\nutil.toArray = function toArray(object) {\r\n    if (object) {\r\n        var keys  = Object.keys(object),\r\n            array = new Array(keys.length),\r\n            index = 0;\r\n        while (index < keys.length)\r\n            array[index] = object[keys[index++]];\r\n        return array;\r\n    }\r\n    return [];\r\n};\r\n\r\n/**\r\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\r\n * @param {Array.<*>} array Array to convert\r\n * @returns {Object.<string,*>} Converted object\r\n */\r\nutil.toObject = function toObject(array) {\r\n    var object = {},\r\n        index  = 0;\r\n    while (index < array.length) {\r\n        var key = array[index++],\r\n            val = array[index++];\r\n        if (val !== undefined)\r\n            object[key] = val;\r\n    }\r\n    return object;\r\n};\r\n\r\nvar safePropBackslashRe = /\\\\/g,\r\n    safePropQuoteRe     = /\"/g;\r\n\r\n/**\r\n * Tests whether the specified name is a reserved word in JS.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nutil.isReserved = function isReserved(name) {\r\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\r\n};\r\n\r\n/**\r\n * Returns a safe property accessor for the specified property name.\r\n * @param {string} prop Property name\r\n * @returns {string} Safe accessor\r\n */\r\nutil.safeProp = function safeProp(prop) {\r\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\r\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\r\n    return \".\" + prop;\r\n};\r\n\r\n/**\r\n * Converts the first character of a string to upper case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.ucFirst = function ucFirst(str) {\r\n    return str.charAt(0).toUpperCase() + str.substring(1);\r\n};\r\n\r\nvar camelCaseRe = /_([a-z])/g;\r\n\r\n/**\r\n * Converts a string to camel case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.camelCase = function camelCase(str) {\r\n    return str.substring(0, 1)\r\n         + str.substring(1)\r\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\r\n};\r\n\r\n/**\r\n * Compares reflected fields by id.\r\n * @param {Field} a First field\r\n * @param {Field} b Second field\r\n * @returns {number} Comparison value\r\n */\r\nutil.compareFieldsById = function compareFieldsById(a, b) {\r\n    return a.id - b.id;\r\n};\r\n\r\n/**\r\n * Decorator helper for types (TypeScript).\r\n * @param {Constructor<T>} ctor Constructor function\r\n * @param {string} [typeName] Type name, defaults to the constructor's name\r\n * @returns {Type} Reflected type\r\n * @template T extends Message<T>\r\n * @property {Root} root Decorators root\r\n */\r\nutil.decorateType = function decorateType(ctor, typeName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (ctor.$type) {\r\n        if (typeName && ctor.$type.name !== typeName) {\r\n            util.decorateRoot.remove(ctor.$type);\r\n            ctor.$type.name = typeName;\r\n            util.decorateRoot.add(ctor.$type);\r\n        }\r\n        return ctor.$type;\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (!Type)\r\n        Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\");\r\n\r\n    var type = new Type(typeName || ctor.name);\r\n    util.decorateRoot.add(type);\r\n    type.ctor = ctor; // sets up .encode, .decode etc.\r\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\r\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\r\n    return type;\r\n};\r\n\r\nvar decorateEnumIndex = 0;\r\n\r\n/**\r\n * Decorator helper for enums (TypeScript).\r\n * @param {Object} object Enum object\r\n * @returns {Enum} Reflected enum\r\n */\r\nutil.decorateEnum = function decorateEnum(object) {\r\n\r\n    /* istanbul ignore if */\r\n    if (object.$type)\r\n        return object.$type;\r\n\r\n    /* istanbul ignore next */\r\n    if (!Enum)\r\n        Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\");\r\n\r\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\r\n    util.decorateRoot.add(enm);\r\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\r\n    return enm;\r\n};\r\n\r\n\r\n/**\r\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {string} path dot '.' delimited path of the property to set\r\n * @param {Object} value the value to set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nutil.setProperty = function setProperty(dst, path, value) {\r\n    function setProp(dst, path, value) {\r\n        var part = path.shift();\r\n        if (part === \"__proto__\" || part === \"prototype\") {\r\n          return dst;\r\n        }\r\n        if (path.length > 0) {\r\n            dst[part] = setProp(dst[part] || {}, path, value);\r\n        } else {\r\n            var prevValue = dst[part];\r\n            if (prevValue)\r\n                value = [].concat(prevValue).concat(value);\r\n            dst[part] = value;\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    if (typeof dst !== \"object\")\r\n        throw TypeError(\"dst must be an object\");\r\n    if (!path)\r\n        throw TypeError(\"path must be specified\");\r\n\r\n    path = path.split(\".\");\r\n    return setProp(dst, path, value);\r\n};\r\n\r\n/**\r\n * Decorator root (TypeScript).\r\n * @name util.decorateRoot\r\n * @type {Root}\r\n * @readonly\r\n */\r\nObject.defineProperty(util, \"decorateRoot\", {\r\n    get: function() {\r\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (__webpack_require__(/*! ./root */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\"))());\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRJQUEwQztBQUNyRDtBQUNBLFlBQVksbUJBQU8sQ0FBQyx3RkFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBcUI7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLDBFQUFtQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsd0VBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwwQkFBMEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNGQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwyQ0FBMkMsZ0NBQWdDO0FBQzNFLHFEQUFxRCxnQ0FBZ0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzRkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxtQkFBTyxDQUFDLHNGQUFRO0FBQ2hGO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsLmpzP2I2OWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucy5cclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciByb290cyA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xyXG5cclxudmFyIFR5cGUsIC8vIGN5Y2xpY1xyXG4gICAgRW51bTtcclxuXHJcbnV0aWwuY29kZWdlbiA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9jb2RlZ2VuXCIpO1xyXG51dGlsLmZldGNoICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmV0Y2hcIik7XHJcbnV0aWwucGF0aCAgICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wYXRoXCIpO1xyXG5cclxuLyoqXHJcbiAqIE5vZGUncyBmcyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxyXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAqL1xyXG51dGlsLmZzID0gdXRpbC5pbnF1aXJlKFwiZnNcIik7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gb2JqZWN0J3MgdmFsdWVzIHRvIGFuIGFycmF5LlxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgT2JqZWN0IHRvIGNvbnZlcnRcclxuICogQHJldHVybnMge0FycmF5LjwqPn0gQ29udmVydGVkIGFycmF5XHJcbiAqL1xyXG51dGlsLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KG9iamVjdCkge1xyXG4gICAgaWYgKG9iamVjdCkge1xyXG4gICAgICAgIHZhciBrZXlzICA9IE9iamVjdC5rZXlzKG9iamVjdCksXHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKSxcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGtleXMubGVuZ3RoKVxyXG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSBvYmplY3Rba2V5c1tpbmRleCsrXV07XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGtleXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZSB0byBhbiBvYmplY3QsIG9taXR0aW5nIHVuZGVmaW5lZCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnJheSBBcnJheSB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gQ29udmVydGVkIG9iamVjdFxyXG4gKi9cclxudXRpbC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KGFycmF5KSB7XHJcbiAgICB2YXIgb2JqZWN0ID0ge30sXHJcbiAgICAgICAgaW5kZXggID0gMDtcclxuICAgIHdoaWxlIChpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBhcnJheVtpbmRleCsrXSxcclxuICAgICAgICAgICAgdmFsID0gYXJyYXlbaW5kZXgrK107XHJcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbDtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3Q7XHJcbn07XHJcblxyXG52YXIgc2FmZVByb3BCYWNrc2xhc2hSZSA9IC9cXFxcL2csXHJcbiAgICBzYWZlUHJvcFF1b3RlUmUgICAgID0gL1wiL2c7XHJcblxyXG4vKipcclxuICogVGVzdHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgYSByZXNlcnZlZCB3b3JkIGluIEpTLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICovXHJcbnV0aWwuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWQobmFtZSkge1xyXG4gICAgcmV0dXJuIC9eKD86ZG98aWZ8aW58Zm9yfGxldHxuZXd8dHJ5fHZhcnxjYXNlfGVsc2V8ZW51bXxldmFsfGZhbHNlfG51bGx8dGhpc3x0cnVlfHZvaWR8d2l0aHxicmVha3xjYXRjaHxjbGFzc3xjb25zdHxzdXBlcnx0aHJvd3x3aGlsZXx5aWVsZHxkZWxldGV8ZXhwb3J0fGltcG9ydHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzd2l0Y2h8dHlwZW9mfGRlZmF1bHR8ZXh0ZW5kc3xmaW5hbGx5fHBhY2thZ2V8cHJpdmF0ZXxjb250aW51ZXxkZWJ1Z2dlcnxmdW5jdGlvbnxhcmd1bWVudHN8aW50ZXJmYWNlfHByb3RlY3RlZHxpbXBsZW1lbnRzfGluc3RhbmNlb2YpJC8udGVzdChuYW1lKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2FmZSBwcm9wZXJ0eSBhY2Nlc3NvciBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFNhZmUgYWNjZXNzb3JcclxuICovXHJcbnV0aWwuc2FmZVByb3AgPSBmdW5jdGlvbiBzYWZlUHJvcChwcm9wKSB7XHJcbiAgICBpZiAoIS9eWyRcXHdfXSskLy50ZXN0KHByb3ApIHx8IHV0aWwuaXNSZXNlcnZlZChwcm9wKSlcclxuICAgICAgICByZXR1cm4gXCJbXFxcIlwiICsgcHJvcC5yZXBsYWNlKHNhZmVQcm9wQmFja3NsYXNoUmUsIFwiXFxcXFxcXFxcIikucmVwbGFjZShzYWZlUHJvcFF1b3RlUmUsIFwiXFxcXFxcXCJcIikgKyBcIlxcXCJdXCI7XHJcbiAgICByZXR1cm4gXCIuXCIgKyBwcm9wO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXHJcbiAqL1xyXG51dGlsLnVjRmlyc3QgPSBmdW5jdGlvbiB1Y0ZpcnN0KHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XHJcbn07XHJcblxyXG52YXIgY2FtZWxDYXNlUmUgPSAvXyhbYS16XSkvZztcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcclxuICovXHJcbnV0aWwuY2FtZWxDYXNlID0gZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMSlcclxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXHJcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKGNhbWVsQ2FzZVJlLCBmdW5jdGlvbigkMCwgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHJlZmxlY3RlZCBmaWVsZHMgYnkgaWQuXHJcbiAqIEBwYXJhbSB7RmllbGR9IGEgRmlyc3QgZmllbGRcclxuICogQHBhcmFtIHtGaWVsZH0gYiBTZWNvbmQgZmllbGRcclxuICogQHJldHVybnMge251bWJlcn0gQ29tcGFyaXNvbiB2YWx1ZVxyXG4gKi9cclxudXRpbC5jb21wYXJlRmllbGRzQnlJZCA9IGZ1bmN0aW9uIGNvbXBhcmVGaWVsZHNCeUlkKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmlkIC0gYi5pZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciB0eXBlcyAoVHlwZVNjcmlwdCkuXHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXHJcbiAqIEByZXR1cm5zIHtUeXBlfSBSZWZsZWN0ZWQgdHlwZVxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cclxuICogQHByb3BlcnR5IHtSb290fSByb290IERlY29yYXRvcnMgcm9vdFxyXG4gKi9cclxudXRpbC5kZWNvcmF0ZVR5cGUgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUoY3RvciwgdHlwZU5hbWUpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChjdG9yLiR0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVOYW1lICYmIGN0b3IuJHR5cGUubmFtZSAhPT0gdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QucmVtb3ZlKGN0b3IuJHR5cGUpO1xyXG4gICAgICAgICAgICBjdG9yLiR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcclxuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGN0b3IuJHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3Rvci4kdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKCFUeXBlKVxyXG4gICAgICAgIFR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xyXG5cclxuICAgIHZhciB0eXBlID0gbmV3IFR5cGUodHlwZU5hbWUgfHwgY3Rvci5uYW1lKTtcclxuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZCh0eXBlKTtcclxuICAgIHR5cGUuY3RvciA9IGN0b3I7IC8vIHNldHMgdXAgLmVuY29kZSwgLmRlY29kZSBldGMuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3RvciwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcclxuICAgIHJldHVybiB0eXBlO1xyXG59O1xyXG5cclxudmFyIGRlY29yYXRlRW51bUluZGV4ID0gMDtcclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciBlbnVtcyAoVHlwZVNjcmlwdCkuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgRW51bSBvYmplY3RcclxuICogQHJldHVybnMge0VudW19IFJlZmxlY3RlZCBlbnVtXHJcbiAqL1xyXG51dGlsLmRlY29yYXRlRW51bSA9IGZ1bmN0aW9uIGRlY29yYXRlRW51bShvYmplY3QpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChvYmplY3QuJHR5cGUpXHJcbiAgICAgICAgcmV0dXJuIG9iamVjdC4kdHlwZTtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKCFFbnVtKVxyXG4gICAgICAgIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xyXG5cclxuICAgIHZhciBlbm0gPSBuZXcgRW51bShcIkVudW1cIiArIGRlY29yYXRlRW51bUluZGV4KyssIG9iamVjdCk7XHJcbiAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoZW5tKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFwiJHR5cGVcIiwgeyB2YWx1ZTogZW5tLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcclxuICAgIHJldHVybiBlbm07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYnkgcHJvcGVydHkgcGF0aC4gSWYgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cywgaXQgaXMgdHVybmVkIHRvIGFuIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZG90ICcuJyBkZWxpbWl0ZWQgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XHJcbiAqL1xyXG51dGlsLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoZHN0LCBwYXRoLCB2YWx1ZSkge1xyXG4gICAgZnVuY3Rpb24gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKHBhcnQgPT09IFwiX19wcm90b19fXCIgfHwgcGFydCA9PT0gXCJwcm90b3R5cGVcIikge1xyXG4gICAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBkc3RbcGFydF0gPSBzZXRQcm9wKGRzdFtwYXJ0XSB8fCB7fSwgcGF0aCwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBkc3RbcGFydF07XHJcbiAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGRzdFtwYXJ0XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZHN0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZHN0ICE9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImRzdCBtdXN0IGJlIGFuIG9iamVjdFwiKTtcclxuICAgIGlmICghcGF0aClcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJwYXRoIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xyXG5cclxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgIHJldHVybiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciByb290IChUeXBlU2NyaXB0KS5cclxuICogQG5hbWUgdXRpbC5kZWNvcmF0ZVJvb3RcclxuICogQHR5cGUge1Jvb3R9XHJcbiAqIEByZWFkb25seVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHV0aWwsIFwiZGVjb3JhdGVSb290XCIsIHtcclxuICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3RzW1wiZGVjb3JhdGVkXCJdIHx8IChyb290c1tcImRlY29yYXRlZFwiXSA9IG5ldyAocmVxdWlyZShcIi4vcm9vdFwiKSkoKSk7XHJcbiAgICB9XHJcbn0pO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = LongBits;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs new long bits.\r\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\r\n * @memberof util\r\n * @constructor\r\n * @param {number} lo Low 32 bits, unsigned\r\n * @param {number} hi High 32 bits, unsigned\r\n */\r\nfunction LongBits(lo, hi) {\r\n\r\n    // note that the casts below are theoretically unnecessary as of today, but older statically\r\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\r\n\r\n    /**\r\n     * Low bits.\r\n     * @type {number}\r\n     */\r\n    this.lo = lo >>> 0;\r\n\r\n    /**\r\n     * High bits.\r\n     * @type {number}\r\n     */\r\n    this.hi = hi >>> 0;\r\n}\r\n\r\n/**\r\n * Zero bits.\r\n * @memberof util.LongBits\r\n * @type {util.LongBits}\r\n */\r\nvar zero = LongBits.zero = new LongBits(0, 0);\r\n\r\nzero.toNumber = function() { return 0; };\r\nzero.zzEncode = zero.zzDecode = function() { return this; };\r\nzero.length = function() { return 1; };\r\n\r\n/**\r\n * Zero hash.\r\n * @memberof util.LongBits\r\n * @type {string}\r\n */\r\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\r\n\r\n/**\r\n * Constructs new long bits from the specified number.\r\n * @param {number} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.fromNumber = function fromNumber(value) {\r\n    if (value === 0)\r\n        return zero;\r\n    var sign = value < 0;\r\n    if (sign)\r\n        value = -value;\r\n    var lo = value >>> 0,\r\n        hi = (value - lo) / 4294967296 >>> 0;\r\n    if (sign) {\r\n        hi = ~hi >>> 0;\r\n        lo = ~lo >>> 0;\r\n        if (++lo > 4294967295) {\r\n            lo = 0;\r\n            if (++hi > 4294967295)\r\n                hi = 0;\r\n        }\r\n    }\r\n    return new LongBits(lo, hi);\r\n};\r\n\r\n/**\r\n * Constructs new long bits from a number, long or string.\r\n * @param {Long|number|string} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.from = function from(value) {\r\n    if (typeof value === \"number\")\r\n        return LongBits.fromNumber(value);\r\n    if (util.isString(value)) {\r\n        /* istanbul ignore else */\r\n        if (util.Long)\r\n            value = util.Long.fromString(value);\r\n        else\r\n            return LongBits.fromNumber(parseInt(value, 10));\r\n    }\r\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a possibly unsafe JavaScript number.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {number} Possibly unsafe number\r\n */\r\nLongBits.prototype.toNumber = function toNumber(unsigned) {\r\n    if (!unsigned && this.hi >>> 31) {\r\n        var lo = ~this.lo + 1 >>> 0,\r\n            hi = ~this.hi     >>> 0;\r\n        if (!lo)\r\n            hi = hi + 1 >>> 0;\r\n        return -(lo + hi * 4294967296);\r\n    }\r\n    return this.lo + this.hi * 4294967296;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a long.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long} Long\r\n */\r\nLongBits.prototype.toLong = function toLong(unsigned) {\r\n    return util.Long\r\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\r\n        /* istanbul ignore next */\r\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\r\n};\r\n\r\nvar charCodeAt = String.prototype.charCodeAt;\r\n\r\n/**\r\n * Constructs new long bits from the specified 8 characters long hash.\r\n * @param {string} hash Hash\r\n * @returns {util.LongBits} Bits\r\n */\r\nLongBits.fromHash = function fromHash(hash) {\r\n    if (hash === zeroHash)\r\n        return zero;\r\n    return new LongBits(\r\n        ( charCodeAt.call(hash, 0)\r\n        | charCodeAt.call(hash, 1) << 8\r\n        | charCodeAt.call(hash, 2) << 16\r\n        | charCodeAt.call(hash, 3) << 24) >>> 0\r\n    ,\r\n        ( charCodeAt.call(hash, 4)\r\n        | charCodeAt.call(hash, 5) << 8\r\n        | charCodeAt.call(hash, 6) << 16\r\n        | charCodeAt.call(hash, 7) << 24) >>> 0\r\n    );\r\n};\r\n\r\n/**\r\n * Converts this long bits to a 8 characters long hash.\r\n * @returns {string} Hash\r\n */\r\nLongBits.prototype.toHash = function toHash() {\r\n    return String.fromCharCode(\r\n        this.lo        & 255,\r\n        this.lo >>> 8  & 255,\r\n        this.lo >>> 16 & 255,\r\n        this.lo >>> 24      ,\r\n        this.hi        & 255,\r\n        this.hi >>> 8  & 255,\r\n        this.hi >>> 16 & 255,\r\n        this.hi >>> 24\r\n    );\r\n};\r\n\r\n/**\r\n * Zig-zag encodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzEncode = function zzEncode() {\r\n    var mask =   this.hi >> 31;\r\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\r\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Zig-zag decodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzDecode = function zzDecode() {\r\n    var mask = -(this.lo & 1);\r\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\r\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Calculates the length of this longbits when encoded as a varint.\r\n * @returns {number} Length\r\n */\r\nLongBits.prototype.length = function length() {\r\n    var part0 =  this.lo,\r\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\r\n        part2 =  this.hi >>> 24;\r\n    return part2 === 0\r\n         ? part1 === 0\r\n           ? part0 < 16384\r\n             ? part0 < 128 ? 1 : 2\r\n             : part0 < 2097152 ? 3 : 4\r\n           : part1 < 16384\r\n             ? part1 < 128 ? 5 : 6\r\n             : part1 < 2097152 ? 7 : 8\r\n         : part2 < 128 ? 9 : 10;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUdBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2Q0FBNkM7QUFDN0MsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcz85MWEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cclxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcclxuXHJcbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxyXG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb3cgYml0cy5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZ2ggYml0cy5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFplcm8gYml0cy5cclxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcclxuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XHJcbiAqL1xyXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XHJcblxyXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xyXG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcclxuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XHJcblxyXG4vKipcclxuICogWmVybyBoYXNoLlxyXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcclxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSAwKVxyXG4gICAgICAgIHJldHVybiB6ZXJvO1xyXG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XHJcbiAgICBpZiAoc2lnbilcclxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcclxuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxyXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcclxuICAgIGlmIChzaWduKSB7XHJcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XHJcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XHJcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XHJcbiAgICAgICAgICAgIGxvID0gMDtcclxuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxyXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcclxuICovXHJcbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHV0aWwuTG9uZylcclxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XHJcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxyXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcclxuICAgICAgICBpZiAoIWxvKVxyXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcclxuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gdXRpbC5Mb25nXHJcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xyXG59O1xyXG5cclxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcclxuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcclxuICAgICAgICByZXR1cm4gemVybztcclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXHJcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcclxuICAgICxcclxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcclxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcclxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiAyNFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xyXG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XHJcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XHJcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xyXG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcclxuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcclxuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xyXG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXHJcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxyXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xyXG4gICAgcmV0dXJuIHBhcnQyID09PSAwXHJcbiAgICAgICAgID8gcGFydDEgPT09IDBcclxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcclxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxyXG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxyXG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XHJcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XHJcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar util = exports;\r\n\r\n// used to return a Promise where callback is omitted\r\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"(ssr)/./node_modules/@protobufjs/aspromise/index.js\");\r\n\r\n// converts to / from base64 encoded strings\r\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"(ssr)/./node_modules/@protobufjs/base64/index.js\");\r\n\r\n// base class of rpc.Service\r\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"(ssr)/./node_modules/@protobufjs/eventemitter/index.js\");\r\n\r\n// float handling accross browsers\r\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"(ssr)/./node_modules/@protobufjs/float/index.js\");\r\n\r\n// requires modules optionally and hides the call from bundlers\r\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"(ssr)/./node_modules/@protobufjs/inquire/index.js\");\r\n\r\n// converts to / from utf8 encoded strings\r\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"(ssr)/./node_modules/@protobufjs/utf8/index.js\");\r\n\r\n// provides a node-like buffer pool in the browser\r\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"(ssr)/./node_modules/@protobufjs/pool/index.js\");\r\n\r\n// utility to work with the low and high bits of a 64 bit value\r\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js\");\r\n\r\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n */\r\nutil.isNode = Boolean(typeof global !== \"undefined\"\r\n                   && global\r\n                   && global.process\r\n                   && global.process.versions\r\n                   && global.process.versions.node);\r\n\r\n/**\r\n * Global object reference.\r\n * @memberof util\r\n * @type {Object}\r\n */\r\nutil.global = util.isNode && global\r\n           || typeof window !== \"undefined\" && window\r\n           || typeof self   !== \"undefined\" && self\r\n           || this; // eslint-disable-line no-invalid-this\r\n\r\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\r\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\r\n\r\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\r\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\r\n\r\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\r\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\r\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\r\nutil.isString = function isString(value) {\r\n    return typeof value === \"string\" || value instanceof String;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\r\nutil.isObject = function isObject(value) {\r\n    return value && typeof value === \"object\";\r\n};\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isset =\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isSet = function isSet(obj, prop) {\r\n    var value = obj[prop];\r\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\r\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\r\n\r\n/**\r\n * Node's Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\r\nutil.Buffer = (function() {\r\n    try {\r\n        var Buffer = util.inquire(\"buffer\").Buffer;\r\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\r\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\r\n    } catch (e) {\r\n        /* istanbul ignore next */\r\n        return null;\r\n    }\r\n})();\r\n\r\n// Internal alias of or polyfull for Buffer.from.\r\nutil._Buffer_from = null;\r\n\r\n// Internal alias of or polyfill for Buffer.allocUnsafe.\r\nutil._Buffer_allocUnsafe = null;\r\n\r\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\r\nutil.newBuffer = function newBuffer(sizeOrArray) {\r\n    /* istanbul ignore next */\r\n    return typeof sizeOrArray === \"number\"\r\n        ? util.Buffer\r\n            ? util._Buffer_allocUnsafe(sizeOrArray)\r\n            : new util.Array(sizeOrArray)\r\n        : util.Buffer\r\n            ? util._Buffer_from(sizeOrArray)\r\n            : typeof Uint8Array === \"undefined\"\r\n                ? sizeOrArray\r\n                : new Uint8Array(sizeOrArray);\r\n};\r\n\r\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\r\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\r\n\r\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\r\n\r\n/**\r\n * Long.js's Long class if available.\r\n * @type {Constructor<Long>}\r\n */\r\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\r\n         || /* istanbul ignore next */ util.global.Long\r\n         || util.inquire(\"long\");\r\n\r\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key2Re = /^true|false|0|1$/;\r\n\r\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\r\n\r\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\r\n\r\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\r\nutil.longToHash = function longToHash(value) {\r\n    return value\r\n        ? util.LongBits.from(value).toHash()\r\n        : util.LongBits.zeroHash;\r\n};\r\n\r\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\r\nutil.longFromHash = function longFromHash(hash, unsigned) {\r\n    var bits = util.LongBits.fromHash(hash);\r\n    if (util.Long)\r\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\r\n    return bits.toNumber(Boolean(unsigned));\r\n};\r\n\r\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nfunction merge(dst, src, ifNotSet) { // used by converters\r\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\r\n        if (dst[keys[i]] === undefined || !ifNotSet)\r\n            dst[keys[i]] = src[keys[i]];\r\n    return dst;\r\n}\r\n\r\nutil.merge = merge;\r\n\r\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.lcFirst = function lcFirst(str) {\r\n    return str.charAt(0).toLowerCase() + str.substring(1);\r\n};\r\n\r\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\r\nfunction newError(name) {\r\n\r\n    function CustomError(message, properties) {\r\n\r\n        if (!(this instanceof CustomError))\r\n            return new CustomError(message, properties);\r\n\r\n        // Error.call(this, message);\r\n        // ^ just returns a new error instance because the ctor can be called as a function\r\n\r\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\r\n\r\n        /* istanbul ignore next */\r\n        if (Error.captureStackTrace) // node\r\n            Error.captureStackTrace(this, CustomError);\r\n        else\r\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\r\n\r\n        if (properties)\r\n            merge(this, properties);\r\n    }\r\n\r\n    CustomError.prototype = Object.create(Error.prototype, {\r\n        constructor: {\r\n            value: CustomError,\r\n            writable: true,\r\n            enumerable: false,\r\n            configurable: true,\r\n        },\r\n        name: {\r\n            get: function get() { return name; },\r\n            set: undefined,\r\n            enumerable: false,\r\n            // configurable: false would accurately preserve the behavior of\r\n            // the original, but I'm guessing that was not intentional.\r\n            // For an actual error subclass, this property would\r\n            // be configurable.\r\n            configurable: true,\r\n        },\r\n        toString: {\r\n            value: function value() { return this.name + \": \" + this.message; },\r\n            writable: true,\r\n            enumerable: false,\r\n            configurable: true,\r\n        },\r\n    });\r\n\r\n    return CustomError;\r\n}\r\n\r\nutil.newError = newError;\r\n\r\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\r\n * }\r\n */\r\nutil.ProtocolError = newError(\"ProtocolError\");\r\n\r\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\r\n\r\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\r\n\r\n/**\r\n * Builds a getter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\r\nutil.oneOfGetter = function getOneOf(fieldNames) {\r\n    var fieldMap = {};\r\n    for (var i = 0; i < fieldNames.length; ++i)\r\n        fieldMap[fieldNames[i]] = 1;\r\n\r\n    /**\r\n     * @returns {string|undefined} Set field name, if any\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function() { // eslint-disable-line consistent-return\r\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\r\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\r\n                return keys[i];\r\n    };\r\n};\r\n\r\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Builds a setter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\r\nutil.oneOfSetter = function setOneOf(fieldNames) {\r\n\r\n    /**\r\n     * @param {string} name Field name\r\n     * @returns {undefined}\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function(name) {\r\n        for (var i = 0; i < fieldNames.length; ++i)\r\n            if (fieldNames[i] !== name)\r\n                delete this[fieldNames[i]];\r\n    };\r\n};\r\n\r\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\r\nutil.toJSONOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    json: true\r\n};\r\n\r\n// Sets up buffer utility according to the environment (called in index-minimal)\r\nutil._configure = function() {\r\n    var Buffer = util.Buffer;\r\n    /* istanbul ignore if */\r\n    if (!Buffer) {\r\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\r\n        return;\r\n    }\r\n    // because node 4.x buffers are incompatible & immutable\r\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\r\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\r\n        /* istanbul ignore next */\r\n        function Buffer_from(value, encoding) {\r\n            return new Buffer(value, encoding);\r\n        };\r\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\r\n        /* istanbul ignore next */\r\n        function Buffer_allocUnsafe(size) {\r\n            return new Buffer(size);\r\n        };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQXVCO0FBQ2hEO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsNEVBQW9CO0FBQzFDO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDdEQ7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywwRUFBbUI7QUFDeEM7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBcUI7QUFDNUM7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyx3RUFBa0I7QUFDdEM7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyx3RUFBa0I7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1HQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtREFBbUQsbUNBQW1DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQSxxQ0FBcUM7QUFDckMsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0IsbUJBQW1CO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNDQUFzQyx5Q0FBeUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLFVBQVU7QUFDVixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0EsVUFBVTtBQUNWLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcz81Y2ExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXRpbCA9IGV4cG9ydHM7XHJcblxyXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxyXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XHJcblxyXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xyXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XHJcblxyXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXHJcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcclxuXHJcbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcclxudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcclxuXHJcbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xyXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcclxuXHJcbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xyXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcclxuXHJcbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXHJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xyXG5cclxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXHJcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICovXHJcbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXHJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XHJcblxyXG4vKipcclxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxyXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XHJcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXHJcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcclxuXHJcbi8qKlxyXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHR5cGUge0FycmF5LjwqPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXHJcblxyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cclxuICogQHR5cGUge09iamVjdH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXHJcbiAqL1xyXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXHJcbiAqL1xyXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XHJcbiAqL1xyXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cclxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAqL1xyXG51dGlsLmlzc2V0ID1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAqL1xyXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXHJcbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxyXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxyXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cclxuICovXHJcbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcclxuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59KSgpO1xyXG5cclxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxyXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XHJcblxyXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxyXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cclxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcclxuICovXHJcbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxyXG4gICAgICAgID8gdXRpbC5CdWZmZXJcclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXHJcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXHJcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxyXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XHJcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cclxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxyXG4gKi9cclxudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xyXG5cclxuLyoqXHJcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXHJcbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxyXG4gKiBAaW50ZXJmYWNlIExvbmdcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcclxuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXHJcbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cclxuICovXHJcbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXHJcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcclxuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcclxuXHJcbi8qKlxyXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXHJcbiAqIEB0eXBlIHtSZWdFeHB9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XHJcblxyXG4vKipcclxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cclxuICogQHR5cGUge1JlZ0V4cH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcclxuXHJcbi8qKlxyXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxyXG4gKiBAdHlwZSB7UmVnRXhwfVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcclxuICovXHJcbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxyXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxyXG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXHJcbiAqL1xyXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xyXG4gICAgaWYgKHV0aWwuTG9uZylcclxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcclxuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xyXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxyXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcblxyXG51dGlsLm1lcmdlID0gbWVyZ2U7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcclxuICovXHJcbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXHJcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xyXG5cclxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuXHJcbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBuYW1lOiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gbmFtZTsgfSxcclxuICAgICAgICAgICAgc2V0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlIHdvdWxkIGFjY3VyYXRlbHkgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mXHJcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYnV0IEknbSBndWVzc2luZyB0aGF0IHdhcyBub3QgaW50ZW50aW9uYWwuXHJcbiAgICAgICAgICAgIC8vIEZvciBhbiBhY3R1YWwgZXJyb3Igc3ViY2xhc3MsIHRoaXMgcHJvcGVydHkgd291bGRcclxuICAgICAgICAgICAgLy8gYmUgY29uZmlndXJhYmxlLlxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzoge1xyXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH0sXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XHJcbn1cclxuXHJcbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxyXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZXh0ZW5kcyBFcnJvclxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB0cnkge1xyXG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gKiB9IGNhdGNoIChlKSB7XHJcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcclxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcclxuICogfVxyXG4gKi9cclxudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xyXG5cclxuLyoqXHJcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXHJcbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxyXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cclxuICovXHJcblxyXG4vKipcclxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxyXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xyXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXHJcbiAqL1xyXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xyXG4gICAgdmFyIGZpZWxkTWFwID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcclxuICAgICAqIEB0aGlzIE9iamVjdFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cclxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxyXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxyXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcclxuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxyXG4gKi9cclxudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgKiBAdGhpcyBPYmplY3RcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcclxuICpcclxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xyXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xyXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXHJcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcclxuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXHJcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcclxuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xyXG4gKlxyXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxyXG4gKi9cclxudXRpbC50b0pTT05PcHRpb25zID0ge1xyXG4gICAgbG9uZ3M6IFN0cmluZyxcclxuICAgIGVudW1zOiBTdHJpbmcsXHJcbiAgICBieXRlczogU3RyaW5nLFxyXG4gICAganNvbjogdHJ1ZVxyXG59O1xyXG5cclxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcclxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghQnVmZmVyKSB7XHJcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXHJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XHJcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH07XHJcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xyXG4gICAgICAgIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = verifier;\r\n\r\nvar Enum      = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"),\r\n    util      = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\r\n\r\nfunction invalid(field, expected) {\r\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\r\n}\r\n\r\n/**\r\n * Generates a partial value verifier.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {number} fieldIndex Field index\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\r\n    /* eslint-disable no-unexpected-multiline */\r\n    if (field.resolvedType) {\r\n        if (field.resolvedType instanceof Enum) { gen\r\n            (\"switch(%s){\", ref)\r\n                (\"default:\")\r\n                    (\"return%j\", invalid(field, \"enum value\"));\r\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\r\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\r\n            gen\r\n                    (\"break\")\r\n            (\"}\");\r\n        } else {\r\n            gen\r\n            (\"{\")\r\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\r\n                (\"if(e)\")\r\n                    (\"return%j+e\", field.name + \".\")\r\n            (\"}\");\r\n        }\r\n    } else {\r\n        switch (field.type) {\r\n            case \"int32\":\r\n            case \"uint32\":\r\n            case \"sint32\":\r\n            case \"fixed32\":\r\n            case \"sfixed32\": gen\r\n                (\"if(!util.isInteger(%s))\", ref)\r\n                    (\"return%j\", invalid(field, \"integer\"));\r\n                break;\r\n            case \"int64\":\r\n            case \"uint64\":\r\n            case \"sint64\":\r\n            case \"fixed64\":\r\n            case \"sfixed64\": gen\r\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\r\n                    (\"return%j\", invalid(field, \"integer|Long\"));\r\n                break;\r\n            case \"float\":\r\n            case \"double\": gen\r\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\r\n                    (\"return%j\", invalid(field, \"number\"));\r\n                break;\r\n            case \"bool\": gen\r\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\r\n                    (\"return%j\", invalid(field, \"boolean\"));\r\n                break;\r\n            case \"string\": gen\r\n                (\"if(!util.isString(%s))\", ref)\r\n                    (\"return%j\", invalid(field, \"string\"));\r\n                break;\r\n            case \"bytes\": gen\r\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\r\n                    (\"return%j\", invalid(field, \"buffer\"));\r\n                break;\r\n        }\r\n    }\r\n    return gen;\r\n    /* eslint-enable no-unexpected-multiline */\r\n}\r\n\r\n/**\r\n * Generates a partial key verifier.\r\n * @param {Codegen} gen Codegen instance\r\n * @param {Field} field Reflected field\r\n * @param {string} ref Variable reference\r\n * @returns {Codegen} Codegen instance\r\n * @ignore\r\n */\r\nfunction genVerifyKey(gen, field, ref) {\r\n    /* eslint-disable no-unexpected-multiline */\r\n    switch (field.keyType) {\r\n        case \"int32\":\r\n        case \"uint32\":\r\n        case \"sint32\":\r\n        case \"fixed32\":\r\n        case \"sfixed32\": gen\r\n            (\"if(!util.key32Re.test(%s))\", ref)\r\n                (\"return%j\", invalid(field, \"integer key\"));\r\n            break;\r\n        case \"int64\":\r\n        case \"uint64\":\r\n        case \"sint64\":\r\n        case \"fixed64\":\r\n        case \"sfixed64\": gen\r\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\r\n                (\"return%j\", invalid(field, \"integer|Long key\"));\r\n            break;\r\n        case \"bool\": gen\r\n            (\"if(!util.key2Re.test(%s))\", ref)\r\n                (\"return%j\", invalid(field, \"boolean key\"));\r\n            break;\r\n    }\r\n    return gen;\r\n    /* eslint-enable no-unexpected-multiline */\r\n}\r\n\r\n/**\r\n * Generates a verifier specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\r\nfunction verifier(mtype) {\r\n    /* eslint-disable no-unexpected-multiline */\r\n\r\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\r\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\r\n        (\"return%j\", \"object expected\");\r\n    var oneofs = mtype.oneofsArray,\r\n        seenFirstField = {};\r\n    if (oneofs.length) gen\r\n    (\"var p={}\");\r\n\r\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\r\n        var field = mtype._fieldsArray[i].resolve(),\r\n            ref   = \"m\" + util.safeProp(field.name);\r\n\r\n        if (field.optional) gen\r\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\r\n\r\n        // map fields\r\n        if (field.map) { gen\r\n            (\"if(!util.isObject(%s))\", ref)\r\n                (\"return%j\", invalid(field, \"object\"))\r\n            (\"var k=Object.keys(%s)\", ref)\r\n            (\"for(var i=0;i<k.length;++i){\");\r\n                genVerifyKey(gen, field, \"k[i]\");\r\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\r\n            (\"}\");\r\n\r\n        // repeated fields\r\n        } else if (field.repeated) { gen\r\n            (\"if(!Array.isArray(%s))\", ref)\r\n                (\"return%j\", invalid(field, \"array\"))\r\n            (\"for(var i=0;i<%s.length;++i){\", ref);\r\n                genVerifyValue(gen, field, i, ref + \"[i]\")\r\n            (\"}\");\r\n\r\n        // required or present fields\r\n        } else {\r\n            if (field.partOf) {\r\n                var oneofProp = util.safeProp(field.partOf.name);\r\n                if (seenFirstField[field.partOf.name] === 1) gen\r\n            (\"if(p%s===1)\", oneofProp)\r\n                (\"return%j\", field.partOf.name + \": multiple values\");\r\n                seenFirstField[field.partOf.name] = 1;\r\n                gen\r\n            (\"p%s=1\", oneofProp);\r\n            }\r\n            genVerifyValue(gen, field, i, ref);\r\n        }\r\n        if (field.optional) gen\r\n        (\"}\");\r\n    }\r\n    return gen\r\n    (\"return null\");\r\n    /* eslint-enable no-unexpected-multiline */\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQVE7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQVE7QUFDaEM7QUFDQTtBQUNBLGtJQUFrSSxvQkFBb0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwyRUFBMkUsaUJBQWlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixVQUFVO0FBQ1Y7QUFDQSxlQUFlO0FBQ2YsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0JBQW9CLGdEQUFnRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxLQUFLO0FBQzFDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWSxLQUFLO0FBQzNDO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanM/YzAwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZmllcjtcclxuXHJcbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxyXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuXHJcbmZ1bmN0aW9uIGludmFsaWQoZmllbGQsIGV4cGVjdGVkKSB7XHJcbiAgICByZXR1cm4gZmllbGQubmFtZSArIFwiOiBcIiArIGV4cGVjdGVkICsgKGZpZWxkLnJlcGVhdGVkICYmIGV4cGVjdGVkICE9PSBcImFycmF5XCIgPyBcIltdXCIgOiBmaWVsZC5tYXAgJiYgZXhwZWN0ZWQgIT09IFwib2JqZWN0XCIgPyBcIntrOlwiK2ZpZWxkLmtleVR5cGUrXCJ9XCIgOiBcIlwiKSArIFwiIGV4cGVjdGVkXCI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIHZlcmlmaWVyLlxyXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIFZhcmlhYmxlIHJlZmVyZW5jZVxyXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXHJcbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XHJcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXHJcbiAgICAgICAgICAgIChcInN3aXRjaCglcyl7XCIsIHJlZilcclxuICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJlbnVtIHZhbHVlXCIpKTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXMpLCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIGdlblxyXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc1trZXlzW2pdXSk7XHJcbiAgICAgICAgICAgIGdlblxyXG4gICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXHJcbiAgICAgICAgICAgIChcIn1cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2VuXHJcbiAgICAgICAgICAgIChcIntcIilcclxuICAgICAgICAgICAgICAgIChcInZhciBlPXR5cGVzWyVpXS52ZXJpZnkoJXMpO1wiLCBmaWVsZEluZGV4LCByZWYpXHJcbiAgICAgICAgICAgICAgICAoXCJpZihlKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqK2VcIiwgZmllbGQubmFtZSArIFwiLlwiKVxyXG4gICAgICAgICAgICAoXCJ9XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZpeGVkMzJcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxyXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNJbnRlZ2VyKCVzKSlcIiwgcmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlclwiKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc0ludGVnZXIoJXMpJiYhKCVzJiZ1dGlsLmlzSW50ZWdlciglcy5sb3cpJiZ1dGlsLmlzSW50ZWdlciglcy5oaWdoKSkpXCIsIHJlZiwgcmVmLCByZWYsIHJlZilcclxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJ8TG9uZ1wiKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjogZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YgJXMhPT1cXFwibnVtYmVyXFxcIilcIiwgcmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwibnVtYmVyXCIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cclxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJib29sZWFuXFxcIilcIiwgcmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhblwiKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cclxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzU3RyaW5nKCVzKSlcIiwgcmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwic3RyaW5nXCIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXHJcbiAgICAgICAgICAgICAgICAoXCJpZighKCVzJiZ0eXBlb2YgJXMubGVuZ3RoPT09XFxcIm51bWJlclxcXCJ8fHV0aWwuaXNTdHJpbmcoJXMpKSlcIiwgcmVmLCByZWYsIHJlZilcclxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJ1ZmZlclwiKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2VuO1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBrZXkgdmVyaWZpZXIuXHJcbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcclxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXHJcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCByZWYpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXHJcbiAgICBzd2l0Y2ggKGZpZWxkLmtleVR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiaW50MzJcIjpcclxuICAgICAgICBjYXNlIFwidWludDMyXCI6XHJcbiAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxyXG4gICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XHJcbiAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxyXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkzMlJlLnRlc3QoJXMpKVwiLCByZWYpXHJcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXIga2V5XCIpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImludDY0XCI6XHJcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxyXG4gICAgICAgIGNhc2UgXCJzaW50NjRcIjpcclxuICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxyXG4gICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cclxuICAgICAgICAgICAgKFwiaWYoIXV0aWwua2V5NjRSZS50ZXN0KCVzKSlcIiwgcmVmKSAvLyBzZWUgY29tbWVudCBhYm92ZTogeCBpcyBvaywgZCBpcyBub3RcclxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlcnxMb25nIGtleVwiKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxyXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkyUmUudGVzdCglcykpXCIsIHJlZilcclxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhbiBrZXlcIikpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBnZW47XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSB2ZXJpZmllciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cclxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcclxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIHZlcmlmaWVyKG10eXBlKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xyXG5cclxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiXSwgbXR5cGUubmFtZSArIFwiJHZlcmlmeVwiKVxyXG4gICAgKFwiaWYodHlwZW9mIG0hPT1cXFwib2JqZWN0XFxcInx8bT09PW51bGwpXCIpXHJcbiAgICAgICAgKFwicmV0dXJuJWpcIiwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICB2YXIgb25lb2ZzID0gbXR5cGUub25lb2ZzQXJyYXksXHJcbiAgICAgICAgc2VlbkZpcnN0RmllbGQgPSB7fTtcclxuICAgIGlmIChvbmVvZnMubGVuZ3RoKSBnZW5cclxuICAgIChcInZhciBwPXt9XCIpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgICByZWYgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cclxuICAgICAgICAoXCJpZiglcyE9bnVsbCYmbS5oYXNPd25Qcm9wZXJ0eSglaikpe1wiLCByZWYsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXHJcblxyXG4gICAgICAgIC8vIG1hcCBmaWVsZHNcclxuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxyXG4gICAgICAgICAgICAoXCJpZighdXRpbC5pc09iamVjdCglcykpXCIsIHJlZilcclxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwib2JqZWN0XCIpKVxyXG4gICAgICAgICAgICAoXCJ2YXIgaz1PYmplY3Qua2V5cyglcylcIiwgcmVmKVxyXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGsubGVuZ3RoOysraSl7XCIpO1xyXG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5S2V5KGdlbiwgZmllbGQsIFwia1tpXVwiKTtcclxuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2tbaV1dXCIpXHJcbiAgICAgICAgICAgIChcIn1cIik7XHJcblxyXG4gICAgICAgIC8vIHJlcGVhdGVkIGZpZWxkc1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXHJcbiAgICAgICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KCVzKSlcIiwgcmVmKVxyXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJhcnJheVwiKSlcclxuICAgICAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKXtcIiwgcmVmKTtcclxuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2ldXCIpXHJcbiAgICAgICAgICAgIChcIn1cIik7XHJcblxyXG4gICAgICAgIC8vIHJlcXVpcmVkIG9yIHByZXNlbnQgZmllbGRzXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLnBhcnRPZikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9uZW9mUHJvcCA9IHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5GaXJzdEZpZWxkW2ZpZWxkLnBhcnRPZi5uYW1lXSA9PT0gMSkgZ2VuXHJcbiAgICAgICAgICAgIChcImlmKHAlcz09PTEpXCIsIG9uZW9mUHJvcClcclxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGZpZWxkLnBhcnRPZi5uYW1lICsgXCI6IG11bHRpcGxlIHZhbHVlc1wiKTtcclxuICAgICAgICAgICAgICAgIHNlZW5GaXJzdEZpZWxkW2ZpZWxkLnBhcnRPZi5uYW1lXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBnZW5cclxuICAgICAgICAgICAgKFwicCVzPTFcIiwgb25lb2ZQcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmllbGQub3B0aW9uYWwpIGdlblxyXG4gICAgICAgIChcIn1cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2VuXHJcbiAgICAoXCJyZXR1cm4gbnVsbFwiKTtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\n/**\r\n * Wrappers for common types.\r\n * @type {Object.<string,IWrapper>}\r\n * @const\r\n */\r\nvar wrappers = exports;\r\n\r\nvar Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\");\r\n\r\n/**\r\n * From object converter part of an {@link IWrapper}.\r\n * @typedef WrapperFromObjectConverter\r\n * @type {function}\r\n * @param {Object.<string,*>} object Plain object\r\n * @returns {Message<{}>} Message instance\r\n * @this Type\r\n */\r\n\r\n/**\r\n * To object converter part of an {@link IWrapper}.\r\n * @typedef WrapperToObjectConverter\r\n * @type {function}\r\n * @param {Message<{}>} message Message instance\r\n * @param {IConversionOptions} [options] Conversion options\r\n * @returns {Object.<string,*>} Plain object\r\n * @this Type\r\n */\r\n\r\n/**\r\n * Common type wrapper part of {@link wrappers}.\r\n * @interface IWrapper\r\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\r\n * @property {WrapperToObjectConverter} [toObject] To object converter\r\n */\r\n\r\n// Custom wrapper for Any\r\nwrappers[\".google.protobuf.Any\"] = {\r\n\r\n    fromObject: function(object) {\r\n\r\n        // unwrap value type if mapped\r\n        if (object && object[\"@type\"]) {\r\n             // Only use fully qualified type name after the last '/'\r\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\r\n            var type = this.lookup(name);\r\n            /* istanbul ignore else */\r\n            if (type) {\r\n                // type_url does not accept leading \".\"\r\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\r\n                    object[\"@type\"].slice(1) : object[\"@type\"];\r\n                // type_url prefix is optional, but path seperator is required\r\n                if (type_url.indexOf(\"/\") === -1) {\r\n                    type_url = \"/\" + type_url;\r\n                }\r\n                return this.create({\r\n                    type_url: type_url,\r\n                    value: type.encode(type.fromObject(object)).finish()\r\n                });\r\n            }\r\n        }\r\n\r\n        return this.fromObject(object);\r\n    },\r\n\r\n    toObject: function(message, options) {\r\n\r\n        // Default prefix\r\n        var googleApi = \"type.googleapis.com/\";\r\n        var prefix = \"\";\r\n        var name = \"\";\r\n\r\n        // decode value if requested and unmapped\r\n        if (options && options.json && message.type_url && message.value) {\r\n            // Only use fully qualified type name after the last '/'\r\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\r\n            // Separate the prefix used\r\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\r\n            var type = this.lookup(name);\r\n            /* istanbul ignore else */\r\n            if (type)\r\n                message = type.decode(message.value);\r\n        }\r\n\r\n        // wrap value if unmapped\r\n        if (!(message instanceof this.ctor) && message instanceof Message) {\r\n            var object = message.$type.toObject(message, options);\r\n            var messageName = message.$type.fullName[0] === \".\" ?\r\n                message.$type.fullName.slice(1) : message.$type.fullName;\r\n            // Default to type.googleapis.com prefix if no prefix is used\r\n            if (prefix === \"\") {\r\n                prefix = googleApi;\r\n            }\r\n            name = prefix + messageName;\r\n            object[\"@type\"] = name;\r\n            return object;\r\n        }\r\n\r\n        return this.toObject(message, options);\r\n    }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsNEZBQVc7QUFDakM7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0EsVUFBVTtBQUNWLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsVUFBVSxHQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxVQUFVLEdBQUc7QUFDeEIsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cmFwcGVycy5qcz9jYTQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIFdyYXBwZXJzIGZvciBjb21tb24gdHlwZXMuXHJcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxJV3JhcHBlcj59XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudmFyIHdyYXBwZXJzID0gZXhwb3J0cztcclxuXHJcbnZhciBNZXNzYWdlID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcclxuXHJcbi8qKlxyXG4gKiBGcm9tIG9iamVjdCBjb252ZXJ0ZXIgcGFydCBvZiBhbiB7QGxpbmsgSVdyYXBwZXJ9LlxyXG4gKiBAdHlwZWRlZiBXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXHJcbiAqIEB0aGlzIFR5cGVcclxuICovXHJcblxyXG4vKipcclxuICogVG8gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXHJcbiAqIEB0eXBlZGVmIFdyYXBwZXJUb09iamVjdENvbnZlcnRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gKiBAdGhpcyBUeXBlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbW1vbiB0eXBlIHdyYXBwZXIgcGFydCBvZiB7QGxpbmsgd3JhcHBlcnN9LlxyXG4gKiBAaW50ZXJmYWNlIElXcmFwcGVyXHJcbiAqIEBwcm9wZXJ0eSB7V3JhcHBlckZyb21PYmplY3RDb252ZXJ0ZXJ9IFtmcm9tT2JqZWN0XSBGcm9tIG9iamVjdCBjb252ZXJ0ZXJcclxuICogQHByb3BlcnR5IHtXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJ9IFt0b09iamVjdF0gVG8gb2JqZWN0IGNvbnZlcnRlclxyXG4gKi9cclxuXHJcbi8vIEN1c3RvbSB3cmFwcGVyIGZvciBBbnlcclxud3JhcHBlcnNbXCIuZ29vZ2xlLnByb3RvYnVmLkFueVwiXSA9IHtcclxuXHJcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcclxuXHJcbiAgICAgICAgLy8gdW53cmFwIHZhbHVlIHR5cGUgaWYgbWFwcGVkXHJcbiAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3RbXCJAdHlwZVwiXSkge1xyXG4gICAgICAgICAgICAgLy8gT25seSB1c2UgZnVsbHkgcXVhbGlmaWVkIHR5cGUgbmFtZSBhZnRlciB0aGUgbGFzdCAnLydcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmplY3RbXCJAdHlwZVwiXS5zdWJzdHJpbmcob2JqZWN0W1wiQHR5cGVcIl0ubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBkb2VzIG5vdCBhY2NlcHQgbGVhZGluZyBcIi5cIlxyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVfdXJsID0gb2JqZWN0W1wiQHR5cGVcIl0uY2hhckF0KDApID09PSBcIi5cIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0uc2xpY2UoMSkgOiBvYmplY3RbXCJAdHlwZVwiXTtcclxuICAgICAgICAgICAgICAgIC8vIHR5cGVfdXJsIHByZWZpeCBpcyBvcHRpb25hbCwgYnV0IHBhdGggc2VwZXJhdG9yIGlzIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZV91cmwuaW5kZXhPZihcIi9cIikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmwgPSBcIi9cIiArIHR5cGVfdXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybDogdHlwZV91cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR5cGUuZW5jb2RlKHR5cGUuZnJvbU9iamVjdChvYmplY3QpKS5maW5pc2goKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3Qob2JqZWN0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCBwcmVmaXhcclxuICAgICAgICB2YXIgZ29vZ2xlQXBpID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tL1wiO1xyXG4gICAgICAgIHZhciBwcmVmaXggPSBcIlwiO1xyXG4gICAgICAgIHZhciBuYW1lID0gXCJcIjtcclxuXHJcbiAgICAgICAgLy8gZGVjb2RlIHZhbHVlIGlmIHJlcXVlc3RlZCBhbmQgdW5tYXBwZWRcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmpzb24gJiYgbWVzc2FnZS50eXBlX3VybCAmJiBtZXNzYWdlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXHJcbiAgICAgICAgICAgIG5hbWUgPSBtZXNzYWdlLnR5cGVfdXJsLnN1YnN0cmluZyhtZXNzYWdlLnR5cGVfdXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xyXG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSB0aGUgcHJlZml4IHVzZWRcclxuICAgICAgICAgICAgcHJlZml4ID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcoMCwgbWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxvb2t1cChuYW1lKTtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKHR5cGUpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdHlwZS5kZWNvZGUobWVzc2FnZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3cmFwIHZhbHVlIGlmIHVubWFwcGVkXHJcbiAgICAgICAgaWYgKCEobWVzc2FnZSBpbnN0YW5jZW9mIHRoaXMuY3RvcikgJiYgbWVzc2FnZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG1lc3NhZ2UuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlTmFtZSA9IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWVbMF0gPT09IFwiLlwiID9cclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWUuc2xpY2UoMSkgOiBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lO1xyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHR5cGUuZ29vZ2xlYXBpcy5jb20gcHJlZml4IGlmIG5vIHByZWZpeCBpcyB1c2VkXHJcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIHByZWZpeCA9IGdvb2dsZUFwaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuYW1lID0gcHJlZml4ICsgbWVzc2FnZU5hbWU7XHJcbiAgICAgICAgICAgIG9iamVjdFtcIkB0eXBlXCJdID0gbmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = Writer;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferWriter; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    base64    = util.base64,\r\n    utf8      = util.utf8;\r\n\r\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\r\nfunction Op(fn, len, val) {\r\n\r\n    /**\r\n     * Function to call.\r\n     * @type {function(Uint8Array, number, *)}\r\n     */\r\n    this.fn = fn;\r\n\r\n    /**\r\n     * Value byte length.\r\n     * @type {number}\r\n     */\r\n    this.len = len;\r\n\r\n    /**\r\n     * Next operation.\r\n     * @type {Writer.Op|undefined}\r\n     */\r\n    this.next = undefined;\r\n\r\n    /**\r\n     * Value to write.\r\n     * @type {*}\r\n     */\r\n    this.val = val; // type varies\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\r\nfunction State(writer) {\r\n\r\n    /**\r\n     * Current head.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.head = writer.head;\r\n\r\n    /**\r\n     * Current tail.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.tail = writer.tail;\r\n\r\n    /**\r\n     * Current buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = writer.len;\r\n\r\n    /**\r\n     * Next state.\r\n     * @type {State|null}\r\n     */\r\n    this.next = writer.states;\r\n}\r\n\r\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\r\nfunction Writer() {\r\n\r\n    /**\r\n     * Current length.\r\n     * @type {number}\r\n     */\r\n    this.len = 0;\r\n\r\n    /**\r\n     * Operations head.\r\n     * @type {Object}\r\n     */\r\n    this.head = new Op(noop, 0, 0);\r\n\r\n    /**\r\n     * Operations tail\r\n     * @type {Object}\r\n     */\r\n    this.tail = this.head;\r\n\r\n    /**\r\n     * Linked forked states.\r\n     * @type {Object|null}\r\n     */\r\n    this.states = null;\r\n\r\n    // When a value is written, the writer calculates its byte length and puts it into a linked\r\n    // list of operations to perform when finish() is called. This both allows us to allocate\r\n    // buffers of the exact required size and reduces the amount of work we have to do compared\r\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\r\n    // part is just a linked list walk calling operations with already prepared values.\r\n}\r\n\r\nvar create = function create() {\r\n    return util.Buffer\r\n        ? function create_buffer_setup() {\r\n            return (Writer.create = function create_buffer() {\r\n                return new BufferWriter();\r\n            })();\r\n        }\r\n        /* istanbul ignore next */\r\n        : function create_array() {\r\n            return new Writer();\r\n        };\r\n};\r\n\r\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\r\nWriter.create = create();\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\nWriter.alloc = function alloc(size) {\r\n    return new util.Array(size);\r\n};\r\n\r\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\r\n/* istanbul ignore else */\r\nif (util.Array !== Array)\r\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\r\n\r\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\r\nWriter.prototype._push = function push(fn, len, val) {\r\n    this.tail = this.tail.next = new Op(fn, len, val);\r\n    this.len += len;\r\n    return this;\r\n};\r\n\r\nfunction writeByte(val, buf, pos) {\r\n    buf[pos] = val & 255;\r\n}\r\n\r\nfunction writeVarint32(val, buf, pos) {\r\n    while (val > 127) {\r\n        buf[pos++] = val & 127 | 128;\r\n        val >>>= 7;\r\n    }\r\n    buf[pos] = val;\r\n}\r\n\r\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\r\nfunction VarintOp(len, val) {\r\n    this.len = len;\r\n    this.next = undefined;\r\n    this.val = val;\r\n}\r\n\r\nVarintOp.prototype = Object.create(Op.prototype);\r\nVarintOp.prototype.fn = writeVarint32;\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.uint32 = function write_uint32(value) {\r\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\r\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\r\n    this.len += (this.tail = this.tail.next = new VarintOp(\r\n        (value = value >>> 0)\r\n                < 128       ? 1\r\n        : value < 16384     ? 2\r\n        : value < 2097152   ? 3\r\n        : value < 268435456 ? 4\r\n        :                     5,\r\n    value)).len;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.int32 = function write_int32(value) {\r\n    return value < 0\r\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\r\n        : this.uint32(value);\r\n};\r\n\r\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sint32 = function write_sint32(value) {\r\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\r\n};\r\n\r\nfunction writeVarint64(val, buf, pos) {\r\n    while (val.hi) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\r\n        val.hi >>>= 7;\r\n    }\r\n    while (val.lo > 127) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = val.lo >>> 7;\r\n    }\r\n    buf[pos++] = val.lo;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.uint64 = function write_uint64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.int64 = Writer.prototype.uint64;\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sint64 = function write_sint64(value) {\r\n    var bits = LongBits.from(value).zzEncode();\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bool = function write_bool(value) {\r\n    return this._push(writeByte, 1, value ? 1 : 0);\r\n};\r\n\r\nfunction writeFixed32(val, buf, pos) {\r\n    buf[pos    ] =  val         & 255;\r\n    buf[pos + 1] =  val >>> 8   & 255;\r\n    buf[pos + 2] =  val >>> 16  & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fixed32 = function write_fixed32(value) {\r\n    return this._push(writeFixed32, 4, value >>> 0);\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.fixed64 = function write_fixed64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\r\n\r\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.float = function write_float(value) {\r\n    return this._push(util.float.writeFloatLE, 4, value);\r\n};\r\n\r\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.double = function write_double(value) {\r\n    return this._push(util.float.writeDoubleLE, 8, value);\r\n};\r\n\r\nvar writeBytes = util.Array.prototype.set\r\n    ? function writeBytes_set(val, buf, pos) {\r\n        buf.set(val, pos); // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytes_for(val, buf, pos) {\r\n        for (var i = 0; i < val.length; ++i)\r\n            buf[pos + i] = val[i];\r\n    };\r\n\r\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bytes = function write_bytes(value) {\r\n    var len = value.length >>> 0;\r\n    if (!len)\r\n        return this._push(writeByte, 1, 0);\r\n    if (util.isString(value)) {\r\n        var buf = Writer.alloc(len = base64.length(value));\r\n        base64.decode(value, buf, 0);\r\n        value = buf;\r\n    }\r\n    return this.uint32(len)._push(writeBytes, len, value);\r\n};\r\n\r\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.string = function write_string(value) {\r\n    var len = utf8.length(value);\r\n    return len\r\n        ? this.uint32(len)._push(utf8.write, len, value)\r\n        : this._push(writeByte, 1, 0);\r\n};\r\n\r\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fork = function fork() {\r\n    this.states = new State(this);\r\n    this.head = this.tail = new Op(noop, 0, 0);\r\n    this.len = 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.reset = function reset() {\r\n    if (this.states) {\r\n        this.head   = this.states.head;\r\n        this.tail   = this.states.tail;\r\n        this.len    = this.states.len;\r\n        this.states = this.states.next;\r\n    } else {\r\n        this.head = this.tail = new Op(noop, 0, 0);\r\n        this.len  = 0;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.ldelim = function ldelim() {\r\n    var head = this.head,\r\n        tail = this.tail,\r\n        len  = this.len;\r\n    this.reset().uint32(len);\r\n    if (len) {\r\n        this.tail.next = head.next; // skip noop\r\n        this.tail = tail;\r\n        this.len += len;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\r\nWriter.prototype.finish = function finish() {\r\n    var head = this.head.next, // skip noop\r\n        buf  = this.constructor.alloc(this.len),\r\n        pos  = 0;\r\n    while (head) {\r\n        head.fn(head.val, buf, pos);\r\n        pos += head.len;\r\n        head = head.next;\r\n    }\r\n    // this.head = this.tail = null;\r\n    return buf;\r\n};\r\n\r\nWriter._configure = function(BufferWriter_) {\r\n    BufferWriter = BufferWriter_;\r\n    Writer.create = create();\r\n    BufferWriter._configure();\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNHQUFnQjtBQUN4QztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCLEdBQUcsb0JBQW9CLHlDQUF5QztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxRQUFRO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCLElBQUksNEJBQTRCO0FBQ3RFLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzP2ZmZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xyXG5cclxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xyXG5cclxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXHJcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcclxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxyXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5mbiA9IGZuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IGxlbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxyXG4gICAgICogQHR5cGUgeyp9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xyXG59XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXHJcbiAqIEBtZW1iZXJvZiBXcml0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgaGVhZC5cclxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCB0YWlsLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZXh0IHN0YXRlLlxyXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gV3JpdGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxyXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XHJcblxyXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxyXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcclxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcclxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcclxuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXHJcbn1cclxuXHJcbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xyXG4gICAgICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cclxuICovXHJcbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcclxuXHJcbi8qKlxyXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXHJcbiAqL1xyXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XHJcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XHJcbn07XHJcblxyXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcclxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxyXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xyXG5cclxuLyoqXHJcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XHJcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xyXG4gICAgdGhpcy5sZW4gKz0gbGVuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xyXG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xyXG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XHJcbiAgICAgICAgdmFsID4+Pj0gNztcclxuICAgIH1cclxuICAgIGJ1Zltwb3NdID0gdmFsO1xyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXHJcbiAqIEBleHRlbmRzIE9wXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcclxuICAgIHRoaXMubGVuID0gbGVuO1xyXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy52YWwgPSB2YWw7XHJcbn1cclxuXHJcblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcclxuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xyXG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXHJcbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxyXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxyXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXHJcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcclxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xyXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XHJcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXHJcbiAgICB2YWx1ZSkpLmxlbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA8IDBcclxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xyXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xyXG4gICAgd2hpbGUgKHZhbC5oaSkge1xyXG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XHJcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XHJcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcclxuICAgIH1cclxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcclxuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xyXG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcclxuICAgIH1cclxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xyXG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xyXG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XHJcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xyXG59O1xyXG5cclxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcclxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmICghbGVuKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XHJcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcclxuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xyXG4gICAgICAgIHZhbHVlID0gYnVmO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcclxuICAgIHJldHVybiBsZW5cclxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcclxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cclxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xyXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XHJcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcbiAgICB0aGlzLmxlbiA9IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcclxuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XHJcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xyXG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xyXG4gICAgICAgIHRoaXMubGVuICA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcclxuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxyXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXHJcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xyXG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xyXG4gICAgaWYgKGxlbikge1xyXG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcclxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xyXG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xyXG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXHJcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxyXG4gICAgICAgIHBvcyAgPSAwO1xyXG4gICAgd2hpbGUgKGhlYWQpIHtcclxuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XHJcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xyXG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XHJcbiAgICB9XHJcbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgcmV0dXJuIGJ1ZjtcclxufTtcclxuXHJcbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xyXG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcclxuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcclxuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nmodule.exports = BufferWriter;\r\n\r\n// extends Writer\r\nvar Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\");\r\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs a new buffer writer instance.\r\n * @classdesc Wire format writer using node buffers.\r\n * @extends Writer\r\n * @constructor\r\n */\r\nfunction BufferWriter() {\r\n    Writer.call(this);\r\n}\r\n\r\nBufferWriter._configure = function () {\r\n    /**\r\n     * Allocates a buffer of the specified size.\r\n     * @function\r\n     * @param {number} size Buffer size\r\n     * @returns {Buffer} Buffer\r\n     */\r\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\r\n\r\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\r\n        ? function writeBytesBuffer_set(val, buf, pos) {\r\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\r\n          // also works for plain array values\r\n        }\r\n        /* istanbul ignore next */\r\n        : function writeBytesBuffer_copy(val, buf, pos) {\r\n          if (val.copy) // Buffer values\r\n            val.copy(buf, pos, 0, val.length);\r\n          else for (var i = 0; i < val.length;) // plain array values\r\n            buf[pos++] = val[i++];\r\n        };\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\r\n    if (util.isString(value))\r\n        value = util._Buffer_from(value, \"base64\");\r\n    var len = value.length >>> 0;\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(BufferWriter.writeBytesBuffer, len, value);\r\n    return this;\r\n};\r\n\r\nfunction writeStringBuffer(val, buf, pos) {\r\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\r\n        util.utf8.write(val, buf, pos);\r\n    else if (buf.utf8Write)\r\n        buf.utf8Write(val, pos);\r\n    else\r\n        buf.write(val, pos);\r\n}\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.string = function write_string_buffer(value) {\r\n    var len = util.Buffer.byteLength(value);\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeStringBuffer, len, value);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @name BufferWriter#finish\r\n * @function\r\n * @returns {Buffer} Finished buffer\r\n */\r\n\r\nBufferWriter._configure();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywwRkFBVTtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNHQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcz9mOWJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcclxuXHJcbi8vIGV4dGVuZHMgV3JpdGVyXHJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XHJcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cclxuICogQGV4dGVuZHMgV3JpdGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xyXG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XHJcbn1cclxuXHJcbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxyXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXHJcbiAgICAgKi9cclxuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcclxuXHJcbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXHJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXHJcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcclxuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xyXG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xyXG4gICAgICAgIH07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xyXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxyXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xyXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcclxuICAgIHRoaXMudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKVxyXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcclxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XHJcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxyXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xyXG4gICAgdGhpcy51aW50MzIobGVuKTtcclxuICAgIGlmIChsZW4pXHJcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cclxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXHJcbiAqL1xyXG5cclxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return util_1.loadProtosWithOptions(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\nutil_1.addCommonProtos();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUVBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG1EQUFNO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZmxhc2hjYXJkcy8uL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL2luZGV4LmpzPzk1YmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZShcImxvZGFzaC5jYW1lbGNhc2VcIik7XG5jb25zdCBQcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xuY29uc3QgZGVzY3JpcHRvciA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL2V4dC9kZXNjcmlwdG9yXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcbmV4cG9ydHMuTG9uZyA9IExvbmc7XG5mdW5jdGlvbiBpc0FueUV4dGVuc2lvbihvYmopIHtcbiAgICByZXR1cm4gKCdAdHlwZScgaW4gb2JqKSAmJiAodHlwZW9mIG9ialsnQHR5cGUnXSA9PT0gJ3N0cmluZycpO1xufVxuZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGlzQW55RXh0ZW5zaW9uO1xuY29uc3QgZGVzY3JpcHRvck9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAgZGVmYXVsdHM6IHRydWUsXG4gICAgb25lb2ZzOiB0cnVlLFxuICAgIGpzb246IHRydWUsXG59O1xuZnVuY3Rpb24gam9pbk5hbWUoYmFzZU5hbWUsIG5hbWUpIHtcbiAgICBpZiAoYmFzZU5hbWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOYW1lICsgJy4nICsgbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0KG9iaikge1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pO1xufVxuZnVuY3Rpb24gaXNOYW1lc3BhY2VCYXNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5OYW1lc3BhY2UgfHwgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuUm9vdDtcbn1cbmZ1bmN0aW9uIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhvYmosIHBhcmVudE5hbWUpIHtcbiAgICBjb25zdCBvYmpOYW1lID0gam9pbk5hbWUocGFyZW50TmFtZSwgb2JqLm5hbWUpO1xuICAgIGlmIChpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtbb2JqTmFtZSwgb2JqXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXNOYW1lc3BhY2VCYXNlKG9iaikgJiYgdHlwZW9mIG9iai5uZXN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqLm5lc3RlZClcbiAgICAgICAgICAgICAgICAubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLm5lc3RlZFtuYW1lXSwgb2JqTmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yLmNvbmNhdChjdXJyZW50VmFsdWUpLCBbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzZXJpYWxpemVyKGNscywgb3B0aW9ucykge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZXNlcmlhbGl6ZShhcmdCdWYpIHtcbiAgICAgICAgcmV0dXJuIGNscy50b09iamVjdChjbHMuZGVjb2RlKGFyZ0J1ZiksIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJpYWxpemVyKGNscykge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXJpYWxpemUoYXJnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNlcmlhbGl6ZSBtZXNzYWdlOiBleHBlY3RlZCBvYmplY3Qgd2l0aCAke2Nscy5uYW1lfSBzdHJ1Y3R1cmUsIGdvdCBhcnJheSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNscy5mcm9tT2JqZWN0KGFyZyk7XG4gICAgICAgIHJldHVybiBjbHMuZW5jb2RlKG1lc3NhZ2UpLmZpbmlzaCgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgc2VydmljZU5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIC8qIFRoaXMgaXMgb25seSBldmVyIGNhbGxlZCBhZnRlciB0aGUgY29ycmVzcG9uZGluZyByb290LnJlc29sdmVBbGwoKSwgc28gd2VcbiAgICAgKiBjYW4gYXNzdW1lIHRoYXQgdGhlIHJlc29sdmVkIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHR5cGVzIGFyZSBub24tbnVsbCAqL1xuICAgIGNvbnN0IHJlcXVlc3RUeXBlID0gbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGU7XG4gICAgY29uc3QgcmVzcG9uc2VUeXBlID0gbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6ICcvJyArIHNlcnZpY2VOYW1lICsgJy8nICsgbWV0aG9kLm5hbWUsXG4gICAgICAgIHJlcXVlc3RTdHJlYW06ICEhbWV0aG9kLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtOiAhIW1ldGhvZC5yZXNwb25zZVN0cmVhbSxcbiAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogY3JlYXRlU2VyaWFsaXplcihyZXF1ZXN0VHlwZSksXG4gICAgICAgIHJlcXVlc3REZXNlcmlhbGl6ZTogY3JlYXRlRGVzZXJpYWxpemVyKHJlcXVlc3RUeXBlLCBvcHRpb25zKSxcbiAgICAgICAgcmVzcG9uc2VTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVzcG9uc2VUeXBlKSxcbiAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogY3JlYXRlRGVzZXJpYWxpemVyKHJlc3BvbnNlVHlwZSwgb3B0aW9ucyksXG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXNcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBjYW1lbENhc2UobWV0aG9kLm5hbWUpLFxuICAgICAgICByZXF1ZXN0VHlwZTogY3JlYXRlTWVzc2FnZURlZmluaXRpb24ocmVxdWVzdFR5cGUsIGZpbGVEZXNjcmlwdG9ycyksXG4gICAgICAgIHJlc3BvbnNlVHlwZTogY3JlYXRlTWVzc2FnZURlZmluaXRpb24ocmVzcG9uc2VUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihzZXJ2aWNlLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBzZXJ2aWNlLm1ldGhvZHNBcnJheSkge1xuICAgICAgICBkZWZbbWV0aG9kLm5hbWVdID0gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihtZXNzYWdlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGVzY3JpcHRvciA9IG1lc3NhZ2UudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBEZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBtZXNzYWdlRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChtZXNzYWdlRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbnVtRGVmaW5pdGlvbihlbnVtVHlwZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZW51bURlc2NyaXB0b3IgPSBlbnVtVHlwZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIEVudW1EZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBlbnVtRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChlbnVtRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG4vKipcbiAqIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5TZXJ2aWNlLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6XG4gKiBPcHRpb25zKTogU2VydmljZURlZmluaXRpb247IGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5UeXBlLFxuICogbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTogTWVzc2FnZVR5cGVEZWZpbml0aW9uOyBmdW5jdGlvblxuICogY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLkVudW0sIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6XG4gKiBFbnVtVHlwZURlZmluaXRpb247XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmljZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1EZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBtaXNtYXRjaCBpbiByZWZsZWN0aW9uIG9iamVjdCBoYW5kbGluZycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yTGlzdCA9IHJvb3QudG9EZXNjcmlwdG9yKCdwcm90bzMnKS5maWxlO1xuICAgIGNvbnN0IGJ1ZmZlckxpc3QgPSBkZXNjcmlwdG9yTGlzdC5tYXAodmFsdWUgPT4gQnVmZmVyLmZyb20oZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclByb3RvLmVuY29kZSh2YWx1ZSkuZmluaXNoKCkpKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBvYmpdIG9mIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhyb290LCAnJykpIHtcbiAgICAgICAgZGVmW25hbWVdID0gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGJ1ZmZlckxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21EZXNjcmlwdG9yKGRlY29kZWREZXNjcmlwdG9yU2V0KTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIExvYWQgYSAucHJvdG8gZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAqIEBwYXJhbSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZSBwYXRocyB0byBsb2FkLiBDYW4gYmUgYW4gYWJzb2x1dGUgcGF0aFxuICogICAgIG9yIHJlbGF0aXZlIHRvIGFuIGluY2x1ZGUgcGF0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmtlZXBDYXNlIFByZXNlcnZlIGZpZWxkIG5hbWVzLiBUaGUgZGVmYXVsdCBpcyB0byBjaGFuZ2UgdGhlbVxuICogICAgIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0gb3B0aW9ucy5sb25ncyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgbG9uZ2AgdmFsdWVzLlxuICogICAgIFZhbGlkIG9wdGlvbnMgYXJlIGBOdW1iZXJgIGFuZCBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gYSBgTG9uZ2Agb2JqZWN0IHR5cGVcbiAqICAgICBmcm9tIGEgbGlicmFyeS5cbiAqIEBwYXJhbSBvcHRpb25zLmVudW1zIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBlbnVtYCB2YWx1ZXMuXG4gKiAgICAgVGhlIG9ubHkgdmFsaWQgb3B0aW9uIGlzIGBTdHJpbmdgLiBEZWZhdWx0cyB0byB0aGUgbnVtZXJpYyB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zLmJ5dGVzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBieXRlc2BcbiAqICAgICB2YWx1ZXMuIFZhbGlkIG9wdGlvbnMgYXJlIGBBcnJheWAgYW5kIGBTdHJpbmdgLiBUaGUgZGVmYXVsdCBpcyB0byB1c2VcbiAqICAgICBgQnVmZmVyYC5cbiAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRzIFNldCBkZWZhdWx0IHZhbHVlcyBvbiBvdXRwdXQgb2JqZWN0cy4gRGVmYXVsdHMgdG9cbiAqICAgICBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMuYXJyYXlzIFNldCBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgYXJyYXkgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vYmplY3RzIFNldCBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG9iamVjdCB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9uZW9mcyBTZXQgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHRvIHRoZSBwcmVzZW50IGZpZWxkJ3NcbiAqICAgICBuYW1lXG4gKiBAcGFyYW0gb3B0aW9ucy5qc29uIFJlcHJlc2VudCBJbmZpbml0eSBhbmQgTmFOIGFzIHN0cmluZ3MgaW4gZmxvYXQgZmllbGRzLFxuICogICAgIGFuZCBhdXRvbWF0aWNhbGx5IGRlY29kZSBnb29nbGUucHJvdG9idWYuQW55IHZhbHVlcy5cbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVEaXJzIFBhdGhzIHRvIHNlYXJjaCBmb3IgaW1wb3J0ZWQgYC5wcm90b2AgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9ucyhmaWxlbmFtZSwgb3B0aW9ucykudGhlbihsb2FkZWRSb290ID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbUpTT04oanNvbik7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcihkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdChkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmZyb21PYmplY3QoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdDtcbnV0aWxfMS5hZGRDb21tb25Qcm90b3MoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */\nfunction addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSx3Q0FBd0MsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHFHQUFxQztBQUN2RSxpQ0FBaUMsbUJBQU8sQ0FBQyxtSEFBNEM7QUFDckYsb0NBQW9DLG1CQUFPLENBQUMsMkhBQWdEO0FBQzVGLDJCQUEyQixtQkFBTyxDQUFDLHVHQUFzQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlmbGFzaGNhcmRzLy4vbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvdXRpbC5qcz9mNjc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\nvar Long = (function(exports) {\n  \"use strict\";\n  \n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = void 0;\n  \n  /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */\n  // WebAssembly optimizations to do native i64 multiplication and divide\n  var wasm = null;\n  \n  try {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n  } catch (e) {// no wasm support :(\n  }\n  /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */\n  \n  \n  function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n  \n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n  \n    this.unsigned = !!unsigned;\n  } // The internal representation of a long is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // Javascript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within Javascript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n  \n  /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */\n  \n  \n  Long.prototype.__isLong__;\n  Object.defineProperty(Long.prototype, \"__isLong__\", {\n    value: true\n  });\n  /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */\n  \n  function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n  }\n  /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */\n  \n  \n  function ctz32(value) {\n    var c = Math.clz32(value & -value);\n    return value ? 31 - c : c;\n  }\n  /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */\n  \n  \n  Long.isLong = isLong;\n  /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var INT_CACHE = {};\n  /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var UINT_CACHE = {};\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n  \n    if (unsigned) {\n      value >>>= 0;\n  \n      if (cache = 0 <= value && value < 256) {\n        cachedObj = UINT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, 0, true);\n      if (cache) UINT_CACHE[value] = obj;\n      return obj;\n    } else {\n      value |= 0;\n  \n      if (cache = -128 <= value && value < 128) {\n        cachedObj = INT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, value < 0 ? -1 : 0, false);\n      if (cache) INT_CACHE[value] = obj;\n      return obj;\n    }\n  }\n  /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromInt = fromInt;\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromNumber(value, unsigned) {\n    if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  \n    if (unsigned) {\n      if (value < 0) return UZERO;\n      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    } else {\n      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n    }\n  \n    if (value < 0) return fromNumber(-value, unsigned).neg();\n    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n  }\n  /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromNumber = fromNumber;\n  /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n  }\n  /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBits = fromBits;\n  /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */\n  \n  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n  \n  /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromString(str, unsigned, radix) {\n    if (str.length === 0) throw Error('empty string');\n  \n    if (typeof unsigned === 'number') {\n      // For goog.math.long compatibility\n      radix = unsigned;\n      unsigned = false;\n    } else {\n      unsigned = !!unsigned;\n    }\n  \n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    var p;\n    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {\n      return fromString(str.substring(1), unsigned, radix).neg();\n    } // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n  \n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i),\n          value = parseInt(str.substring(i, i + size), radix);\n  \n      if (size < 8) {\n        var power = fromNumber(pow_dbl(radix, size));\n        result = result.mul(power).add(fromNumber(value));\n      } else {\n        result = result.mul(radixToPower);\n        result = result.add(fromNumber(value));\n      }\n    }\n  \n    result.unsigned = unsigned;\n    return result;\n  }\n  /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromString = fromString;\n  /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromValue(val, unsigned) {\n    if (typeof val === 'number') return fromNumber(val, unsigned);\n    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n  \n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n  }\n  /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */\n  \n  \n  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n  // no runtime penalty for these.\n  \n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_16_DBL = 1 << 16;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24_DBL = 1 << 24;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n  /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ZERO = fromInt(0);\n  /**\n   * Signed zero.\n   * @type {!Long}\n   */\n  \n  Long.ZERO = ZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UZERO = fromInt(0, true);\n  /**\n   * Unsigned zero.\n   * @type {!Long}\n   */\n  \n  Long.UZERO = UZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ONE = fromInt(1);\n  /**\n   * Signed one.\n   * @type {!Long}\n   */\n  \n  Long.ONE = ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UONE = fromInt(1, true);\n  /**\n   * Unsigned one.\n   * @type {!Long}\n   */\n  \n  Long.UONE = UONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var NEG_ONE = fromInt(-1);\n  /**\n   * Signed negative one.\n   * @type {!Long}\n   */\n  \n  Long.NEG_ONE = NEG_ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n  /**\n   * Maximum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_VALUE = MAX_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n  /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n  /**\n   * Minimum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MIN_VALUE = MIN_VALUE;\n  /**\n   * @alias Long.prototype\n   * @inner\n   */\n  \n  var LongPrototype = Long.prototype;\n  /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  LongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n  };\n  /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.toNumber = function toNumber() {\n    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n  };\n  /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */\n  \n  \n  LongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    if (this.isZero()) return '0';\n  \n    if (this.isNegative()) {\n      // Unsigned Longs are never negative\n      if (this.eq(MIN_VALUE)) {\n        // We need to change the Long value before it can be negated, so we remove\n        // the bottom-most digit in this base and then recurse to do the rest.\n        var radixLong = fromNumber(radix),\n            div = this.div(radixLong),\n            rem1 = div.mul(radixLong).sub(this);\n        return div.toString(radix) + rem1.toInt().toString(radix);\n      } else return '-' + this.neg().toString(radix);\n    } // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n  \n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n  \n    while (true) {\n      var remDiv = rem.div(radixToPower),\n          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n          digits = intval.toString(radix);\n      rem = remDiv;\n      if (rem.isZero()) return digits + result;else {\n        while (digits.length < 6) digits = '0' + digits;\n  \n        result = '' + digits + result;\n      }\n    }\n  };\n  /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */\n  \n  \n  LongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n  };\n  /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */\n  \n  \n  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n  };\n  /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */\n  \n  \n  LongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n  };\n  /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */\n  \n  \n  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n  };\n  /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n  \n    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;\n  \n    return this.high != 0 ? bit + 33 : bit + 1;\n  };\n  /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n  };\n  /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eqz = LongPrototype.isZero;\n  /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  LongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n  };\n  /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n  };\n  /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n  };\n  /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n  };\n  /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.equals = function equals(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  };\n  /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eq = LongPrototype.equals;\n  /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(\n    /* validates */\n    other);\n  };\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.neq = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ne = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThan = function lessThan(other) {\n    return this.comp(\n    /* validates */\n    other) < 0;\n  };\n  /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lt = LongPrototype.lessThan;\n  /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) <= 0;\n  };\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lte = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.le = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(\n    /* validates */\n    other) > 0;\n  };\n  /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gt = LongPrototype.greaterThan;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) >= 0;\n  };\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n  /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  LongPrototype.compare = function compare(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.eq(other)) return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) return -1;\n    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n  \n    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n  \n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n  };\n  /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  \n  LongPrototype.comp = LongPrototype.compare;\n  /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */\n  \n  LongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n    return this.not().add(ONE);\n  };\n  /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */\n  \n  \n  LongPrototype.neg = LongPrototype.negate;\n  /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */\n  \n  LongPrototype.add = function add(addend) {\n    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n  };\n  /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.sub = LongPrototype.subtract;\n  /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  LongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero()) return this;\n    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n  \n    if (wasm) {\n      var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n  \n    if (this.isNegative()) {\n      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n  \n  \n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  \n  LongPrototype.mul = LongPrototype.multiply;\n  /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  LongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor);\n    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present\n  \n    if (wasm) {\n      // guard against signed division overflow: the largest\n      // negative number / -1 would be 1 larger than the largest\n      // positive number, due to two's complement.\n      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n        // be consistent with non-wasm code path\n        return this;\n      }\n  \n      var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n  \n    if (!this.unsigned) {\n      // This section is only relevant for signed longs and is derived from the\n      // closure library as a whole.\n      if (this.eq(MIN_VALUE)) {\n        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n        else if (divisor.eq(MIN_VALUE)) return ONE;else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = this.shr(1);\n          approx = halfThis.div(divisor).shl(1);\n  \n          if (approx.eq(ZERO)) {\n            return divisor.isNegative() ? ONE : NEG_ONE;\n          } else {\n            rem = this.sub(divisor.mul(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n  \n      if (this.isNegative()) {\n        if (divisor.isNegative()) return this.neg().div(divisor.neg());\n        return this.neg().div(divisor).neg();\n      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n  \n      res = ZERO;\n    } else {\n      // The algorithm below has not been made for unsigned longs. It's therefore\n      // required to take special care of the MSB prior to running it.\n      if (!divisor.unsigned) divisor = divisor.toUnsigned();\n      if (divisor.gt(this)) return UZERO;\n      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n        return UONE;\n      res = UZERO;\n    } // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n  \n  \n    rem = this;\n  \n    while (rem.gte(divisor)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n      // the smallest non-fractional digit, whichever is larger.\n  \n      var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n          // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n          approxRem = approxRes.mul(divisor);\n  \n      while (approxRem.isNegative() || approxRem.gt(rem)) {\n        approx -= delta;\n        approxRes = fromNumber(approx, this.unsigned);\n        approxRem = approxRes.mul(divisor);\n      } // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n  \n  \n      if (approxRes.isZero()) approxRes = ONE;\n      res = res.add(approxRes);\n      rem = rem.sub(approxRem);\n    }\n  \n    return res;\n  };\n  /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  \n  LongPrototype.div = LongPrototype.divide;\n  /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n  \n    if (wasm) {\n      var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    return this.sub(this.div(divisor).mul(divisor));\n  };\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  \n  LongPrototype.mod = LongPrototype.modulo;\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.rem = LongPrototype.modulo;\n  /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */\n  \n  LongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n  };\n  /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.countLeadingZeros = function countLeadingZeros() {\n    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n  };\n  /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.clz = LongPrototype.countLeadingZeros;\n  /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */\n  \n  LongPrototype.countTrailingZeros = function countTrailingZeros() {\n    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n  };\n  /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.ctz = LongPrototype.countTrailingZeros;\n  /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  LongPrototype.and = function and(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.or = function or(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.xor = function xor(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shl = LongPrototype.shiftLeft;\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shr = LongPrototype.shiftRight;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotl = LongPrototype.rotateLeft;\n  /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotr = LongPrototype.rotateRight;\n  /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */\n  \n  LongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned) return this;\n    return fromBits(this.low, this.high, false);\n  };\n  /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */\n  \n  \n  LongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned) return this;\n    return fromBits(this.low, this.high, true);\n  };\n  /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */\n  \n  \n  LongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n  };\n  /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];\n  };\n  /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];\n  };\n  /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n  };\n  /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n  };\n  /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n  };\n  \n  var _default = Long;\n  exports.default = _default;\n  return \"default\" in exports ? exports.default : exports;\n})({});\nif (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Long; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOHNDQUE4c0M7QUFDOXNDLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFNBQVM7QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCLCtDQUErQztBQUNsRixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0IsK0NBQStDO0FBQ2xGLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQjtBQUNwRixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGtCQUFrQjtBQUMvRjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxxQkFBcUI7QUFDbEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxxQkFBcUI7QUFDbEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsb0JBQW9CO0FBQ3ZHO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RiwyQkFBMkI7QUFDdkg7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RiwyQkFBMkI7QUFDdkg7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRix1QkFBdUI7QUFDN0c7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLDhCQUE4QjtBQUM3SDtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLDhCQUE4QjtBQUM3SDtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbUJBQW1CO0FBQzlGO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxxQkFBcUI7QUFDbEMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsb0JBQW9CO0FBQ3JHO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSxNQUFNLDJFQUEyRTtBQUNqRjtBQUNBO0FBQ0EscUlBQXFJO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLG9CQUFvQjtBQUNsRztBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxrQkFBa0I7QUFDeEY7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQjtBQUNwRjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQjtBQUNwRjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0EsYUFBYTtBQUNiLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxjQUFjO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZIQUE2SDtBQUN4SztBQUNBO0FBQ0EsK0ZBQStGLHFCQUFxQjtBQUNwSDtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEhBQThIO0FBQ3pLO0FBQ0E7QUFDQSwrR0FBK0csc0JBQXNCO0FBQ3JJO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osYUFBYSxjQUFjO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyw4QkFBOEI7QUFDeEk7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsOEJBQThCO0FBQ3hJO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHNCQUFzQjtBQUNySDtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHVCQUF1QjtBQUN2SDtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsWUFBWTtBQUNaLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMLElBQUksSUFBMEMsRUFBRSxpQ0FBTyxFQUFFLG1DQUFFLGFBQWEsY0FBYztBQUFBLGtHQUFDO0FBQ3ZGLEtBQUssRUFBcUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haWZsYXNoY2FyZHMvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanM/MmU3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQuXG52YXIgTG9uZyA9IChmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnNcbiAgICogQ29weXJpZ2h0IDIwMjAgRGFuaWVsIFdpcnR6IC8gVGhlIGxvbmcuanMgQXV0aG9ycy5cbiAgICpcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICpcbiAgICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAqXG4gICAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gICAqL1xuICAvLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxuICB2YXIgd2FzbSA9IG51bGw7XG4gIFxuICB0cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xuICB9IGNhdGNoIChlKSB7Ly8gbm8gd2FzbSBzdXBwb3J0IDooXG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gICAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxuICAgKiBAZXhwb3J0cyBMb25nXG4gICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIFxuICBcbiAgZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gIFxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICB9IC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4gIC8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXG4gIC8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4gIC8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XG4gIC8vIG9yIGNoYW5nZSBpbiBzaWduLlxuICAvL1xuICAvLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXG4gIC8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbiAgLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xuICAvLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4gIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy9cbiAgLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4gIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG4gIFxuICAvKipcbiAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGNvbnN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBcbiAgXG4gIExvbmcucHJvdG90eXBlLl9faXNMb25nX187XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgbnVtYmVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIFxuICBmdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICAgIHZhciBjID0gTWF0aC5jbHozMih2YWx1ZSAmIC12YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYztcbiAgfVxuICAvKipcbiAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmlzTG9uZyA9IGlzTG9uZztcbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIElOVF9DQUNIRSA9IHt9O1xuICAvKipcbiAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gICAqIEB0eXBlIHshT2JqZWN0fVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICBcbiAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgIHZhbHVlID4+Pj0gMDtcbiAgXG4gICAgICBpZiAoY2FjaGUgPSAwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSB7XG4gICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICBcbiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICAgIGlmIChjYWNoZSkgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSB8PSAwO1xuICBcbiAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcbiAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgIH1cbiAgXG4gICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XG4gICAgICBpZiAoY2FjaGUpIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tSW50ID0gZnJvbUludDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICBcbiAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBVWkVSTztcbiAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpIHJldHVybiBNQVhfVkFMVUU7XG4gICAgfVxuICBcbiAgICBpZiAodmFsdWUgPCAwKSByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcbiAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG4gIFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxuICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XG4gIFxuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgICAgcmFkaXggPSB1bnNpZ25lZDtcbiAgICAgIHVuc2lnbmVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICB9XG4gIFxuICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIikgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICAgIHZhciBwO1xuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMCkgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO2Vsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gICAgfSAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIFxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcbiAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgXG4gICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpOyAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICBcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlOyAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXG4gIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG4gIFxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xuICAvKipcbiAgICogU2lnbmVkIHplcm8uXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLlpFUk8gPSBaRVJPO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xuICAvKipcbiAgICogVW5zaWduZWQgemVyby5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuVVpFUk8gPSBVWkVSTztcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE9ORSA9IGZyb21JbnQoMSk7XG4gIC8qKlxuICAgKiBTaWduZWQgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5PTkUgPSBPTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcbiAgLyoqXG4gICAqIFVuc2lnbmVkIG9uZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuVU9ORSA9IFVPTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XG4gIC8qKlxuICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweDdGRkZGRkZGIHwgMCwgZmFsc2UpO1xuICAvKipcbiAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweEZGRkZGRkZGIHwgMCwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCwgZmFsc2UpO1xuICAvKipcbiAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcbiAgLyoqXG4gICAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAnMCc7XG4gIFxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxuICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xuICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICB9IGVsc2UgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICAgIH0gLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICBcbiAgXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgICAgICByZW0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXG4gICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgIHJlbSA9IHJlbURpdjtcbiAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7ZWxzZSB7XG4gICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNikgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICBcbiAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xuICBcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApIGJyZWFrO1xuICBcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gIXRoaXMuZXEoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpIDwgMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA8PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA+PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gMDtcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHJldHVybiAtMTtcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpIHJldHVybiAxOyAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gIFxuICAgIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7IC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICBcbiAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7XG4gIH07XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcbiAgLyoqXG4gICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xuICB9O1xuICAvKipcbiAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSkgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7IC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxuICBcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKSBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSkgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTsgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIFxuICAgIGlmICh3YXNtKSB7XG4gICAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtlbHNlIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7IC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cbiAgXG4gIFxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7IC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG4gIFxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICogYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiAqIGIwMDtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMxNiArPSBhMDAgKiBiMTY7XG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgYzE2ICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTMyICogYjAwO1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGExNiAqIGIxNjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMDAgKiBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcbiAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgIGlmIChkaXZpc29yLmlzWmVybygpKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxuICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxuICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXG4gICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKSByZXR1cm4gTUlOX1ZBTFVFOyAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxuICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiBPTkU7ZWxzZSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xuICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gIFxuICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIFxuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gIFxuICAgICAgcmVzID0gWkVSTztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXG4gICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXG4gICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKSByZXR1cm4gVVpFUk87XG4gICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxuICAgICAgICByZXR1cm4gVU9ORTtcbiAgICAgIHJlcyA9IFVaRVJPO1xuICAgIH0gLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXG4gICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cbiAgXG4gIFxuICAgIHJlbSA9IHRoaXM7XG4gIFxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXG4gICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxuICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICBcbiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICAgICAgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcbiAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcbiAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxuICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gIFxuICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICB9IC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gIFxuICBcbiAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIGFwcHJveFJlcyA9IE9ORTtcbiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJyZW1fdVwiXSA6IHdhc21bXCJyZW1fc1wiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRMZWFkaW5nWmVyb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRMZWFkaW5nWmVyb3N9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICAgIHJldHVybiB0aGlzLmxvdyA/IGN0ejMyKHRoaXMubG93KSA6IGN0ejMyKHRoaXMuaGlnaCkgKyAzMjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRUcmFpbGluZ1plcm9zfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO2Vsc2UgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7ZWxzZSByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7ZWxzZSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gICAgdmFyIGI7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgXG4gICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykge1xuICAgIHZhciBiO1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIFxuICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICBudW1CaXRzIC09IDMyO1xuICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IGIgfCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBiIHwgdGhpcy5sb3cgPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlUmlnaHR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xuICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW2xvICYgMHhmZiwgbG8gPj4+IDggJiAweGZmLCBsbyA+Pj4gMTYgJiAweGZmLCBsbyA+Pj4gMjQsIGhpICYgMHhmZiwgaGkgPj4+IDggJiAweGZmLCBoaSA+Pj4gMTYgJiAweGZmLCBoaSA+Pj4gMjRdO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW2hpID4+PiAyNCwgaGkgPj4+IDE2ICYgMHhmZiwgaGkgPj4+IDggJiAweGZmLCBoaSAmIDB4ZmYsIGxvID4+PiAyNCwgbG8gPj4+IDE2ICYgMHhmZiwgbG8gPj4+IDggJiAweGZmLCBsbyAmIDB4ZmZdO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpO1xuICB9O1xuICBcbiAgdmFyIF9kZWZhdWx0ID0gTG9uZztcbiAgZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4gIHJldHVybiBcImRlZmF1bHRcIiBpbiBleHBvcnRzID8gZXhwb3J0cy5kZWZhdWx0IDogZXhwb3J0cztcbn0pKHt9KTtcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBMb25nOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBMb25nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/api.json":
/*!*************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/api.json ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Api":{"fields":{"name":{"type":"string","id":1},"methods":{"rule":"repeated","type":"Method","id":2},"options":{"rule":"repeated","type":"Option","id":3},"version":{"type":"string","id":4},"sourceContext":{"type":"SourceContext","id":5},"mixins":{"rule":"repeated","type":"Mixin","id":6},"syntax":{"type":"Syntax","id":7}}},"Method":{"fields":{"name":{"type":"string","id":1},"requestTypeUrl":{"type":"string","id":2},"requestStreaming":{"type":"bool","id":3},"responseTypeUrl":{"type":"string","id":4},"responseStreaming":{"type":"bool","id":5},"options":{"rule":"repeated","type":"Option","id":6},"syntax":{"type":"Syntax","id":7}}},"Mixin":{"fields":{"name":{"type":"string","id":1},"root":{"type":"string","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json":
/*!********************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"FileDescriptorSet":{"fields":{"file":{"rule":"repeated","type":"FileDescriptorProto","id":1}}},"FileDescriptorProto":{"fields":{"name":{"type":"string","id":1},"package":{"type":"string","id":2},"dependency":{"rule":"repeated","type":"string","id":3},"publicDependency":{"rule":"repeated","type":"int32","id":10,"options":{"packed":false}},"weakDependency":{"rule":"repeated","type":"int32","id":11,"options":{"packed":false}},"messageType":{"rule":"repeated","type":"DescriptorProto","id":4},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":5},"service":{"rule":"repeated","type":"ServiceDescriptorProto","id":6},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":7},"options":{"type":"FileOptions","id":8},"sourceCodeInfo":{"type":"SourceCodeInfo","id":9},"syntax":{"type":"string","id":12}}},"DescriptorProto":{"fields":{"name":{"type":"string","id":1},"field":{"rule":"repeated","type":"FieldDescriptorProto","id":2},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":6},"nestedType":{"rule":"repeated","type":"DescriptorProto","id":3},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":4},"extensionRange":{"rule":"repeated","type":"ExtensionRange","id":5},"oneofDecl":{"rule":"repeated","type":"OneofDescriptorProto","id":8},"options":{"type":"MessageOptions","id":7},"reservedRange":{"rule":"repeated","type":"ReservedRange","id":9},"reservedName":{"rule":"repeated","type":"string","id":10}},"nested":{"ExtensionRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}},"ReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"FieldDescriptorProto":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":3},"label":{"type":"Label","id":4},"type":{"type":"Type","id":5},"typeName":{"type":"string","id":6},"extendee":{"type":"string","id":2},"defaultValue":{"type":"string","id":7},"oneofIndex":{"type":"int32","id":9},"jsonName":{"type":"string","id":10},"options":{"type":"FieldOptions","id":8}},"nested":{"Type":{"values":{"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Label":{"values":{"LABEL_OPTIONAL":1,"LABEL_REQUIRED":2,"LABEL_REPEATED":3}}}},"OneofDescriptorProto":{"fields":{"name":{"type":"string","id":1},"options":{"type":"OneofOptions","id":2}}},"EnumDescriptorProto":{"fields":{"name":{"type":"string","id":1},"value":{"rule":"repeated","type":"EnumValueDescriptorProto","id":2},"options":{"type":"EnumOptions","id":3}}},"EnumValueDescriptorProto":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"type":"EnumValueOptions","id":3}}},"ServiceDescriptorProto":{"fields":{"name":{"type":"string","id":1},"method":{"rule":"repeated","type":"MethodDescriptorProto","id":2},"options":{"type":"ServiceOptions","id":3}}},"MethodDescriptorProto":{"fields":{"name":{"type":"string","id":1},"inputType":{"type":"string","id":2},"outputType":{"type":"string","id":3},"options":{"type":"MethodOptions","id":4},"clientStreaming":{"type":"bool","id":5},"serverStreaming":{"type":"bool","id":6}}},"FileOptions":{"fields":{"javaPackage":{"type":"string","id":1},"javaOuterClassname":{"type":"string","id":8},"javaMultipleFiles":{"type":"bool","id":10},"javaGenerateEqualsAndHash":{"type":"bool","id":20,"options":{"deprecated":true}},"javaStringCheckUtf8":{"type":"bool","id":27},"optimizeFor":{"type":"OptimizeMode","id":9,"options":{"default":"SPEED"}},"goPackage":{"type":"string","id":11},"ccGenericServices":{"type":"bool","id":16},"javaGenericServices":{"type":"bool","id":17},"pyGenericServices":{"type":"bool","id":18},"deprecated":{"type":"bool","id":23},"ccEnableArenas":{"type":"bool","id":31},"objcClassPrefix":{"type":"string","id":36},"csharpNamespace":{"type":"string","id":37},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[38,38]],"nested":{"OptimizeMode":{"values":{"SPEED":1,"CODE_SIZE":2,"LITE_RUNTIME":3}}}},"MessageOptions":{"fields":{"messageSetWireFormat":{"type":"bool","id":1},"noStandardDescriptorAccessor":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"mapEntry":{"type":"bool","id":7},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[8,8]]},"FieldOptions":{"fields":{"ctype":{"type":"CType","id":1,"options":{"default":"STRING"}},"packed":{"type":"bool","id":2},"jstype":{"type":"JSType","id":6,"options":{"default":"JS_NORMAL"}},"lazy":{"type":"bool","id":5},"deprecated":{"type":"bool","id":3},"weak":{"type":"bool","id":10},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4]],"nested":{"CType":{"values":{"STRING":0,"CORD":1,"STRING_PIECE":2}},"JSType":{"values":{"JS_NORMAL":0,"JS_STRING":1,"JS_NUMBER":2}}}},"OneofOptions":{"fields":{"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumOptions":{"fields":{"allowAlias":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumValueOptions":{"fields":{"deprecated":{"type":"bool","id":1},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"ServiceOptions":{"fields":{"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"MethodOptions":{"fields":{"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"UninterpretedOption":{"fields":{"name":{"rule":"repeated","type":"NamePart","id":2},"identifierValue":{"type":"string","id":3},"positiveIntValue":{"type":"uint64","id":4},"negativeIntValue":{"type":"int64","id":5},"doubleValue":{"type":"double","id":6},"stringValue":{"type":"bytes","id":7},"aggregateValue":{"type":"string","id":8}},"nested":{"NamePart":{"fields":{"namePart":{"rule":"required","type":"string","id":1},"isExtension":{"rule":"required","type":"bool","id":2}}}}},"SourceCodeInfo":{"fields":{"location":{"rule":"repeated","type":"Location","id":1}},"nested":{"Location":{"fields":{"path":{"rule":"repeated","type":"int32","id":1},"span":{"rule":"repeated","type":"int32","id":2},"leadingComments":{"type":"string","id":3},"trailingComments":{"type":"string","id":4},"leadingDetachedComments":{"rule":"repeated","type":"string","id":6}}}}},"GeneratedCodeInfo":{"fields":{"annotation":{"rule":"repeated","type":"Annotation","id":1}},"nested":{"Annotation":{"fields":{"path":{"rule":"repeated","type":"int32","id":1},"sourceFile":{"type":"string","id":2},"begin":{"type":"int32","id":3},"end":{"type":"int32","id":4}}}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/source_context.json":
/*!************************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/source_context.json ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/type.json":
/*!**************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/type.json ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Type":{"fields":{"name":{"type":"string","id":1},"fields":{"rule":"repeated","type":"Field","id":2},"oneofs":{"rule":"repeated","type":"string","id":3},"options":{"rule":"repeated","type":"Option","id":4},"sourceContext":{"type":"SourceContext","id":5},"syntax":{"type":"Syntax","id":6}}},"Field":{"fields":{"kind":{"type":"Kind","id":1},"cardinality":{"type":"Cardinality","id":2},"number":{"type":"int32","id":3},"name":{"type":"string","id":4},"typeUrl":{"type":"string","id":6},"oneofIndex":{"type":"int32","id":7},"packed":{"type":"bool","id":8},"options":{"rule":"repeated","type":"Option","id":9},"jsonName":{"type":"string","id":10},"defaultValue":{"type":"string","id":11}},"nested":{"Kind":{"values":{"TYPE_UNKNOWN":0,"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Cardinality":{"values":{"CARDINALITY_UNKNOWN":0,"CARDINALITY_OPTIONAL":1,"CARDINALITY_REQUIRED":2,"CARDINALITY_REPEATED":3}}}},"Enum":{"fields":{"name":{"type":"string","id":1},"enumvalue":{"rule":"repeated","type":"EnumValue","id":2},"options":{"rule":"repeated","type":"Option","id":3},"sourceContext":{"type":"SourceContext","id":4},"syntax":{"type":"Syntax","id":5}}},"EnumValue":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"rule":"repeated","type":"Option","id":3}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}},"Any":{"fields":{"type_url":{"type":"string","id":1},"value":{"type":"bytes","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@grpc/grpc-js","version":"1.7.3","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.108","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","clang-format":"^1.0.55","execa":"^2.0.3","gts":"^2.0.0","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^8.3.0","typescript":"^3.7.2"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"npm run check","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"gts check src/**/*.ts","fix":"gts fix src/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.0","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;